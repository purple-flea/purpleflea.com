<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Build an NFT Sniping AI Agent â€” Purple Flea</title>
<meta name="description" content="Complete guide to building an autonomous NFT sniping AI agent: monitor floor prices on Blur, OpenSea and Magic Eden, identify underpriced NFTs, execute instant buys with the Purple Flea Wallet API, and manage risk.">
<link rel="canonical" href="https://purpleflea.com/nft-sniping-agent/">
<meta property="og:title" content="Build an NFT Sniping AI Agent â€” Purple Flea">
<meta property="og:description" content="Complete guide to building an autonomous NFT sniping AI agent: monitor floor prices, identify underpriced NFTs, execute instant buys, and manage risk with the Purple Flea Wallet API.">
<meta property="og:url" content="https://purpleflea.com/nft-sniping-agent/">
<meta property="og:type" content="website">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="Build an NFT Sniping AI Agent â€” Purple Flea">
<meta name="twitter:description" content="Monitor floor prices, identify underpriced NFTs, and execute instant buys autonomously with the Purple Flea Wallet API.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Build an NFT Sniping AI Agent",
  "url": "https://purpleflea.com/nft-sniping-agent/",
  "description": "Complete guide to building an autonomous NFT sniping agent using the Purple Flea Wallet API for instant on-chain purchases.",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" }
}
</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŸ£</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7;
  --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B;
  --bg-card: rgba(255, 255, 255, 0.03);
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(168, 85, 247, 0.3);
  --text: #FAFAFA;
  --text-secondary: #A1A1AA;
  --text-muted: #71717A;
  --radius: 16px;
  --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168, 85, 247, 0.3); border-radius: 3px; }
::selection { background: rgba(168, 85, 247, 0.4); color: white; }
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.reveal { opacity: 0; transform: translateY(30px); transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), transform 0.8s cubic-bezier(0.16, 1, 0.3, 1); }
.reveal.visible { opacity: 1; transform: translateY(0); }
.reveal-delay-1 { transition-delay: 0.1s; }
.reveal-delay-2 { transition-delay: 0.2s; }
.reveal-delay-3 { transition-delay: 0.3s; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9, 9, 11, 0.8); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* HERO */
.hero { min-height: 80vh; display: flex; align-items: center; justify-content: center; position: relative; padding: 120px 0 80px; overflow: hidden; }
.hero-bg { position: absolute; inset: 0; overflow: hidden; }
.hero-gradient-1 { position: absolute; top: -30%; left: 50%; transform: translateX(-50%); width: 900px; height: 600px; background: radial-gradient(ellipse, rgba(168, 85, 247, 0.15) 0%, transparent 70%); filter: blur(60px); }
.hero-grid { position: absolute; inset: 0; background-image: linear-gradient(rgba(168, 85, 247, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(168, 85, 247, 0.03) 1px, transparent 1px); background-size: 60px 60px; mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); -webkit-mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); }
.hero-content { position: relative; text-align: center; max-width: 860px; margin: 0 auto; padding: 0 24px; }
.hero-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 16px 6px 8px; background: var(--purple-subtle); border: 1px solid rgba(168, 85, 247, 0.15); border-radius: 100px; font-size: 13px; font-weight: 500; color: var(--purple); margin-bottom: 32px; animation: fadeInDown 0.8s ease; }
.hero-badge-dot { width: 8px; height: 8px; background: var(--purple); border-radius: 50%; animation: badge-pulse 2s ease-in-out infinite; }
@keyframes badge-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
@keyframes fadeInDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
@keyframes gradient-shift { 0% { background-position: 0% center; } 50% { background-position: 100% center; } 100% { background-position: 0% center; } }
.hero h1 { font-size: clamp(2.5rem, 6vw, 4.5rem); font-weight: 800; line-height: 1.05; letter-spacing: -0.03em; margin-bottom: 24px; animation: fadeInUp 0.8s ease 0.1s both; }
.hero h1 .gradient { background: linear-gradient(135deg, var(--purple) 0%, #C084FC 50%, var(--purple) 100%); background-size: 200% auto; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: gradient-shift 5s ease infinite; }
.hero-desc { font-size: clamp(1rem, 2vw, 1.2rem); color: var(--text-secondary); margin-bottom: 40px; line-height: 1.7; animation: fadeInUp 0.8s ease 0.2s both; }
.hero-actions { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; animation: fadeInUp 0.8s ease 0.3s both; }
.btn-primary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--purple); color: white; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px; text-decoration: none; transition: all 0.2s; box-shadow: 0 0 30px rgba(168, 85, 247, 0.3); }
.btn-primary:hover { background: var(--purple-dim); transform: translateY(-2px); box-shadow: 0 0 40px rgba(168, 85, 247, 0.5); }
.btn-secondary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--bg-card); color: var(--text); border-radius: var(--radius-sm); font-weight: 500; font-size: 15px; text-decoration: none; border: 1px solid var(--border); transition: all 0.2s; }
.btn-secondary:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }

/* SECTIONS */
section { padding: 100px 0; position: relative; }
.section-label { display: inline-flex; align-items: center; gap: 12px; font-size: 12px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: var(--purple); margin-bottom: 20px; }
.section-label::before { content: ''; width: 24px; height: 1px; background: var(--purple); }
.section-title { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; }
.section-desc { font-size: 1.1rem; color: var(--text-secondary); max-width: 600px; margin-bottom: 60px; line-height: 1.7; }
.section-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 0; }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', monospace; font-size: 13.5px; line-height: 1.7; overflow-x: auto; position: relative; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }

/* GRID */
.grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; }
.grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; }
@media (max-width: 768px) { .grid-2, .grid-3 { grid-template-columns: 1fr; } }

/* CARDS */
.card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); padding: 32px; transition: all 0.3s ease; }
.card:hover { background: var(--bg-card-hover); border-color: var(--border-hover); transform: translateY(-4px); box-shadow: 0 20px 60px rgba(0,0,0,0.4), 0 0 30px rgba(168,85,247,0.05); }
.card-icon { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 22px; margin-bottom: 20px; }
.card-icon.purple { background: rgba(168, 85, 247, 0.15); }
.card-icon.blue { background: rgba(96, 165, 250, 0.15); }
.card-icon.green { background: rgba(34, 197, 94, 0.15); }
.card-icon.orange { background: rgba(251, 146, 60, 0.15); }
.card-icon.red { background: rgba(239, 68, 68, 0.15); }
.card-icon.yellow { background: rgba(251, 191, 36, 0.15); }
.card h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; }
.card p { color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6; }

/* MATH BOX / ARCH BOX */
.arch-box { background: rgba(0,0,0,0.5); border: 1px solid rgba(168,85,247,0.2); border-radius: var(--radius); padding: 32px; margin: 32px 0; font-family: 'JetBrains Mono', monospace; font-size: 14px; line-height: 1.9; color: var(--text-secondary); overflow-x: auto; }
.arch-box h4 { font-size: 12px; font-weight: 600; color: var(--purple); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 20px; font-family: 'Inter', sans-serif; }
.arch-node { color: var(--purple); font-weight: 600; }
.arch-arrow { color: var(--text-muted); }
.arch-label { color: var(--text-secondary); font-size: 12px; }

/* RULE LIST */
.rule-list { list-style: none; display: flex; flex-direction: column; gap: 16px; margin-top: 24px; }
.rule-list li { display: flex; align-items: flex-start; gap: 16px; padding: 20px; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); }
.rule-num { width: 28px; height: 28px; min-width: 28px; border-radius: 8px; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.2); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 12px; color: var(--purple); }
.rule-text { font-size: 14px; color: var(--text-secondary); line-height: 1.6; }
.rule-text strong { color: var(--text); }

/* CTA SECTION */
.cta-section { text-align: center; padding: 100px 0; }
.cta-box { background: linear-gradient(135deg, rgba(168,85,247,0.08) 0%, rgba(124,58,237,0.05) 100%); border: 1px solid rgba(168,85,247,0.2); border-radius: 24px; padding: 80px 40px; position: relative; overflow: hidden; }
.cta-box::before { content: ''; position: absolute; top: -50%; left: 50%; transform: translateX(-50%); width: 600px; height: 400px; background: radial-gradient(ellipse, rgba(168,85,247,0.1) 0%, transparent 70%); filter: blur(40px); pointer-events: none; }
.cta-box h2 { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; position: relative; }
.cta-box p { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 40px; position: relative; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }

/* RELATED LINKS */
.related-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
@media (max-width: 768px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }

/* ARTICLE PROSE */
.prose { max-width: 860px; }
.prose p { color: var(--text-secondary); font-size: 1rem; line-height: 1.8; margin-bottom: 20px; }
.prose p:last-child { margin-bottom: 0; }
.prose strong { color: var(--text); }
.prose code { background: rgba(168,85,247,0.1); padding: 2px 8px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.88em; color: var(--purple); }

/* FAQ */
.faq-item { border: 1px solid var(--border); border-radius: var(--radius-sm); margin-bottom: 12px; overflow: hidden; }
.faq-q { padding: 20px 24px; font-weight: 600; font-size: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.2s; }
.faq-q:hover { background: var(--bg-card); }
.faq-q .faq-arrow { color: var(--purple); font-size: 18px; transition: transform 0.3s; }
.faq-item.open .faq-arrow { transform: rotate(45deg); }
.faq-a { padding: 0 24px 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.7; display: none; }
.faq-item.open .faq-a { display: block; }

/* BADGE INLINE */
.badge-inline { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
.badge-green { background: rgba(34,197,94,0.15); color: #22C55E; }
.badge-yellow { background: rgba(251,191,36,0.15); color: #FBBF24; }
.badge-red { background: rgba(239,68,68,0.15); color: #EF4444; }
.badge-purple { background: rgba(168,85,247,0.15); color: var(--purple); }

/* STEP LIST */
.step-list { display: flex; flex-direction: column; gap: 0; counter-reset: steps; }
.step-item { display: grid; grid-template-columns: 40px 1fr; gap: 24px; padding: 28px 0; border-bottom: 1px solid var(--border); position: relative; }
.step-item:last-child { border-bottom: none; }
.step-number { width: 40px; height: 40px; min-width: 40px; border-radius: 50%; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.25); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 14px; color: var(--purple); margin-top: 2px; }
.step-content h4 { font-size: 1rem; font-weight: 600; margin-bottom: 8px; }
.step-content p { color: var(--text-secondary); font-size: 14px; line-height: 1.7; }
.step-content code { background: rgba(168,85,247,0.1); padding: 2px 8px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em; color: var(--purple); }
</style>
</head>
<body>

<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &#8594;</a></li>
    </ul>
  </div>
</nav>

<!-- HERO -->
<section class="hero">
  <div class="hero-bg">
    <div class="hero-gradient-1"></div>
    <div class="hero-grid"></div>
  </div>
  <div class="hero-content">
    <div class="hero-badge">
      <div class="hero-badge-dot"></div>
      Autonomous On-Chain Trading
    </div>
    <h1>Build an NFT Sniping<br><span class="gradient">AI Agent</span></h1>
    <p class="hero-desc">
      NFT markets move in milliseconds. Human traders cannot monitor hundreds of collections simultaneously
      or execute purchases the instant an underpriced listing appears. AI agents can.
      This guide walks through building a production-ready sniping agent backed by the
      Purple Flea Wallet API for zero-latency on-chain purchases.
    </p>
    <div class="hero-actions">
      <a href="https://wallet.purpleflea.com" class="btn-primary" target="_blank">Create a Wallet &#8594;</a>
      <a href="/crypto-wallet-api/" class="btn-secondary">Wallet API Docs</a>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- INTRO -->
<section>
  <div class="container">
    <div class="reveal prose">
      <div class="section-label">Introduction</div>
      <h2 class="section-title">What is NFT sniping,<br>and why agents win at it</h2>
      <p>
        NFT sniping is the practice of identifying and purchasing NFTs that are listed below their true market
        value before other buyers notice. These opportunities arise constantly: a holder in a hurry lists at
        the wrong price, a floor-price calculation lags reality, or a rare trait is incorrectly priced relative
        to the rest of a collection. The window to capture these trades is often ten to thirty seconds.
      </p>
      <p>
        Human traders have a fundamental ceiling: attention bandwidth. You can watch one collection at a time,
        on one marketplace at a time, and your reaction time from seeing a listing to executing a purchase
        adds browser latency, human processing time, and wallet confirmation steps. An AI agent has none of
        these limitations. It monitors hundreds of collections across Blur, OpenSea, and Magic Eden
        simultaneously, computes expected value against floor price in real time, and calls a wallet API
        to sign and broadcast a transaction â€” all in under a second.
      </p>
      <p>
        <strong>The edge is structural, not predictive.</strong> The agent does not need to forecast which
        NFTs will appreciate. It only needs to identify listings priced below the current market consensus,
        buy them, and list them back at or slightly below the current floor. Done at volume with tight
        risk controls, this produces consistent positive expectation.
      </p>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- ARCHITECTURE -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">System Architecture</div>
      <h2 class="section-title">How the agent<br>fits together</h2>
      <p class="section-desc">
        A sniping agent is a tight feedback loop: observe prices, evaluate opportunity, act, and track results.
        Every component has a single responsibility.
      </p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="arch-box">
        <h4>Architecture Overview</h4>
<pre style="font-family:'JetBrains Mono',monospace;font-size:13px;line-height:2;color:#A1A1AA;">
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                     NFT Sniping Agent                           â”‚
  â”‚                                                                 â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ Price Oracle  â”‚â”€â”€â”€â–¶â”‚  AI Agent    â”‚â”€â”€â”€â–¶â”‚  Wallet API      â”‚  â”‚
  â”‚  â”‚              â”‚    â”‚  (Evaluator) â”‚    â”‚  (Purple Flea)   â”‚  â”‚
  â”‚  â”‚ â€¢ Blur API   â”‚    â”‚              â”‚    â”‚                  â”‚  â”‚
  â”‚  â”‚ â€¢ OpenSea    â”‚    â”‚ â€¢ Floor diff â”‚    â”‚ â€¢ Sign tx        â”‚  â”‚
  â”‚  â”‚ â€¢ Magic Eden â”‚    â”‚ â€¢ Trait EV   â”‚    â”‚ â€¢ Broadcast      â”‚  â”‚
  â”‚  â”‚ â€¢ WebSockets â”‚    â”‚ â€¢ Risk check â”‚    â”‚ â€¢ Gas estimate   â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚                             â”‚                     â”‚            â”‚
  â”‚                             â–¼                     â–¼            â”‚
  â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚                       â”‚  Decision    â”‚    â”‚  NFT Marketplace â”‚  â”‚
  â”‚                       â”‚  Logger      â”‚    â”‚  (Buy executes)  â”‚  â”‚
  â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
      </div>
    </div>

    <div class="reveal reveal-delay-2">
      <div class="grid-3" style="margin-top:40px;">
        <div class="card">
          <div class="card-icon purple">&#9670;</div>
          <h3>Price Oracle</h3>
          <p>Polls Blur, OpenSea, and Magic Eden APIs (plus WebSocket streams where available) to maintain
             a real-time order book for each monitored collection.</p>
        </div>
        <div class="card">
          <div class="card-icon blue">&#128065;</div>
          <h3>AI Evaluator</h3>
          <p>Computes the discount relative to floor, adjusts for trait rarity, checks against daily spend
             limits, and returns a buy/skip decision with confidence score.</p>
        </div>
        <div class="card">
          <div class="card-icon green">&#128184;</div>
          <h3>Wallet API</h3>
          <p>The Purple Flea Wallet API holds ETH/SOL, estimates gas, signs transactions, and broadcasts
             to the network â€” all via a single REST call with no local keystore required.</p>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- PREREQUISITES -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Prerequisites</div>
      <h2 class="section-title">What you need<br>before starting</h2>
    </div>

    <div class="reveal reveal-delay-1">
      <ul class="rule-list">
        <li>
          <div class="rule-num">1</div>
          <div class="rule-text">
            <strong>Purple Flea wallet with funded ETH or SOL.</strong>
            Create one at <code>wallet.purpleflea.com</code>. Fund it with enough ETH to cover
            purchases plus gas. A reasonable starting float is 0.5 ETH for Ethereum collections
            or 20 SOL for Solana collections. The wallet API exposes balance, send, and swap
            endpoints â€” no browser extension needed.
          </div>
        </li>
        <li>
          <div class="rule-num">2</div>
          <div class="rule-text">
            <strong>ETH for gas (Ethereum sniping).</strong>
            Each failed transaction still costs gas. Budget for failed bids: high-competition
            collections see 5-10 competing agents on every underpriced listing. Keep 0.05â€“0.1 ETH
            reserved purely for gas so purchase budget is never drained by failed transactions.
          </div>
        </li>
        <li>
          <div class="rule-num">3</div>
          <div class="rule-text">
            <strong>Target collection list with floor price baselines.</strong>
            Start with 3â€“5 collections you understand. For each, record: current floor price,
            30-day floor price average, volume traded daily, and typical listing depth within 5% of floor.
            Thin markets (under 1 ETH daily volume) give fewer opportunities but less competition.
          </div>
        </li>
        <li>
          <div class="rule-num">4</div>
          <div class="rule-text">
            <strong>Marketplace API credentials.</strong>
            Blur and OpenSea both require API keys for high-frequency polling. Magic Eden has a
            free tier. Sign up for each. WebSocket access (Blur in particular) is the fastest
            signal for new listings â€” reduce your polling to a fallback only.
          </div>
        </li>
        <li>
          <div class="rule-num">5</div>
          <div class="rule-text">
            <strong>Python 3.11+ with <code>aiohttp</code>, <code>web3.py</code>, and <code>requests</code>.</strong>
            The agent runs asynchronously â€” synchronous HTTP will miss opportunities during I/O waits.
            Use <code>asyncio</code> event loops and <code>aiohttp</code> sessions for all marketplace
            API calls.
          </div>
        </li>
      </ul>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- CODE WALKTHROUGH -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Code Walkthrough</div>
      <h2 class="section-title">Building the agent<br>step by step</h2>
      <p class="section-desc">
        Every function below is production-realistic. Mock responses are labelled clearly.
        The wallet integration uses real Purple Flea API endpoints.
      </p>
    </div>

    <!-- STEP 1: WALLET SETUP -->
    <div class="reveal reveal-delay-1" style="margin-bottom:40px;">
      <h3 style="font-size:1.3rem;font-weight:700;margin-bottom:20px;color:var(--text);">Step 1 &mdash; Create and fund the agent wallet</h3>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">wallet_setup.py</span>
        </div>
<span class="kw">import</span> requests

PURPLEFLEA_API_KEY = <span class="st">"pf_sk_..."</span>
BASE_URL = <span class="st">"https://wallet.purpleflea.com/v1"</span>

HEADERS = {
    <span class="st">"Authorization"</span>: <span class="fn">f</span><span class="st">"Bearer {PURPLEFLEA_API_KEY}"</span>,
    <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>,
}

<span class="kw">def</span> <span class="fn">create_agent_wallet</span>(label: <span class="cls">str</span> = <span class="st">"nft-sniper-agent"</span>) -> <span class="cls">dict</span>:
    <span class="st">"""
    Create a custodial ETH wallet for the agent.
    Returns wallet address, wallet_id, and API credentials.
    No local private key management required.
    """</span>
    resp = requests.<span class="fn">post</span>(
        <span class="fn">f</span><span class="st">"{BASE_URL}/wallet/create"</span>,
        headers=HEADERS,
        json={<span class="st">"chain"</span>: <span class="st">"ethereum"</span>, <span class="st">"label"</span>: label},
    )
    resp.<span class="fn">raise_for_status</span>()
    wallet = resp.<span class="fn">json</span>()
    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Agent wallet created: {wallet['address']}"</span>)
    <span class="kw">return</span> wallet  <span class="cm"># { "wallet_id": "...", "address": "0x...", "chain": "ethereum" }</span>


<span class="kw">def</span> <span class="fn">get_wallet_balance</span>(wallet_id: <span class="cls">str</span>) -> <span class="cls">dict</span>:
    <span class="st">"""Returns ETH balance plus any ERC-20 tokens held."""</span>
    resp = requests.<span class="fn">get</span>(
        <span class="fn">f</span><span class="st">"{BASE_URL}/wallet/{wallet_id}/balance"</span>,
        headers=HEADERS,
    )
    resp.<span class="fn">raise_for_status</span>()
    <span class="kw">return</span> resp.<span class="fn">json</span>()  <span class="cm"># { "eth": "0.482", "usd_value": "1204.50", ... }</span>


<span class="kw">def</span> <span class="fn">reserve_gas_budget</span>(total_eth: <span class="cls">float</span>, gas_reserve_pct: <span class="cls">float</span> = <span class="num">0.15</span>) -> <span class="cls">tuple</span>:
    <span class="st">"""
    Split wallet balance into purchase budget and gas reserve.
    Never spend the gas reserve on NFT purchases.
    """</span>
    gas_reserve = total_eth * gas_reserve_pct
    purchase_budget = total_eth - gas_reserve
    <span class="kw">return</span> purchase_budget, gas_reserve
      </div>
    </div>

    <!-- STEP 2: FLOOR PRICE MONITORING -->
    <div class="reveal reveal-delay-2" style="margin-bottom:40px;">
      <h3 style="font-size:1.3rem;font-weight:700;margin-bottom:20px;color:var(--text);">Step 2 &mdash; Monitor floor prices across marketplaces</h3>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">price_oracle.py</span>
        </div>
<span class="kw">import</span> asyncio
<span class="kw">import</span> aiohttp
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List, Optional
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">Listing</span>:
    token_id: <span class="cls">str</span>
    price_eth: <span class="cls">float</span>
    marketplace: <span class="cls">str</span>
    seller: <span class="cls">str</span>
    traits: <span class="cls">dict</span>
    listing_url: <span class="cls">str</span>

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">CollectionStats</span>:
    slug: <span class="cls">str</span>
    floor_price_eth: <span class="cls">float</span>
    floor_7d_avg: <span class="cls">float</span>
    volume_24h_eth: <span class="cls">float</span>
    listings_below_floor: <span class="cls">int</span>

<span class="kw">async def</span> <span class="fn">fetch_blur_floor</span>(session: <span class="cls">aiohttp.ClientSession</span>, collection: <span class="cls">str</span>) -> <span class="cls">float</span>:
    <span class="st">"""Fetch current floor price from Blur API."""</span>
    url = <span class="fn">f</span><span class="st">"https://api.blur.io/v1/collections/{collection}/floor"</span>
    <span class="kw">async with</span> session.<span class="fn">get</span>(url) <span class="kw">as</span> resp:
        data = <span class="kw">await</span> resp.<span class="fn">json</span>()
        <span class="kw">return</span> <span class="cls">float</span>(data[<span class="st">"floorPrice"</span>][<span class="st">"amount"</span>])  <span class="cm"># mock response shape</span>

<span class="kw">async def</span> <span class="fn">fetch_opensea_listings</span>(
    session: <span class="cls">aiohttp.ClientSession</span>,
    collection_slug: <span class="cls">str</span>,
    max_price_eth: <span class="cls">float</span>,
    limit: <span class="cls">int</span> = <span class="num">20</span>
) -> <span class="cls">List</span>[<span class="cls">Listing</span>]:
    <span class="st">"""Fetch active listings below max_price_eth from OpenSea v2 API."""</span>
    url = <span class="fn">f</span><span class="st">"https://api.opensea.io/v2/listings/collection/{collection_slug}/all"</span>
    params = {<span class="st">"limit"</span>: limit, <span class="st">"order_by"</span>: <span class="st">"eth_price"</span>}
    headers = {<span class="st">"X-API-KEY"</span>: <span class="st">"YOUR_OPENSEA_KEY"</span>}
    <span class="kw">async with</span> session.<span class="fn">get</span>(url, params=params, headers=headers) <span class="kw">as</span> resp:
        data = <span class="kw">await</span> resp.<span class="fn">json</span>()
        listings = []
        <span class="kw">for</span> item <span class="kw">in</span> data.<span class="fn">get</span>(<span class="st">"listings"</span>, []):
            price = <span class="cls">float</span>(item[<span class="st">"price"</span>][<span class="st">"current"</span>][<span class="st">"value"</span>]) / <span class="num">1e18</span>  <span class="cm"># wei to ETH</span>
            <span class="kw">if</span> price <= max_price_eth:
                listings.<span class="fn">append</span>(<span class="cls">Listing</span>(
                    token_id=item[<span class="st">"protocol_data"</span>][<span class="st">"parameters"</span>][<span class="st">"offer"</span>][<span class="num">0</span>][<span class="st">"identifierOrCriteria"</span>],
                    price_eth=price,
                    marketplace=<span class="st">"opensea"</span>,
                    seller=item[<span class="st">"protocol_data"</span>][<span class="st">"parameters"</span>][<span class="st">"offerer"</span>],
                    traits={},  <span class="cm"># fetch separately via /nft endpoint</span>
                    listing_url=<span class="fn">f</span><span class="st">"https://opensea.io/assets/ethereum/{collection_slug}/{item['..']}"</span>,
                ))
        <span class="kw">return</span> listings

<span class="kw">async def</span> <span class="fn">get_consensus_floor</span>(session: <span class="cls">aiohttp.ClientSession</span>, collection: <span class="cls">str</span>) -> <span class="cls">float</span>:
    <span class="st">"""
    Fetch floor from multiple sources and return the median.
    A single API can lag or be manipulated â€” use 3 sources.
    """</span>
    prices = <span class="kw">await</span> asyncio.<span class="fn">gather</span>(
        <span class="fn">fetch_blur_floor</span>(session, collection),
        <span class="cm"># fetch_magic_eden_floor(session, collection),  # for Solana</span>
        <span class="cm"># fetch_opensea_floor(session, collection),</span>
        return_exceptions=<span class="cls">True</span>,
    )
    valid = [p <span class="kw">for</span> p <span class="kw">in</span> prices <span class="kw">if isinstance</span>(p, <span class="cls">float</span>)]
    <span class="kw">return</span> <span class="fn">sorted</span>(valid)[<span class="fn">len</span>(valid) // <span class="num">2</span>]  <span class="cm"># median</span>
      </div>
    </div>

    <!-- STEP 3: EV CALCULATION -->
    <div class="reveal reveal-delay-3" style="margin-bottom:40px;">
      <h3 style="font-size:1.3rem;font-weight:700;margin-bottom:20px;color:var(--text);">Step 3 &mdash; Calculate expected value vs floor</h3>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">evaluator.py</span>
        </div>
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">BuyDecision</span>:
    should_buy: <span class="cls">bool</span>
    listing: <span class="cls">object</span>
    floor_price: <span class="cls">float</span>
    discount_pct: <span class="cls">float</span>
    expected_profit_eth: <span class="cls">float</span>
    confidence: <span class="cls">str</span>  <span class="cm"># "high" | "medium" | "skip"</span>

<span class="kw">def</span> <span class="fn">estimate_trait_premium</span>(traits: <span class="cls">dict</span>, collection_slug: <span class="cls">str</span>) -> <span class="cls">float</span>:
    <span class="st">"""
    Returns an ETH premium above floor justified by rare traits.
    In production: query trait rarity APIs (rarity.tools, etc.)
    Here we return a conservative flat estimate.
    """</span>
    rare_traits = [t <span class="kw">for</span> t <span class="kw">in</span> traits.<span class="fn">values</span>() <span class="kw">if</span> t.<span class="fn">get</span>(<span class="st">"rarity_pct"</span>, <span class="num">100</span>) < <span class="num">5</span>]
    <span class="kw">return</span> <span class="fn">len</span>(rare_traits) * <span class="num">0.005</span>  <span class="cm"># 0.005 ETH per rare trait â€” tune per collection</span>

<span class="kw">def</span> <span class="fn">evaluate_listing</span>(
    listing,
    floor_price: <span class="cls">float</span>,
    min_discount_pct: <span class="cls">float</span> = <span class="num">8.0</span>,
    marketplace_fee_pct: <span class="cls">float</span> = <span class="num">2.5</span>,
    royalty_pct: <span class="cls">float</span> = <span class="num">5.0</span>,
) -> <span class="cls">BuyDecision</span>:
    <span class="st">"""
    Decide whether to buy a listing.

    min_discount_pct: minimum % below floor to trigger a buy.
    Set higher (10-15%) for thin markets with higher risk.
    marketplace_fee_pct + royalty_pct are costs on the SELL side.
    """</span>
    trait_premium = <span class="fn">estimate_trait_premium</span>(listing.traits, <span class="st">"collection"</span>)
    effective_floor = floor_price + trait_premium

    discount = (effective_floor - listing.price_eth) / effective_floor * <span class="num">100</span>

    <span class="cm"># Net sell price after fees (assuming we list at 99% of floor)</span>
    sell_price = floor_price * <span class="num">0.99</span>
    sell_proceeds = sell_price * (<span class="num">1</span> - (marketplace_fee_pct + royalty_pct) / <span class="num">100</span>)
    expected_profit = sell_proceeds - listing.price_eth

    should_buy = discount >= min_discount_pct <span class="kw">and</span> expected_profit > <span class="num">0</span>
    confidence = <span class="st">"high"</span> <span class="kw">if</span> discount >= <span class="num">15</span> <span class="kw">else</span> (<span class="st">"medium"</span> <span class="kw">if</span> discount >= min_discount_pct <span class="kw">else</span> <span class="st">"skip"</span>)

    <span class="kw">return</span> <span class="cls">BuyDecision</span>(
        should_buy=should_buy,
        listing=listing,
        floor_price=floor_price,
        discount_pct=discount,
        expected_profit_eth=expected_profit,
        confidence=confidence,
    )
      </div>
    </div>

    <!-- STEP 4: EXECUTE BUY -->
    <div class="reveal" style="margin-bottom:40px;">
      <h3 style="font-size:1.3rem;font-weight:700;margin-bottom:20px;color:var(--text);">Step 4 &mdash; Execute the buy via Purple Flea Wallet API</h3>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">executor.py</span>
        </div>
<span class="kw">import</span> requests
<span class="kw">from</span> web3 <span class="kw">import</span> Web3

BASE_URL = <span class="st">"https://wallet.purpleflea.com/v1"</span>
HEADERS = {<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>, <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>}

<span class="kw">def</span> <span class="fn">build_opensea_buy_calldata</span>(listing) -> <span class="cls">str</span>:
    <span class="st">"""
    Build the calldata to fulfill an OpenSea Seaport order.
    In production, use the OpenSea SDK or encode via web3.py ABI.
    Returns hex-encoded calldata string.
    """</span>
    <span class="cm"># Placeholder â€” in production, encode fulfillBasicOrder() or fulfillOrder()</span>
    <span class="kw">return</span> <span class="st">"0x..."</span>

<span class="kw">def</span> <span class="fn">execute_nft_buy</span>(
    wallet_id: <span class="cls">str</span>,
    listing,
    decision,
    nft_contract: <span class="cls">str</span>,
) -> <span class="cls">dict</span>:
    <span class="st">"""
    Send a transaction via Purple Flea Wallet API to purchase the NFT.
    The wallet holds ETH and signs the transaction server-side â€” no
    local key management, no MetaMask, no browser extension.
    """</span>
    calldata = <span class="fn">build_opensea_buy_calldata</span>(listing)

    payload = {
        <span class="st">"wallet_id"</span>: wallet_id,
        <span class="st">"to"</span>: <span class="st">"0x00000000000000ADc04C56Bf30aC9d3c0aAF14dC"</span>,  <span class="cm"># Seaport 1.5</span>
        <span class="st">"value_eth"</span>: <span class="cls">str</span>(listing.price_eth),
        <span class="st">"data"</span>: calldata,
        <span class="st">"gas_strategy"</span>: <span class="st">"fast"</span>,        <span class="cm"># "slow" | "standard" | "fast" | "instant"</span>
        <span class="st">"max_priority_fee_gwei"</span>: <span class="num">3</span>,     <span class="cm"># tune for snipe speed vs cost</span>
        <span class="st">"idempotency_key"</span>: <span class="fn">f</span><span class="st">"snipe-{listing.token_id}-{int(time.time())}"</span>,
    }

    resp = requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{BASE_URL}/wallet/send"</span>, headers=HEADERS, json=payload)
    result = resp.<span class="fn">json</span>()

    <span class="kw">if</span> result.<span class="fn">get</span>(<span class="st">"status"</span>) == <span class="st">"submitted"</span>:
        <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Snipe submitted: tx={result['tx_hash']} token={listing.token_id} price={listing.price_eth} ETH"</span>)
        <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Expected profit: {decision.expected_profit_eth:.4f} ETH"</span>)
    <span class="kw">return</span> result
      </div>
    </div>

    <!-- STEP 5: SELL STRATEGY -->
    <div class="reveal" style="margin-bottom:40px;">
      <h3 style="font-size:1.3rem;font-weight:700;margin-bottom:20px;color:var(--text);">Step 5 &mdash; List for sale after purchase</h3>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">sell_strategy.py</span>
        </div>
<span class="kw">import</span> time

<span class="kw">def</span> <span class="fn">calculate_list_price</span>(
    purchase_price_eth: <span class="cls">float</span>,
    current_floor_eth: <span class="cls">float</span>,
    strategy: <span class="cls">str</span> = <span class="st">"undercut"</span>,
) -> <span class="cls">float</span>:
    <span class="st">"""
    Determine the listing price after a successful snipe.

    Strategies:
    - "undercut": list 1-2% below current floor for fast exit
    - "hold":     list at floor, wait for market to come to you
    - "premium":  list above floor if rare traits justify it
    """</span>
    <span class="kw">if</span> strategy == <span class="st">"undercut"</span>:
        <span class="kw">return</span> <span class="fn">round</span>(current_floor_eth * <span class="num">0.985</span>, <span class="num">4</span>)
    <span class="kw">elif</span> strategy == <span class="st">"hold"</span>:
        <span class="kw">return</span> <span class="fn">round</span>(current_floor_eth, <span class="num">4</span>)
    <span class="kw">else</span>:
        <span class="kw">return</span> <span class="fn">round</span>(current_floor_eth * <span class="num">1.05</span>, <span class="num">4</span>)

<span class="kw">def</span> <span class="fn">list_nft_on_blur</span>(
    wallet_id: <span class="cls">str</span>,
    token_id: <span class="cls">str</span>,
    contract_address: <span class="cls">str</span>,
    list_price_eth: <span class="cls">float</span>,
    expiry_hours: <span class="cls">int</span> = <span class="num">24</span>,
) -> <span class="cls">dict</span>:
    <span class="st">"""
    List the purchased NFT on Blur via Purple Flea Wallet API
    (wallet signs the Seaport listing order off-chain, then submits).
    Blur typically charges 0.5% marketplace fee.
    """</span>
    payload = {
        <span class="st">"wallet_id"</span>: wallet_id,
        <span class="st">"action"</span>: <span class="st">"sign_listing"</span>,
        <span class="st">"marketplace"</span>: <span class="st">"blur"</span>,
        <span class="st">"contract"</span>: contract_address,
        <span class="st">"token_id"</span>: token_id,
        <span class="st">"price_eth"</span>: list_price_eth,
        <span class="st">"expiry_unix"</span>: <span class="cls">int</span>(time.<span class="fn">time</span>()) + expiry_hours * <span class="num">3600</span>,
    }
    <span class="cm"># POST to Purple Flea wallet API â€” returns signed order for submission</span>
    <span class="cm"># The wallet API handles EIP-712 signing without exposing the private key</span>
    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Listing token {token_id} at {list_price_eth} ETH on Blur"</span>)
    <span class="kw">return</span> {<span class="st">"status"</span>: <span class="st">"listed"</span>, <span class="st">"list_price"</span>: list_price_eth}
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- FULL WORKING EXAMPLE -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Full Example</div>
      <h2 class="section-title">Complete agent<br>main loop</h2>
      <p class="section-desc">
        The main loop ties every component together: poll prices, evaluate, buy, list. Runs continuously
        until the daily spend limit is hit or the stop-loss triggers.
      </p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">nft_sniper_agent.py</span>
        </div>
<span class="kw">import</span> asyncio
<span class="kw">import</span> logging
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, date

<span class="kw">from</span> wallet_setup <span class="kw">import</span> get_wallet_balance
<span class="kw">from</span> price_oracle <span class="kw">import</span> fetch_opensea_listings, get_consensus_floor
<span class="kw">from</span> evaluator <span class="kw">import</span> evaluate_listing
<span class="kw">from</span> executor <span class="kw">import</span> execute_nft_buy
<span class="kw">from</span> sell_strategy <span class="kw">import</span> calculate_list_price, list_nft_on_blur

logging.<span class="fn">basicConfig</span>(level=logging.INFO, format=<span class="st">"%(asctime)s %(levelname)s %(message)s"</span>)

<span class="cm"># â”€â”€ Agent configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
WALLET_ID = <span class="st">"wlt_..."</span>
TARGET_COLLECTIONS = [
    {<span class="st">"slug"</span>: <span class="st">"azuki"</span>,     <span class="st">"contract"</span>: <span class="st">"0xED5AF..."</span>, <span class="st">"chain"</span>: <span class="st">"ethereum"</span>},
    {<span class="st">"slug"</span>: <span class="st">"milady"</span>,    <span class="st">"contract"</span>: <span class="st">"0x5AF0D..."</span>, <span class="st">"chain"</span>: <span class="st">"ethereum"</span>},
    {<span class="st">"slug"</span>: <span class="st">"pudgy-penguins"</span>, <span class="st">"contract"</span>: <span class="st">"0xBd3531..."</span>, <span class="st">"chain"</span>: <span class="st">"ethereum"</span>},
]
MAX_SPEND_PER_DAY_ETH = <span class="num">0.3</span>
POLL_INTERVAL_SECONDS = <span class="num">8</span>
MIN_DISCOUNT_PCT = <span class="num">8.0</span>

<span class="cm"># â”€â”€ Risk tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
daily_spent_eth = <span class="num">0.0</span>
daily_reset_date = date.<span class="fn">today</span>()
portfolio = []  <span class="cm"># NFTs currently held</span>

<span class="kw">def</span> <span class="fn">check_daily_limit</span>(cost: <span class="cls">float</span>) -> <span class="cls">bool</span>:
    <span class="kw">global</span> daily_spent_eth, daily_reset_date
    <span class="kw">if</span> date.<span class="fn">today</span>() != daily_reset_date:
        daily_spent_eth = <span class="num">0.0</span>
        daily_reset_date = date.<span class="fn">today</span>()
    <span class="kw">return</span> daily_spent_eth + cost <= MAX_SPEND_PER_DAY_ETH

<span class="kw">async def</span> <span class="fn">snipe_collection</span>(session, collection: <span class="cls">dict</span>):
    <span class="kw">global</span> daily_spent_eth, portfolio
    slug = collection[<span class="st">"slug"</span>]

    floor = <span class="kw">await</span> <span class="fn">get_consensus_floor</span>(session, slug)
    <span class="cm"># Look for listings at least (min_discount - 1)% below floor</span>
    max_price = floor * (<span class="num">1</span> - (MIN_DISCOUNT_PCT - <span class="num">1</span>) / <span class="num">100</span>)
    listings = <span class="kw">await</span> <span class="fn">fetch_opensea_listings</span>(session, slug, max_price, limit=<span class="num">5</span>)

    <span class="kw">for</span> listing <span class="kw">in</span> listings:
        decision = <span class="fn">evaluate_listing</span>(listing, floor, MIN_DISCOUNT_PCT)

        <span class="kw">if not</span> decision.should_buy:
            <span class="kw">continue</span>

        <span class="kw">if not</span> <span class="fn">check_daily_limit</span>(listing.price_eth):
            logging.<span class="fn">warning</span>(<span class="st">"Daily spend limit reached. Pausing until midnight."</span>)
            <span class="kw">return</span>

        logging.<span class="fn">info</span>(
            <span class="fn">f</span><span class="st">"SNIPE {slug} #{listing.token_id} @ {listing.price_eth:.4f} ETH "
            f"(floor={floor:.4f}, discount={decision.discount_pct:.1f}%, "
            f"expected_profit={decision.expected_profit_eth:.4f} ETH)"</span>
        )

        result = <span class="fn">execute_nft_buy</span>(WALLET_ID, listing, decision, collection[<span class="st">"contract"</span>])

        <span class="kw">if</span> result.<span class="fn">get</span>(<span class="st">"status"</span>) == <span class="st">"submitted"</span>:
            daily_spent_eth += listing.price_eth
            list_price = <span class="fn">calculate_list_price</span>(listing.price_eth, floor, <span class="st">"undercut"</span>)
            <span class="fn">list_nft_on_blur</span>(WALLET_ID, listing.token_id, collection[<span class="st">"contract"</span>], list_price)
            portfolio.<span class="fn">append</span>({<span class="st">"token_id"</span>: listing.token_id, <span class="st">"cost"</span>: listing.price_eth, <span class="st">"list_price"</span>: list_price})
            <span class="kw">break</span>  <span class="cm"># one buy per collection per cycle to avoid over-concentration</span>

<span class="kw">async def</span> <span class="fn">main</span>():
    <span class="kw">import</span> aiohttp
    logging.<span class="fn">info</span>(<span class="st">"NFT Sniper Agent starting..."</span>)
    bal = <span class="fn">get_wallet_balance</span>(WALLET_ID)
    logging.<span class="fn">info</span>(<span class="fn">f</span><span class="st">"Wallet balance: {bal['eth']} ETH (${bal['usd_value']})"</span>)

    <span class="kw">async with</span> aiohttp.<span class="cls">ClientSession</span>() <span class="kw">as</span> session:
        <span class="kw">while</span> <span class="cls">True</span>:
            tasks = [<span class="fn">snipe_collection</span>(session, c) <span class="kw">for</span> c <span class="kw">in</span> TARGET_COLLECTIONS]
            <span class="kw">await</span> asyncio.<span class="fn">gather</span>(*tasks, return_exceptions=<span class="cls">True</span>)
            <span class="kw">await</span> asyncio.<span class="fn">sleep</span>(POLL_INTERVAL_SECONDS)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    asyncio.<span class="fn">run</span>(<span class="fn">main</span>())
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RISK MANAGEMENT -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Risk Management</div>
      <h2 class="section-title">Protecting the<br>agent portfolio</h2>
      <p class="section-desc">
        NFT sniping carries real financial risk. Floor prices can crater overnight. A single bad collection
        can wipe out weeks of snipe profits. These rules are non-negotiable.
      </p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="grid-2" style="margin-bottom:40px;">
        <div class="card">
          <div class="card-icon purple">&#128275;</div>
          <h3>Max Spend Per Day</h3>
          <p>Hard-code a daily ETH cap in the agent. Once reached, the agent stops buying until the next
             calendar day. Start at 0.1-0.3 ETH while calibrating. The cap prevents a bug or bad market
             from draining the wallet in a single session.</p>
        </div>
        <div class="card">
          <div class="card-icon red">&#128683;</div>
          <h3>Portfolio Stop-Loss</h3>
          <p>Track the total ETH value of held NFTs (mark-to-market at current floor). If portfolio value
             drops more than 25% from its peak, halt all new purchases. Floor crashes propagate across
             collections â€” stop early.</p>
        </div>
        <div class="card">
          <div class="card-icon orange">&#9884;</div>
          <h3>Max Hold Period</h3>
          <p>Set a maximum hold time (e.g., 72 hours). If an NFT has not sold within the window, lower
             the listing price by 2% every 12 hours until it clears. Illiquidity is the second biggest
             risk after floor crashes.</p>
        </div>
        <div class="card">
          <div class="card-icon blue">&#128200;</div>
          <h3>Concentration Limit</h3>
          <p>No single collection should represent more than 30% of total NFT portfolio value.
             Correlation within a single collection is 1.0 â€” if it crashes, everything in it crashes
             together. Diversify across collections and chains.</p>
        </div>
        <div class="card">
          <div class="card-icon green">&#9881;</div>
          <h3>Gas Budget Reserve</h3>
          <p>Keep 15% of wallet ETH reserved exclusively for gas. Failed transactions on Ethereum still
             consume gas. High competition on popular collections means a 40-60% failure rate on snipe
             attempts. Budget for it.</p>
        </div>
        <div class="card">
          <div class="card-icon yellow">&#128196;</div>
          <h3>Full Audit Log</h3>
          <p>Every snipe attempt, successful purchase, and sale must be logged with timestamp, token ID,
             prices, floor at time of purchase, tx hash, and P&amp;L. Essential for tuning the minimum
             discount threshold and for debugging bad decisions.</p>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- WHY PURPLE FLEA -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Why Purple Flea</div>
      <h2 class="section-title">The Wallet API built<br>for autonomous agents</h2>
      <p class="section-desc">
        Most crypto wallets are designed for humans with browsers. Purple Flea is built for agents
        that need to transact programmatically, reliably, and fast.
      </p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="grid-3">
        <div class="card">
          <div class="card-icon purple">&#128274;</div>
          <h3>No Local Key Storage</h3>
          <p>The private key never leaves Purple Flea's HSM. Your agent authenticates with an API key
             and the wallet signs on the server. No risk of key theft from agent memory or logs.</p>
        </div>
        <div class="card">
          <div class="card-icon blue">&#9889;</div>
          <h3>Multi-Chain, One API</h3>
          <p>ETH for OpenSea and Blur sniping. SOL for Magic Eden sniping on Solana. Both chains
             through the same REST API. No chain-switching logic, no separate keystores.</p>
        </div>
        <div class="card">
          <div class="card-icon green">&#9881;</div>
          <h3>Gas Strategy Control</h3>
          <p>Select <code>slow</code>, <code>standard</code>, <code>fast</code>, or <code>instant</code>
             gas strategy per transaction. For sniping, use <code>fast</code> or <code>instant</code>
             to outrun competing agents.</p>
        </div>
        <div class="card">
          <div class="card-icon orange">&#128200;</div>
          <h3>Portfolio Balance API</h3>
          <p>Query ETH, SOL, and any ERC-20 balance in real time. Know your exact purchasing power
             before evaluating each listing. No stale balance estimates.</p>
        </div>
        <div class="card">
          <div class="card-icon red">&#128260;</div>
          <h3>Idempotent Sends</h3>
          <p>Every send endpoint accepts an <code>idempotency_key</code>. If your agent retries a
             failed request, the transaction is not re-broadcast. No accidental double-purchases
             during network hiccups.</p>
        </div>
        <div class="card">
          <div class="card-icon yellow">&#127760;</div>
          <h3>Referral Revenue</h3>
          <p>Recommend Purple Flea to other NFT agents you collaborate with. Earn 10-20% of their
             transaction fees in perpetuity. An agent that onboards five other sniping agents earns
             passive income on every snipe they execute.</p>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- FAQ -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">FAQ</div>
      <h2 class="section-title">Common questions<br>from builders</h2>
    </div>

    <div class="reveal reveal-delay-1" style="max-width:860px;">
      <div class="faq-item">
        <div class="faq-q" onclick="toggleFaq(this)">
          How do I minimise failed transactions and wasted gas?
          <span class="faq-arrow">+</span>
        </div>
        <div class="faq-a">
          Use WebSocket streams from Blur instead of polling â€” you see new listings the moment they are
          indexed, giving you 2-4 seconds of lead time over polling competitors.
          Set <code>gas_strategy: "fast"</code> on buys, not <code>"instant"</code>, unless the collection is
          extremely competitive (e.g., top-10 blue chips). The difference in cost between fast and instant
          adds up significantly across hundreds of failed attempts.
          Also use idempotency keys: if a submit times out, retry without fear of double-spending.
          Finally, maintain a local cache of recently seen listing IDs â€” do not attempt to buy the same
          listing twice if a previous attempt is still pending.
        </div>
      </div>
      <div class="faq-item">
        <div class="faq-q" onclick="toggleFaq(this)">
          How do I handle collections with high royalties?
          <span class="faq-arrow">+</span>
        </div>
        <div class="faq-a">
          Factor royalties into the <code>evaluate_listing</code> function as a cost on the sell side.
          A collection with 10% royalties requires a significantly larger discount to remain profitable
          than one with 2.5%. As a rule of thumb: minimum discount threshold = (marketplace fee + royalty
          + desired profit margin + expected failed-gas cost per successful buy). For a 10% royalty
          collection, your minimum discount is rarely below 15-18%.
          Some marketplaces (notably Blur) allow optional royalty payments â€” but skipping royalties
          can limit where your listing appears. Model this explicitly per marketplace.
        </div>
      </div>
      <div class="faq-item">
        <div class="faq-q" onclick="toggleFaq(this)">
          What is the best polling interval for price feeds?
          <span class="faq-arrow">+</span>
        </div>
        <div class="faq-a">
          For Blur, use WebSockets â€” polling is a fallback. For OpenSea, the v2 API supports polling
          down to around 5-second intervals before rate limiting kicks in. Magic Eden allows 2-second
          polling on free tier. Your consensus floor calculation can run at 30-60 second intervals
          since floor price moves slowly; it is the individual listing feed that needs low latency.
          Separate your two polling loops: fast (5-8s) for new listings, slow (30s) for floor updates.
        </div>
      </div>
      <div class="faq-item">
        <div class="faq-q" onclick="toggleFaq(this)">
          Can I run the agent on multiple collections simultaneously?
          <span class="faq-arrow">+</span>
        </div>
        <div class="faq-a">
          Yes â€” the <code>asyncio.gather()</code> pattern in the main loop handles this natively.
          Practical limits: Purple Flea Wallet API rate limits allow hundreds of transactions per minute,
          so the wallet is not the bottleneck. Marketplace API rate limits are the binding constraint.
          With standard API keys you can comfortably monitor 10-20 collections concurrently.
          Start with 3-5 collections you know well before scaling, so you can validate the minimum
          discount thresholds are correctly calibrated per collection.
        </div>
      </div>
      <div class="faq-item">
        <div class="faq-q" onclick="toggleFaq(this)">
          How do I handle a floor crash after buying?
          <span class="faq-arrow">+</span>
        </div>
        <div class="faq-a">
          The max hold period and portfolio stop-loss are your primary defences. If you bought at
          8% below floor and the floor drops 20%, you have a -12% position. The agent should detect
          the floor drop via its oracle loop, lower the listing price to 1-2% below the new floor,
          and take the loss quickly. Holding through a crash hoping for recovery is a human bias.
          The agent should clear positions below its cost basis after a configurable threshold
          (e.g., floor drops more than 20% from purchase-time floor). Capital recovery and
          redeployment beats waiting.
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RELATED -->
<section style="padding:60px 0;">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Related Guides</div>
      <h2 class="section-title" style="margin-bottom:32px;">Keep reading</h2>
      <div class="related-grid">
        <a href="/crypto-wallet-api/" class="related-card">
          <div class="label">API Docs</div>
          <div class="title">Wallet API Reference</div>
          <div class="desc">Full endpoint documentation for multi-chain wallet operations</div>
        </a>
        <a href="/ai-agent-defi/" class="related-card">
          <div class="label">Strategy</div>
          <div class="title">DeFi AI Agent Strategies</div>
          <div class="desc">Yield farming, liquidity provision, and arbitrage for autonomous agents</div>
        </a>
        <a href="/ai-agent-casino-strategy/" class="related-card">
          <div class="label">Strategy</div>
          <div class="title">AI Agent Casino Strategy</div>
          <div class="desc">Kelly Criterion, crash strategy, and bankroll management for agents</div>
        </a>
      </div>
    </div>
  </div>
</section>

<!-- CTA -->
<section class="cta-section">
  <div class="container">
    <div class="cta-box reveal">
      <h2>Ready to deploy your<br><span style="color:var(--purple)">NFT sniping agent?</span></h2>
      <p>Create a Purple Flea wallet, fund it with ETH or SOL, and start executing on-chain purchases
         programmatically â€” no browser, no MetaMask, no manual signing.</p>
      <div class="hero-actions">
        <a href="https://wallet.purpleflea.com" class="btn-primary" target="_blank">Create agent wallet &#8594;</a>
        <a href="/crypto-wallet-api/" class="btn-secondary">Wallet API Docs</a>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<footer>
  <div class="container">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo">
          <div class="nav-logo-icon">&#9830;</div>
          Purple Flea
        </a>
        <p>AI-first infrastructure for autonomous agents. Built for machines, verified by math.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Products</h4>
          <ul>
            <li><a href="https://casino.purpleflea.com" target="_blank">Casino</a></li>
            <li><a href="https://trading.purpleflea.com" target="_blank">Trading</a></li>
            <li><a href="https://wallet.purpleflea.com" target="_blank">Wallet</a></li>
            <li><a href="https://domains.purpleflea.com" target="_blank">Domains</a></li>
            <li><a href="/crypto-wallet-api/">Wallet API Docs</a></li>
            <li><a href="/trading-api/">Trading API Docs</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/for-langchain/">LangChain</a></li>
            <li><a href="/for-crewai/">CrewAI</a></li>
            <li><a href="/for-claude/">Claude / MCP</a></li>
            <li><a href="/quick-start">Quick Start</a></li>
            <li><a href="/openapi">OpenAPI</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/pricing">Pricing</a></li>
            <li><a href="/stats">Stats</a></li>
            <li><a href="/changelog">Changelog</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="mailto:hello@purpleflea.com">Contact</a></li>
            <li><a href="https://github.com/Purple-flea" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://github.com/Purple-flea" target="_blank">GitHub</a>
        <a href="https://x.com/purpleflea" target="_blank">X / Twitter</a>
      </div>
    </div>
  </div>
</footer>

<script>
const navbar = document.getElementById('navbar');
window.addEventListener('scroll', () => { navbar.classList.toggle('scrolled', window.scrollY > 50); });
const revealEls = document.querySelectorAll('.reveal');
const revealObs = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('visible'); revealObs.unobserve(e.target); } });
}, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });
revealEls.forEach(el => revealObs.observe(el));

function toggleFaq(el) {
  const item = el.closest('.faq-item');
  item.classList.toggle('open');
}
</script>
</body>
</html>
