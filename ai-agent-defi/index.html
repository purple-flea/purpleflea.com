<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DeFi AI Agent Strategies â€” Purple Flea</title>
<meta name="description" content="Five DeFi strategies autonomous AI agents excel at: yield farming optimizer, liquidity provision, funding rate harvesting, cross-chain arbitrage, and stablecoin yield maximizer. All using Purple Flea Wallet and Trading APIs.">
<link rel="canonical" href="https://purpleflea.com/ai-agent-defi/">
<meta property="og:title" content="DeFi AI Agent Strategies â€” Purple Flea">
<meta property="og:description" content="Five DeFi strategies autonomous AI agents excel at: yield farming, liquidity provision, funding rate harvesting, cross-chain arbitrage, and stablecoin yield maximization.">
<meta property="og:url" content="https://purpleflea.com/ai-agent-defi/">
<meta property="og:type" content="website">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="DeFi AI Agent Strategies â€” Purple Flea">
<meta name="twitter:description" content="Yield farming, liquidity provision, funding rate harvesting, cross-chain arbitrage, and stablecoin yield maximization for autonomous agents.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "DeFi AI Agent Strategies",
  "url": "https://purpleflea.com/ai-agent-defi/",
  "description": "Five DeFi strategies that autonomous AI agents excel at, with code examples using Purple Flea Wallet and Trading APIs.",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" }
}
</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŸ£</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7;
  --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B;
  --bg-card: rgba(255, 255, 255, 0.03);
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(168, 85, 247, 0.3);
  --text: #FAFAFA;
  --text-secondary: #A1A1AA;
  --text-muted: #71717A;
  --radius: 16px;
  --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168, 85, 247, 0.3); border-radius: 3px; }
::selection { background: rgba(168, 85, 247, 0.4); color: white; }
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.reveal { opacity: 0; transform: translateY(30px); transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), transform 0.8s cubic-bezier(0.16, 1, 0.3, 1); }
.reveal.visible { opacity: 1; transform: translateY(0); }
.reveal-delay-1 { transition-delay: 0.1s; }
.reveal-delay-2 { transition-delay: 0.2s; }
.reveal-delay-3 { transition-delay: 0.3s; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9, 9, 11, 0.8); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* HERO */
.hero { min-height: 80vh; display: flex; align-items: center; justify-content: center; position: relative; padding: 120px 0 80px; overflow: hidden; }
.hero-bg { position: absolute; inset: 0; overflow: hidden; }
.hero-gradient-1 { position: absolute; top: -30%; left: 50%; transform: translateX(-50%); width: 900px; height: 600px; background: radial-gradient(ellipse, rgba(168, 85, 247, 0.15) 0%, transparent 70%); filter: blur(60px); }
.hero-grid { position: absolute; inset: 0; background-image: linear-gradient(rgba(168, 85, 247, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(168, 85, 247, 0.03) 1px, transparent 1px); background-size: 60px 60px; mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); -webkit-mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); }
.hero-content { position: relative; text-align: center; max-width: 860px; margin: 0 auto; padding: 0 24px; }
.hero-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 16px 6px 8px; background: var(--purple-subtle); border: 1px solid rgba(168, 85, 247, 0.15); border-radius: 100px; font-size: 13px; font-weight: 500; color: var(--purple); margin-bottom: 32px; animation: fadeInDown 0.8s ease; }
.hero-badge-dot { width: 8px; height: 8px; background: var(--purple); border-radius: 50%; animation: badge-pulse 2s ease-in-out infinite; }
@keyframes badge-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
@keyframes fadeInDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
@keyframes gradient-shift { 0% { background-position: 0% center; } 50% { background-position: 100% center; } 100% { background-position: 0% center; } }
.hero h1 { font-size: clamp(2.5rem, 6vw, 4.5rem); font-weight: 800; line-height: 1.05; letter-spacing: -0.03em; margin-bottom: 24px; animation: fadeInUp 0.8s ease 0.1s both; }
.hero h1 .gradient { background: linear-gradient(135deg, var(--purple) 0%, #C084FC 50%, var(--purple) 100%); background-size: 200% auto; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: gradient-shift 5s ease infinite; }
.hero-desc { font-size: clamp(1rem, 2vw, 1.2rem); color: var(--text-secondary); margin-bottom: 40px; line-height: 1.7; animation: fadeInUp 0.8s ease 0.2s both; }
.hero-actions { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; animation: fadeInUp 0.8s ease 0.3s both; }
.btn-primary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--purple); color: white; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px; text-decoration: none; transition: all 0.2s; box-shadow: 0 0 30px rgba(168, 85, 247, 0.3); }
.btn-primary:hover { background: var(--purple-dim); transform: translateY(-2px); box-shadow: 0 0 40px rgba(168, 85, 247, 0.5); }
.btn-secondary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--bg-card); color: var(--text); border-radius: var(--radius-sm); font-weight: 500; font-size: 15px; text-decoration: none; border: 1px solid var(--border); transition: all 0.2s; }
.btn-secondary:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }

/* SECTIONS */
section { padding: 100px 0; position: relative; }
.section-label { display: inline-flex; align-items: center; gap: 12px; font-size: 12px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: var(--purple); margin-bottom: 20px; }
.section-label::before { content: ''; width: 24px; height: 1px; background: var(--purple); }
.section-title { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; }
.section-desc { font-size: 1.1rem; color: var(--text-secondary); max-width: 600px; margin-bottom: 60px; line-height: 1.7; }
.section-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 0; }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', monospace; font-size: 13.5px; line-height: 1.7; overflow-x: auto; position: relative; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }

/* GRID */
.grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; }
.grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; }
.grid-5 { display: grid; grid-template-columns: repeat(5, 1fr); gap: 16px; }
@media (max-width: 1024px) { .grid-5 { grid-template-columns: repeat(3, 1fr); } }
@media (max-width: 768px) { .grid-2, .grid-3, .grid-5 { grid-template-columns: 1fr; } }

/* CARDS */
.card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); padding: 32px; transition: all 0.3s ease; }
.card:hover { background: var(--bg-card-hover); border-color: var(--border-hover); transform: translateY(-4px); box-shadow: 0 20px 60px rgba(0,0,0,0.4), 0 0 30px rgba(168,85,247,0.05); }
.card-icon { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 22px; margin-bottom: 20px; }
.card-icon.purple { background: rgba(168, 85, 247, 0.15); }
.card-icon.blue { background: rgba(96, 165, 250, 0.15); }
.card-icon.green { background: rgba(34, 197, 94, 0.15); }
.card-icon.orange { background: rgba(251, 146, 60, 0.15); }
.card-icon.red { background: rgba(239, 68, 68, 0.15); }
.card-icon.yellow { background: rgba(251, 191, 36, 0.15); }
.card-icon.teal { background: rgba(20, 184, 166, 0.15); }
.card h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; }
.card p { color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6; }

/* STRATEGY HEADER */
.strategy-block { margin-bottom: 80px; padding-bottom: 80px; border-bottom: 1px solid var(--border); }
.strategy-block:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
.strategy-number { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 10px; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.25); font-weight: 800; font-size: 15px; color: var(--purple); margin-bottom: 16px; }
.strategy-title { font-size: clamp(1.6rem, 3vw, 2.2rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 16px; }
.strategy-desc { color: var(--text-secondary); font-size: 1rem; line-height: 1.8; max-width: 760px; margin-bottom: 32px; }
.strategy-desc strong { color: var(--text); }
.strategy-desc code { background: rgba(168,85,247,0.1); padding: 2px 8px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.88em; color: var(--purple); }

/* RULE LIST */
.rule-list { list-style: none; display: flex; flex-direction: column; gap: 16px; margin-top: 24px; }
.rule-list li { display: flex; align-items: flex-start; gap: 16px; padding: 20px; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); }
.rule-num { width: 28px; height: 28px; min-width: 28px; border-radius: 8px; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.2); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 12px; color: var(--purple); }
.rule-text { font-size: 14px; color: var(--text-secondary); line-height: 1.6; }
.rule-text strong { color: var(--text); }
.rule-text code { background: rgba(168,85,247,0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em; color: var(--purple); }

/* CTA SECTION */
.cta-section { text-align: center; padding: 100px 0; }
.cta-box { background: linear-gradient(135deg, rgba(168,85,247,0.08) 0%, rgba(124,58,237,0.05) 100%); border: 1px solid rgba(168,85,247,0.2); border-radius: 24px; padding: 80px 40px; position: relative; overflow: hidden; }
.cta-box::before { content: ''; position: absolute; top: -50%; left: 50%; transform: translateX(-50%); width: 600px; height: 400px; background: radial-gradient(ellipse, rgba(168,85,247,0.1) 0%, transparent 70%); filter: blur(40px); pointer-events: none; }
.cta-box h2 { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; position: relative; }
.cta-box p { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 40px; position: relative; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }

/* RELATED LINKS */
.related-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
@media (max-width: 768px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }

/* ARTICLE PROSE */
.prose { max-width: 860px; }
.prose p { color: var(--text-secondary); font-size: 1rem; line-height: 1.8; margin-bottom: 20px; }
.prose p:last-child { margin-bottom: 0; }
.prose strong { color: var(--text); }
.prose code { background: rgba(168,85,247,0.1); padding: 2px 8px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.88em; color: var(--purple); }

/* RISK TABLE */
.risk-table { width: 100%; border-collapse: collapse; }
.risk-table th { text-align: left; padding: 12px 16px; font-size: 12px; font-weight: 600; letter-spacing: 0.05em; text-transform: uppercase; color: var(--text-muted); border-bottom: 1px solid var(--border); }
.risk-table td { padding: 14px 16px; font-size: 14px; border-bottom: 1px solid var(--border); vertical-align: top; color: var(--text-secondary); }
.risk-table tr:last-child td { border-bottom: none; }
.risk-table tr:hover td { background: var(--bg-card); }
.risk-table .metric-name { font-weight: 600; color: var(--text); font-size: 14px; }
.risk-table code { background: rgba(168,85,247,0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--purple); }
.badge-inline { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
.badge-green { background: rgba(34,197,94,0.15); color: #22C55E; }
.badge-yellow { background: rgba(251,191,36,0.15); color: #FBBF24; }
.badge-red { background: rgba(239,68,68,0.15); color: #EF4444; }
.badge-purple { background: rgba(168,85,247,0.15); color: var(--purple); }

/* INFRA GRID */
.infra-pill { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.2); border-radius: 100px; font-size: 13px; font-weight: 500; color: var(--purple); margin: 4px; }
</style>
</head>
<body>

<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &#8594;</a></li>
    </ul>
  </div>
</nav>

<!-- HERO -->
<section class="hero">
  <div class="hero-bg">
    <div class="hero-gradient-1"></div>
    <div class="hero-grid"></div>
  </div>
  <div class="hero-content">
    <div class="hero-badge">
      <div class="hero-badge-dot"></div>
      Autonomous DeFi Execution
    </div>
    <h1>DeFi AI Agent<br><span class="gradient">Strategies</span></h1>
    <p class="hero-desc">
      DeFi protocols generate yield continuously. Optimal capital allocation requires constant monitoring
      across chains, real-time APY comparison, and millisecond execution. These are not tasks for humans
      â€” they are tasks for agents. This guide covers five production-ready strategies
      and the Purple Flea APIs that make them executable.
    </p>
    <div class="hero-actions">
      <a href="https://wallet.purpleflea.com" class="btn-primary" target="_blank">Create agent wallet &#8594;</a>
      <a href="/trading-api/" class="btn-secondary">Trading API Docs</a>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- INTRO -->
<section>
  <div class="container">
    <div class="reveal prose">
      <div class="section-label">Overview</div>
      <h2 class="section-title">Why agents dominate<br>in DeFi</h2>
      <p>
        Decentralised finance is uniquely suited to autonomous agents for three structural reasons.
        First, protocols are permissionless API contracts â€” any entity with a wallet can call them,
        no KYC, no approval, no business hours. Second, the inefficiencies that generate alpha are
        temporary: APY differences between lending protocols, funding rate imbalances, and DEX
        price gaps exist for seconds to hours before arbitrageurs close them. Third, the execution
        is purely programmatic â€” smart contract calls, token approvals, and bridge transactions
        require no human interface.
      </p>
      <p>
        A human DeFi participant can optimise one protocol at a time. An agent monitors dozens of
        protocols across multiple chains simultaneously, rebalances capital in real time, compounds
        yield at the mathematically optimal frequency, and hedges positions the moment risk thresholds
        are crossed. The strategies below represent the highest-return, most agent-friendly approaches
        in the current DeFi landscape.
      </p>
      <p>
        All five strategies use the <strong>Purple Flea Wallet API</strong> for cross-chain capital
        movement and the <strong>Purple Flea Trading API</strong> for perpetual futures positions.
        The wallet provides a single address per chain without local key management; the trading API
        gives direct access to perpetual markets for hedging and funding rate collection.
      </p>
    </div>

    <div class="reveal reveal-delay-1" style="margin-top:60px;">
      <div class="grid-5">
        <div class="card" style="padding:24px;">
          <div class="card-icon green" style="width:40px;height:40px;font-size:18px;margin-bottom:16px;">&#127807;</div>
          <h3 style="font-size:0.95rem;">Yield Farming Optimizer</h3>
          <p style="font-size:0.82rem;">Auto-compound across protocols</p>
        </div>
        <div class="card" style="padding:24px;">
          <div class="card-icon blue" style="width:40px;height:40px;font-size:18px;margin-bottom:16px;">&#128027;</div>
          <h3 style="font-size:0.95rem;">Liquidity Provision</h3>
          <p style="font-size:0.82rem;">Uniswap v3 LP with IL monitoring</p>
        </div>
        <div class="card" style="padding:24px;">
          <div class="card-icon orange" style="width:40px;height:40px;font-size:18px;margin-bottom:16px;">&#128200;</div>
          <h3 style="font-size:0.95rem;">Funding Rate Harvester</h3>
          <p style="font-size:0.82rem;">Collect perp funding, delta-neutral</p>
        </div>
        <div class="card" style="padding:24px;">
          <div class="card-icon purple" style="width:40px;height:40px;font-size:18px;margin-bottom:16px;">&#127760;</div>
          <h3 style="font-size:0.95rem;">Cross-Chain Arbitrage</h3>
          <p style="font-size:0.82rem;">Price gaps across DEXs and chains</p>
        </div>
        <div class="card" style="padding:24px;">
          <div class="card-icon teal" style="width:40px;height:40px;font-size:18px;margin-bottom:16px;">&#128178;</div>
          <h3 style="font-size:0.95rem;">Stablecoin Yield</h3>
          <p style="font-size:0.82rem;">USDC across Aave, Compound, Sky</p>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY 1 -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy 1</div>
      <div class="strategy-block">
        <div class="strategy-number">1</div>
        <h2 class="strategy-title">Yield Farming Optimizer</h2>
        <p class="strategy-desc">
          Yield farming protocols offer APYs that shift hourly as liquidity enters and exits. A static
          allocation optimised today may underperform by 40% within a week. An agent that continuously
          compares APYs across Aave, Compound, Morpho, Yearn, and Convex â€” then reallocates capital
          when the spread justifies the gas cost â€” captures the full yield curve rather than a snapshot.
          <br><br>
          <strong>Auto-compounding</strong> is the second lever. A 15% APY compounded daily becomes 16.2%
          annually; compounded at the Kelly-optimal frequency (when compounding profit exceeds gas cost),
          it maximises geometric growth. The agent calculates the break-even compound frequency and
          triggers harvests only when profitable after gas.
        </p>

        <div class="grid-2" style="margin-bottom:32px;">
          <div class="card">
            <div class="card-icon green">&#127807;</div>
            <h3>Cross-Protocol APY Monitor</h3>
            <p>Poll Aave, Compound, Morpho, Yearn, and Convex supply rates every 5 minutes.
               Maintain a ranked list of best risk-adjusted APY per asset. Trigger rebalance when
               the top protocol beats current allocation by more than the switching cost.</p>
          </div>
          <div class="card">
            <div class="card-icon blue">&#9850;</div>
            <h3>Auto-Compound Trigger</h3>
            <p>Track accrued rewards in real time. Harvest and reinvest when: <code>reward_value_usd &gt; gas_cost_usd * 3</code>.
               The 3x multiplier gives a safety margin for gas price spikes between calculation and execution.</p>
          </div>
        </div>

        <div class="code-block">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-filename">yield_optimizer.py</span>
          </div>
<span class="kw">import</span> requests
<span class="kw">from</span> typing <span class="kw">import</span> Dict, List

BASE_URL = <span class="st">"https://wallet.purpleflea.com/v1"</span>
HEADERS = {<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>, <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>}

PROTOCOLS = {
    <span class="st">"aave_v3_eth"</span>:    <span class="st">"https://aave.com/api/v3/rates?asset=USDC&chain=ethereum"</span>,
    <span class="st">"compound_v3"</span>:    <span class="st">"https://api.compound.finance/api/v2/ctoken?symbol=cUSDCv3"</span>,
    <span class="st">"morpho_blue"</span>:    <span class="st">"https://api.morpho.org/markets?asset=USDC"</span>,
    <span class="st">"aave_v3_arb"</span>:    <span class="st">"https://aave.com/api/v3/rates?asset=USDC&chain=arbitrum"</span>,
}

<span class="kw">def</span> <span class="fn">fetch_apy</span>(protocol: <span class="cls">str</span>, url: <span class="cls">str</span>) -> <span class="cls">float</span>:
    <span class="st">"""Fetch current supply APY for USDC from a given protocol API."""</span>
    <span class="kw">try</span>:
        data = requests.<span class="fn">get</span>(url, timeout=<span class="num">5</span>).<span class="fn">json</span>()
        <span class="cm"># Response shapes vary â€” normalise to a float APY</span>
        <span class="kw">if</span> <span class="st">"supplyApy"</span> <span class="kw">in</span> data:
            <span class="kw">return</span> <span class="cls">float</span>(data[<span class="st">"supplyApy"</span>]) * <span class="num">100</span>
        <span class="kw">elif</span> <span class="st">"supply_rate"</span> <span class="kw">in</span> data:
            <span class="kw">return</span> <span class="cls">float</span>(data[<span class="st">"supply_rate"</span>]) / <span class="num">1e18</span> * <span class="num">365</span> * <span class="num">100</span>
        <span class="kw">return</span> <span class="num">0.0</span>
    <span class="kw">except</span> <span class="cls">Exception</span>:
        <span class="kw">return</span> <span class="num">0.0</span>

<span class="kw">def</span> <span class="fn">get_best_protocol</span>() -> <span class="cls">tuple</span>[<span class="cls">str</span>, <span class="cls">float</span>]:
    <span class="st">"""Returns (protocol_name, apy_pct) for the highest current USDC yield."""</span>
    apys = {p: <span class="fn">fetch_apy</span>(p, url) <span class="kw">for</span> p, url <span class="kw">in</span> PROTOCOLS.items()}
    best = <span class="fn">max</span>(apys, key=apys.<span class="fn">get</span>)
    <span class="kw">return</span> best, apys[best]

<span class="kw">def</span> <span class="fn">should_rebalance</span>(
    current_protocol: <span class="cls">str</span>,
    best_protocol: <span class="cls">str</span>,
    current_apy: <span class="cls">float</span>,
    best_apy: <span class="cls">float</span>,
    position_usd: <span class="cls">float</span>,
    estimated_gas_usd: <span class="cls">float</span> = <span class="num">8.0</span>,
) -> <span class="cls">bool</span>:
    <span class="st">"""
    Only rebalance if annual yield improvement exceeds switching cost.
    Assumes gas cost is recovered within 30 days of improved yield.
    """</span>
    <span class="kw">if</span> current_protocol == best_protocol:
        <span class="kw">return</span> <span class="cls">False</span>
    annual_gain = position_usd * (best_apy - current_apy) / <span class="num">100</span>
    daily_gain = annual_gain / <span class="num">365</span>
    breakeven_days = estimated_gas_usd / daily_gain <span class="kw">if</span> daily_gain > <span class="num">0</span> <span class="kw">else</span> <span class="cls">float</span>(<span class="st">"inf"</span>)
    <span class="kw">return</span> breakeven_days < <span class="num">30</span>  <span class="cm"># rebalance only if payback &lt; 30 days</span>

<span class="kw">def</span> <span class="fn">rebalance_via_wallet</span>(wallet_id: <span class="cls">str</span>, from_protocol: <span class="cls">str</span>, to_protocol: <span class="cls">str</span>, amount_usdc: <span class="cls">float</span>):
    <span class="st">"""
    Execute rebalance: withdraw from current protocol, deposit into best.
    Both operations sent via Purple Flea Wallet API as contract calls.
    Cross-chain rebalances use the wallet swap/bridge endpoint.
    """</span>
    <span class="cm"># Step 1: withdraw from current protocol</span>
    withdraw = requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{BASE_URL}/wallet/contract-call"</span>, headers=HEADERS, json={
        <span class="st">"wallet_id"</span>: wallet_id,
        <span class="st">"protocol"</span>: from_protocol,
        <span class="st">"action"</span>: <span class="st">"withdraw"</span>,
        <span class="st">"asset"</span>: <span class="st">"USDC"</span>,
        <span class="st">"amount"</span>: amount_usdc,
    })
    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Withdrew {amount_usdc} USDC from {from_protocol}: {withdraw.json()['tx_hash']}"</span>)

    <span class="cm"># Step 2: deposit into best protocol (may include bridge if cross-chain)</span>
    deposit = requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{BASE_URL}/wallet/contract-call"</span>, headers=HEADERS, json={
        <span class="st">"wallet_id"</span>: wallet_id,
        <span class="st">"protocol"</span>: to_protocol,
        <span class="st">"action"</span>: <span class="st">"deposit"</span>,
        <span class="st">"asset"</span>: <span class="st">"USDC"</span>,
        <span class="st">"amount"</span>: amount_usdc,
    })
    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Deposited {amount_usdc} USDC into {to_protocol}: {deposit.json()['tx_hash']}"</span>)

<span class="kw">def</span> <span class="fn">calculate_optimal_compound_frequency</span>(
    position_usd: <span class="cls">float</span>,
    apy_pct: <span class="cls">float</span>,
    gas_cost_usd: <span class="cls">float</span> = <span class="num">3.0</span>,
) -> <span class="cls">float</span>:
    <span class="st">"""
    Returns optimal compound interval in hours.
    Compounds when: daily_accrued_reward &gt; gas_cost * 3 (safety margin).
    """</span>
    daily_yield = position_usd * apy_pct / <span class="num">100</span> / <span class="num">365</span>
    hours_to_breakeven = (gas_cost_usd * <span class="num">3</span>) / (daily_yield / <span class="num">24</span>)
    <span class="kw">return</span> <span class="fn">max</span>(hours_to_breakeven, <span class="num">1.0</span>)  <span class="cm"># minimum 1 hour between compounds</span>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY 2 -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy 2</div>
      <div class="strategy-block">
        <div class="strategy-number">2</div>
        <h2 class="strategy-title">Liquidity Provision Agent</h2>
        <p class="strategy-desc">
          Uniswap v3 concentrated liquidity positions earn fees proportional to volume within the
          selected price range. The risk is impermanent loss (IL): if the price moves outside the
          range, the position earns zero fees and holds a suboptimal token ratio. An agent monitors
          positions continuously, adjusts ranges as prices trend, and calculates when accrued fees
          exceed rebalancing cost.
          <br><br>
          <strong>The agent advantage:</strong> humans check LP positions daily or weekly. An agent
          checks every few minutes and can narrow ranges for higher fee yield during high-volume
          windows, or widen ranges before anticipated high-volatility events to reduce rebalance costs.
        </p>

        <div class="code-block">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-filename">lp_agent.py</span>
          </div>
<span class="kw">import</span> math
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">LPPosition</span>:
    pool: <span class="cls">str</span>          <span class="cm"># e.g., "ETH/USDC 0.05%"</span>
    tick_lower: <span class="cls">int</span>
    tick_upper: <span class="cls">int</span>
    liquidity: <span class="cls">float</span>
    fees_earned_usd: <span class="cls">float</span>
    position_value_usd: <span class="cls">float</span>
    entry_price: <span class="cls">float</span>

<span class="kw">def</span> <span class="fn">price_to_tick</span>(price: <span class="cls">float</span>) -> <span class="cls">int</span>:
    <span class="st">"""Convert a token price to the nearest Uniswap v3 tick."""</span>
    <span class="kw">return</span> <span class="cls">int</span>(math.<span class="fn">log</span>(price) / math.<span class="fn">log</span>(<span class="num">1.0001</span>))

<span class="kw">def</span> <span class="fn">calculate_il</span>(entry_price: <span class="cls">float</span>, current_price: <span class="cls">float</span>) -> <span class="cls">float</span>:
    <span class="st">"""
    Returns impermanent loss as a percentage (0.0 to 1.0).
    IL formula for 50/50 constant-product pool.
    """</span>
    r = current_price / entry_price
    il = <span class="num">2</span> * math.<span class="fn">sqrt</span>(r) / (<span class="num">1</span> + r) - <span class="num">1</span>
    <span class="kw">return</span> <span class="fn">abs</span>(il)  <span class="cm"># always negative, return magnitude</span>

<span class="kw">def</span> <span class="fn">should_rerange</span>(
    position: <span class="cls">LPPosition</span>,
    current_price: <span class="cls">float</span>,
    gas_cost_usd: <span class="cls">float</span> = <span class="num">15.0</span>,
    out_of_range_hours: <span class="cls">float</span> = <span class="num">0</span>,
) -> <span class="cls">tuple</span>[<span class="cls">bool</span>, <span class="cls">str</span>]:
    <span class="st">"""
    Decide if a Uniswap v3 position should be reranged.

    Triggers:
    1. Price is out of range (earning zero fees) for over 2 hours
    2. Accrued fees cover rerange gas cost * 3
    3. IL exceeds 5% (price moved significantly from entry)
    """</span>
    current_tick = <span class="fn">price_to_tick</span>(current_price)
    in_range = position.tick_lower <= current_tick <= position.tick_upper
    il = <span class="fn">calculate_il</span>(position.entry_price, current_price)

    <span class="kw">if not</span> in_range <span class="kw">and</span> out_of_range_hours >= <span class="num">2</span>:
        <span class="kw">return</span> <span class="cls">True</span>, <span class="st">"out_of_range_2h"</span>
    <span class="kw">if</span> position.fees_earned_usd >= gas_cost_usd * <span class="num">3</span>:
        <span class="kw">return</span> <span class="cls">True</span>, <span class="st">"fees_cover_rerange"</span>
    <span class="kw">if</span> il > <span class="num">0.05</span>:
        <span class="kw">return</span> <span class="cls">True</span>, <span class="st">"il_threshold"</span>
    <span class="kw">return</span> <span class="cls">False</span>, <span class="st">"hold"</span>

<span class="kw">def</span> <span class="fn">compute_new_range</span>(
    current_price: <span class="cls">float</span>,
    volatility_24h_pct: <span class="cls">float</span>,
    range_width_multiplier: <span class="cls">float</span> = <span class="num">2.0</span>,
) -> <span class="cls">tuple</span>[<span class="cls">float</span>, <span class="cls">float</span>]:
    <span class="st">"""
    Set the new LP range as current_price Â± (volatility * multiplier).
    Wider ranges earn fewer fees per unit of liquidity but rebalance less often.
    Start with 2x daily vol, tighten if volume is consistently high.
    """</span>
    band = current_price * (volatility_24h_pct / <span class="num">100</span>) * range_width_multiplier
    <span class="kw">return</span> current_price - band, current_price + band

<span class="kw">def</span> <span class="fn">rerange_position</span>(wallet_id: <span class="cls">str</span>, position: <span class="cls">LPPosition</span>, new_lower: <span class="cls">float</span>, new_upper: <span class="cls">float</span>):
    <span class="st">"""
    Remove liquidity from old range, collect fees, re-add at new range.
    All steps executed via Purple Flea Wallet API contract calls.
    """</span>
    <span class="kw">import</span> requests
    base = <span class="st">"https://wallet.purpleflea.com/v1/wallet/contract-call"</span>
    hdrs = {<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>}

    <span class="cm"># 1. Remove liquidity + collect fees</span>
    requests.<span class="fn">post</span>(base, headers=hdrs, json={
        <span class="st">"wallet_id"</span>: wallet_id, <span class="st">"protocol"</span>: <span class="st">"uniswap_v3"</span>,
        <span class="st">"action"</span>: <span class="st">"remove_liquidity"</span>, <span class="st">"pool"</span>: position.pool,
        <span class="st">"tick_lower"</span>: position.tick_lower, <span class="st">"tick_upper"</span>: position.tick_upper,
    })

    <span class="cm"># 2. Re-add at new range</span>
    requests.<span class="fn">post</span>(base, headers=hdrs, json={
        <span class="st">"wallet_id"</span>: wallet_id, <span class="st">"protocol"</span>: <span class="st">"uniswap_v3"</span>,
        <span class="st">"action"</span>: <span class="st">"add_liquidity"</span>, <span class="st">"pool"</span>: position.pool,
        <span class="st">"tick_lower"</span>: <span class="fn">price_to_tick</span>(new_lower),
        <span class="st">"tick_upper"</span>: <span class="fn">price_to_tick</span>(new_upper),
        <span class="st">"amount_token0"</span>: <span class="st">"auto"</span>,  <span class="cm"># wallet splits optimally</span>
    })
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY 3 -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy 3</div>
      <div class="strategy-block">
        <div class="strategy-number">3</div>
        <h2 class="strategy-title">Funding Rate Harvester</h2>
        <p class="strategy-desc">
          Perpetual futures markets pay a periodic funding rate between long and short position holders.
          When longs dominate (typical in bull markets), shorts receive funding. The strategy is
          delta-neutral: hold spot ETH (long) and an equal short perpetual position, earning funding
          on the short without directional exposure. Annualised yields during high-sentiment periods
          reach 20-60%.
          <br><br>
          <strong>The Purple Flea Trading API</strong> provides direct access to perpetual positions.
          The wallet API holds the spot collateral. The agent opens the hedge when funding rate exceeds
          a threshold and closes it when the rate compresses, keeping capital deployed only when the
          yield justifies the execution and counterparty risk.
        </p>

        <div class="code-block">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-filename">funding_harvester.py</span>
          </div>
<span class="kw">import</span> requests

WALLET_BASE = <span class="st">"https://wallet.purpleflea.com/v1"</span>
TRADING_BASE = <span class="st">"https://trading.purpleflea.com/v1"</span>
HEADERS = {<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>, <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>}

MIN_FUNDING_RATE_APR = <span class="num">15.0</span>   <span class="cm"># open hedge only above 15% APR</span>
CLOSE_FUNDING_RATE_APR = <span class="num">5.0</span>   <span class="cm"># close hedge below 5% APR</span>

<span class="kw">def</span> <span class="fn">get_funding_rate</span>(symbol: <span class="cls">str</span> = <span class="st">"ETH-PERP"</span>) -> <span class="cls">dict</span>:
    <span class="st">"""
    Fetch current funding rate from Purple Flea Trading API.
    Returns: { "rate_8h": 0.0003, "rate_apr": 13.14, "next_funding_ts": 1234567890 }
    """</span>
    resp = requests.<span class="fn">get</span>(
        <span class="fn">f</span><span class="st">"{TRADING_BASE}/markets/{symbol}/funding"</span>,
        headers=HEADERS,
    )
    <span class="kw">return</span> resp.<span class="fn">json</span>()

<span class="kw">def</span> <span class="fn">open_delta_neutral_position</span>(
    wallet_id: <span class="cls">str</span>,
    notional_usd: <span class="cls">float</span>,
    symbol: <span class="cls">str</span> = <span class="st">"ETH-PERP"</span>,
) -> <span class="cls">dict</span>:
    <span class="st">"""
    Open a delta-neutral funding harvest position:
    - Buy spot ETH via wallet swap (long leg)
    - Short equal notional ETH-PERP via Trading API (short leg)
    Net delta: ~zero. P&amp;L comes from funding payments to the short.
    """</span>
    <span class="cm"># Leg 1: buy spot ETH via wallet swap</span>
    spot = requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{WALLET_BASE}/wallet/swap"</span>, headers=HEADERS, json={
        <span class="st">"wallet_id"</span>: wallet_id,
        <span class="st">"from_asset"</span>: <span class="st">"USDC"</span>,
        <span class="st">"to_asset"</span>: <span class="st">"ETH"</span>,
        <span class="st">"amount_usd"</span>: notional_usd,
        <span class="st">"slippage_bps"</span>: <span class="num">30</span>,
    }).<span class="fn">json</span>()

    <span class="cm"># Leg 2: short perpetual via Trading API</span>
    perp = requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{TRADING_BASE}/orders"</span>, headers=HEADERS, json={
        <span class="st">"symbol"</span>: symbol,
        <span class="st">"side"</span>: <span class="st">"sell"</span>,
        <span class="st">"type"</span>: <span class="st">"market"</span>,
        <span class="st">"notional_usd"</span>: notional_usd,
        <span class="st">"leverage"</span>: <span class="num">1</span>,  <span class="cm"># 1x leverage = fully collateralised, minimal liquidation risk</span>
        <span class="st">"reduce_only"</span>: <span class="cls">False</span>,
    }).<span class="fn">json</span>()

    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Delta-neutral position opened: spot={spot['eth_received']} ETH, perp={perp['order_id']}"</span>)
    <span class="kw">return</span> {<span class="st">"spot_tx"</span>: spot[<span class="st">"tx_hash"</span>], <span class="st">"perp_order"</span>: perp[<span class="st">"order_id"</span>]}

<span class="kw">def</span> <span class="fn">close_delta_neutral_position</span>(wallet_id: <span class="cls">str</span>, perp_order_id: <span class="cls">str</span>, eth_amount: <span class="cls">float</span>):
    <span class="st">"""Close both legs when funding rate compresses below threshold."""</span>
    <span class="cm"># Close perp short</span>
    requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{TRADING_BASE}/orders"</span>, headers=HEADERS, json={
        <span class="st">"symbol"</span>: <span class="st">"ETH-PERP"</span>, <span class="st">"side"</span>: <span class="st">"buy"</span>, <span class="st">"type"</span>: <span class="st">"market"</span>,
        <span class="st">"reduce_only"</span>: <span class="cls">True</span>, <span class="st">"close_order_id"</span>: perp_order_id,
    })
    <span class="cm"># Sell spot ETH back to USDC</span>
    requests.<span class="fn">post</span>(<span class="fn">f</span><span class="st">"{WALLET_BASE}/wallet/swap"</span>, headers=HEADERS, json={
        <span class="st">"wallet_id"</span>: wallet_id, <span class="st">"from_asset"</span>: <span class="st">"ETH"</span>,
        <span class="st">"to_asset"</span>: <span class="st">"USDC"</span>, <span class="st">"amount_token"</span>: eth_amount,
    })

<span class="kw">def</span> <span class="fn">funding_harvest_loop</span>(wallet_id: <span class="cls">str</span>, notional_usd: <span class="cls">float</span>):
    <span class="st">"""Main agent loop for funding rate harvesting."""</span>
    <span class="kw">import</span> time
    active_position = <span class="cls">None</span>
    <span class="kw">while</span> <span class="cls">True</span>:
        funding = <span class="fn">get_funding_rate</span>()
        apr = funding[<span class="st">"rate_apr"</span>]
        <span class="fn">print</span>(<span class="fn">f</span><span class="st">"ETH-PERP funding APR: {apr:.2f}%"</span>)

        <span class="kw">if</span> active_position <span class="kw">is None and</span> apr >= MIN_FUNDING_RATE_APR:
            active_position = <span class="fn">open_delta_neutral_position</span>(wallet_id, notional_usd)
        <span class="kw">elif</span> active_position <span class="kw">is not None and</span> apr < CLOSE_FUNDING_RATE_APR:
            <span class="fn">close_delta_neutral_position</span>(wallet_id, active_position[<span class="st">"perp_order"</span>], notional_usd / <span class="num">3000</span>)
            active_position = <span class="cls">None</span>

        time.<span class="fn">sleep</span>(<span class="num">300</span>)  <span class="cm"># check every 5 minutes</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY 4 -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy 4</div>
      <div class="strategy-block">
        <div class="strategy-number">4</div>
        <h2 class="strategy-title">Cross-Chain Arbitrage</h2>
        <p class="strategy-desc">
          The same token can trade at different prices across chains and DEXs simultaneously.
          ETH on Uniswap (Ethereum) vs Uniswap (Arbitrum), USDC on Curve (Ethereum) vs Curve (Optimism),
          or BTC between Wrapped BTC implementations. Bridging costs and time are the limiting factors.
          An agent calculates net profit after bridge fees and gas, and executes only when the spread
          exceeds a profitability threshold.
          <br><br>
          The <strong>Purple Flea Wallet swap API</strong> handles cross-chain bridge execution as a
          single API call, abstracting the underlying bridge protocol selection and routing.
        </p>

        <div class="code-block">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-filename">cross_chain_arb.py</span>
          </div>
<span class="kw">import</span> asyncio
<span class="kw">import</span> aiohttp
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass
<span class="kw">from</span> typing <span class="kw">import</span> Optional

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">ArbOpportunity</span>:
    asset: <span class="cls">str</span>
    buy_chain: <span class="cls">str</span>
    sell_chain: <span class="cls">str</span>
    buy_price: <span class="cls">float</span>
    sell_price: <span class="cls">float</span>
    spread_pct: <span class="cls">float</span>
    estimated_profit_usd: <span class="cls">float</span>
    bridge_cost_usd: <span class="cls">float</span>
    bridge_time_minutes: <span class="cls">float</span>

DEX_PRICE_APIS = {
    <span class="st">"ethereum"</span>: <span class="st">"https://api.1inch.dev/price/v1.1/1/{token}"</span>,
    <span class="st">"arbitrum"</span>: <span class="st">"https://api.1inch.dev/price/v1.1/42161/{token}"</span>,
    <span class="st">"optimism"</span>: <span class="st">"https://api.1inch.dev/price/v1.1/10/{token}"</span>,
    <span class="st">"base"</span>:     <span class="st">"https://api.1inch.dev/price/v1.1/8453/{token}"</span>,
}

BRIDGE_COSTS_USD = {
    (<span class="st">"ethereum"</span>, <span class="st">"arbitrum"</span>): <span class="num">3.50</span>,
    (<span class="st">"ethereum"</span>, <span class="st">"optimism"</span>): <span class="num">3.50</span>,
    (<span class="st">"ethereum"</span>, <span class="st">"base"</span>):     <span class="num">2.00</span>,
    (<span class="st">"arbitrum"</span>, <span class="st">"optimism"</span>): <span class="num">0.50</span>,  <span class="cm"># L2-to-L2 is cheaper</span>
}

<span class="kw">async def</span> <span class="fn">get_token_price_on_chain</span>(
    session: <span class="cls">aiohttp.ClientSession</span>,
    chain: <span class="cls">str</span>,
    token_address: <span class="cls">str</span>,
) -> <span class="cls">float</span>:
    url = DEX_PRICE_APIS[chain].<span class="fn">format</span>(token=token_address)
    <span class="kw">async with</span> session.<span class="fn">get</span>(url) <span class="kw">as</span> r:
        data = <span class="kw">await</span> r.<span class="fn">json</span>()
        <span class="kw">return</span> <span class="cls">float</span>(data.<span class="fn">get</span>(token_address, {}).<span class="fn">get</span>(<span class="st">"usd"</span>, <span class="num">0</span>))

<span class="kw">async def</span> <span class="fn">find_arb_opportunities</span>(
    session: <span class="cls">aiohttp.ClientSession</span>,
    token_address: <span class="cls">str</span>,
    asset_symbol: <span class="cls">str</span>,
    trade_size_usd: <span class="cls">float</span>,
    min_profit_usd: <span class="cls">float</span> = <span class="num">20.0</span>,
) -> <span class="cls">list</span>[<span class="cls">ArbOpportunity</span>]:
    <span class="st">"""Scan all chain pairs for a profitable arbitrage on the given token."""</span>
    chains = <span class="fn">list</span>(DEX_PRICE_APIS.<span class="fn">keys</span>())
    prices = <span class="kw">await</span> asyncio.<span class="fn">gather</span>(
        *[<span class="fn">get_token_price_on_chain</span>(session, c, token_address) <span class="kw">for</span> c <span class="kw">in</span> chains],
        return_exceptions=<span class="cls">True</span>
    )
    price_map = {c: p <span class="kw">for</span> c, p <span class="kw">in</span> <span class="fn">zip</span>(chains, prices) <span class="kw">if isinstance</span>(p, <span class="cls">float</span>) <span class="kw">and</span> p > <span class="num">0</span>}

    opps = []
    <span class="kw">for</span> buy_chain, buy_price <span class="kw">in</span> price_map.items():
        <span class="kw">for</span> sell_chain, sell_price <span class="kw">in</span> price_map.items():
            <span class="kw">if</span> buy_chain == sell_chain:
                <span class="kw">continue</span>
            bridge_cost = BRIDGE_COSTS_USD.<span class="fn">get</span>((buy_chain, sell_chain), <span class="num">5.0</span>)
            tokens = trade_size_usd / buy_price
            gross_profit = tokens * (sell_price - buy_price)
            net_profit = gross_profit - bridge_cost - <span class="num">3.0</span>  <span class="cm"># $3 gas estimate</span>
            spread_pct = (sell_price - buy_price) / buy_price * <span class="num">100</span>

            <span class="kw">if</span> net_profit >= min_profit_usd:
                opps.<span class="fn">append</span>(<span class="cls">ArbOpportunity</span>(
                    asset=asset_symbol, buy_chain=buy_chain, sell_chain=sell_chain,
                    buy_price=buy_price, sell_price=sell_price, spread_pct=spread_pct,
                    estimated_profit_usd=net_profit, bridge_cost_usd=bridge_cost,
                    bridge_time_minutes=<span class="num">2.0</span> <span class="kw">if</span> <span class="st">"arbitrum"</span> <span class="kw">in</span> (buy_chain, sell_chain) <span class="kw">else</span> <span class="num">15.0</span>,
                ))
    <span class="kw">return sorted</span>(opps, key=<span class="kw">lambda</span> o: o.estimated_profit_usd, reverse=<span class="cls">True</span>)

<span class="kw">def</span> <span class="fn">execute_arb</span>(wallet_id: <span class="cls">str</span>, opp: <span class="cls">ArbOpportunity</span>, amount_usd: <span class="cls">float</span>):
    <span class="st">"""
    Execute cross-chain arb via Purple Flea wallet cross-chain swap endpoint.
    The wallet API selects the optimal bridge, handles token approvals,
    and tracks the bridge transaction until confirmed on the destination chain.
    """</span>
    <span class="kw">import</span> requests
    resp = requests.<span class="fn">post</span>(
        <span class="st">"https://wallet.purpleflea.com/v1/wallet/cross-chain-swap"</span>,
        headers={<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>},
        json={
            <span class="st">"wallet_id"</span>: wallet_id,
            <span class="st">"asset"</span>: opp.asset,
            <span class="st">"from_chain"</span>: opp.buy_chain,
            <span class="st">"to_chain"</span>: opp.sell_chain,
            <span class="st">"amount_usd"</span>: amount_usd,
            <span class="st">"slippage_bps"</span>: <span class="num">50</span>,
            <span class="st">"bridge_strategy"</span>: <span class="st">"fastest"</span>,  <span class="cm"># "cheapest" | "fastest" | "safest"</span>
        }
    )
    <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Arb submitted: {opp.asset} {opp.buy_chain}â†’{opp.sell_chain} est_profit=${opp.estimated_profit_usd:.2f}"</span>)
    <span class="kw">return</span> resp.<span class="fn">json</span>()
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY 5 -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy 5</div>
      <div class="strategy-block">
        <div class="strategy-number">5</div>
        <h2 class="strategy-title">Stablecoin Yield Maximizer</h2>
        <p class="strategy-desc">
          USDC and USDT lending rates across Aave, Compound, Sky (formerly MakerDAO), and Euler
          diverge constantly as utilisation rates change with market demand. The stablecoin yield
          maximizer holds no directional risk â€” it is pure rate arbitrage between lending protocols.
          With $100,000 deployed, even a 2% APY spread captured continuously represents $2,000
          annually in additional yield from just rebalancing.
          <br><br>
          The strategy pairs naturally with the <strong>yield farming optimizer</strong> from Strategy 1
          but deserves its own focus because stablecoins have a distinct risk profile: no IL,
          no price risk, minimal smart contract complexity. The main risks are protocol insolvency
          and smart contract bugs â€” manage with protocol concentration limits.
        </p>

        <div class="code-block">
          <div class="code-header">
            <div class="code-dot red"></div>
            <div class="code-dot yellow"></div>
            <div class="code-dot green"></div>
            <span class="code-filename">stablecoin_maximizer.py</span>
          </div>
<span class="kw">import</span> requests
<span class="kw">from</span> datetime <span class="kw">import</span> datetime

STABLE_PROTOCOLS = {
    <span class="st">"aave_v3"</span>:     {<span class="st">"chain"</span>: <span class="st">"ethereum"</span>, <span class="st">"max_allocation_pct"</span>: <span class="num">40</span>, <span class="st">"audit_score"</span>: <span class="num">9</span>},
    <span class="st">"compound_v3"</span>: {<span class="st">"chain"</span>: <span class="st">"ethereum"</span>, <span class="st">"max_allocation_pct"</span>: <span class="num">30</span>, <span class="st">"audit_score"</span>: <span class="num">9</span>},
    <span class="st">"morpho"</span>:      {<span class="st">"chain"</span>: <span class="st">"ethereum"</span>, <span class="st">"max_allocation_pct"</span>: <span class="num">20</span>, <span class="st">"audit_score"</span>: <span class="num">8</span>},
    <span class="st">"sky_savings"</span>: {<span class="st">"chain"</span>: <span class="st">"ethereum"</span>, <span class="st">"max_allocation_pct"</span>: <span class="num">20</span>, <span class="st">"audit_score"</span>: <span class="num">8</span>},
    <span class="st">"aave_arb"</span>:    {<span class="st">"chain"</span>: <span class="st">"arbitrum"</span>, <span class="st">"max_allocation_pct"</span>: <span class="num">25</span>, <span class="st">"audit_score"</span>: <span class="num">9</span>},
}

<span class="at">@dataclass</span>  <span class="cm"># from dataclasses import dataclass</span>
<span class="kw">class</span> <span class="cls">StableAllocation</span>:
    protocol: <span class="cls">str</span>
    amount_usdc: <span class="cls">float</span>
    apy_pct: <span class="cls">float</span>
    chain: <span class="cls">str</span>
    deposited_at: <span class="cls">str</span>

<span class="kw">def</span> <span class="fn">get_risk_adjusted_apy</span>(raw_apy: <span class="cls">float</span>, audit_score: <span class="cls">int</span>) -> <span class="cls">float</span>:
    <span class="st">"""
    Discount APY by protocol risk score (1-10, 10 = most trusted).
    A 6% APY from an audit_score=6 protocol is treated as ~4.8% adjusted.
    """</span>
    risk_multiplier = audit_score / <span class="num">10</span>
    <span class="kw">return</span> raw_apy * risk_multiplier

<span class="kw">def</span> <span class="fn">build_optimal_allocation</span>(
    total_usdc: <span class="cls">float</span>,
    current_apys: <span class="cls">dict</span>,  <span class="cm"># {protocol: apy_pct}</span>
) -> <span class="cls">list</span>[<span class="cls">StableAllocation</span>]:
    <span class="st">"""
    Allocate USDC across protocols in risk-adjusted APY order,
    respecting per-protocol concentration limits.
    """</span>
    scored = []
    <span class="kw">for</span> protocol, meta <span class="kw">in</span> STABLE_PROTOCOLS.items():
        raw_apy = current_apys.<span class="fn">get</span>(protocol, <span class="num">0</span>)
        adj_apy = <span class="fn">get_risk_adjusted_apy</span>(raw_apy, meta[<span class="st">"audit_score"</span>])
        max_alloc = total_usdc * meta[<span class="st">"max_allocation_pct"</span>] / <span class="num">100</span>
        scored.<span class="fn">append</span>((protocol, adj_apy, max_alloc, meta[<span class="st">"chain"</span>]))

    scored.<span class="fn">sort</span>(key=<span class="kw">lambda</span> x: x[<span class="num">1</span>], reverse=<span class="cls">True</span>)

    allocations = []
    remaining = total_usdc
    <span class="kw">for</span> protocol, apy, max_alloc, chain <span class="kw">in</span> scored:
        <span class="kw">if</span> remaining <= <span class="num">0</span> <span class="kw">or</span> apy <= <span class="num">0</span>:
            <span class="kw">break</span>
        alloc = <span class="fn">min</span>(remaining, max_alloc)
        allocations.<span class="fn">append</span>(<span class="cls">StableAllocation</span>(
            protocol=protocol, amount_usdc=alloc,
            apy_pct=apy, chain=chain,
            deposited_at=datetime.<span class="fn">utcnow</span>().<span class="fn">isoformat</span>(),
        ))
        remaining -= alloc
    <span class="kw">return</span> allocations

<span class="kw">def</span> <span class="fn">deploy_allocations</span>(wallet_id: <span class="cls">str</span>, allocations: <span class="cls">list</span>):
    <span class="st">"""Deploy USDC to each protocol via Purple Flea Wallet API."""</span>
    <span class="kw">for</span> alloc <span class="kw">in</span> allocations:
        resp = requests.<span class="fn">post</span>(
            <span class="st">"https://wallet.purpleflea.com/v1/wallet/contract-call"</span>,
            headers={<span class="st">"Authorization"</span>: <span class="st">"Bearer pf_sk_..."</span>},
            json={
                <span class="st">"wallet_id"</span>: wallet_id,
                <span class="st">"protocol"</span>: alloc.protocol,
                <span class="st">"action"</span>: <span class="st">"deposit"</span>,
                <span class="st">"asset"</span>: <span class="st">"USDC"</span>,
                <span class="st">"amount"</span>: alloc.amount_usdc,
                <span class="st">"chain"</span>: alloc.chain,
            }
        )
        <span class="fn">print</span>(<span class="fn">f</span><span class="st">"Deployed {alloc.amount_usdc:.0f} USDC to {alloc.protocol} ({alloc.apy_pct:.2f}% adj APY)"</span>)
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RISK FRAMEWORK -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Risk Framework</div>
      <h2 class="section-title">Position sizing, stop-losses,<br>and correlation limits</h2>
      <p class="section-desc">
        A DeFi agent running multiple strategies simultaneously must manage a portfolio of risks, not
        individual position risks. The rules below apply to the combined portfolio.
      </p>
    </div>

    <div class="reveal reveal-delay-1" style="margin-bottom:40px;">
      <table class="risk-table" style="background:var(--bg-card);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
        <thead>
          <tr>
            <th>Metric</th>
            <th>Rule</th>
            <th>Rationale</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="metric-name">Max position per protocol</td>
            <td>25% of total capital</td>
            <td>Limits smart contract exploit exposure to a survivable loss</td>
            <td><span class="badge-inline badge-green">Enforced in code</span></td>
          </tr>
          <tr>
            <td class="metric-name">Max directional exposure</td>
            <td>&lt;10% net delta</td>
            <td>Funding harvest and arb strategies must stay near delta-neutral</td>
            <td><span class="badge-inline badge-green">Checked hourly</span></td>
          </tr>
          <tr>
            <td class="metric-name">Drawdown stop-loss</td>
            <td>15% from high-water mark</td>
            <td>Exits all positions if portfolio falls 15% from peak value</td>
            <td><span class="badge-inline badge-yellow">Soft limit first</span></td>
          </tr>
          <tr>
            <td class="metric-name">Cross-protocol correlation</td>
            <td>Max 2 strategies on same protocol</td>
            <td>Aave exploit hits yield farming AND stablecoin allocation simultaneously</td>
            <td><span class="badge-inline badge-green">Allocation-time check</span></td>
          </tr>
          <tr>
            <td class="metric-name">LP rebalance gas budget</td>
            <td>Max 0.5% of position/month</td>
            <td>Excess rebalancing erodes more yield than it captures</td>
            <td><span class="badge-inline badge-green">Per-position tracker</span></td>
          </tr>
          <tr>
            <td class="metric-name">Bridge exposure</td>
            <td>Max 20% of capital in-transit</td>
            <td>Funds in bridge cannot be quickly withdrawn if market moves</td>
            <td><span class="badge-inline badge-yellow">Best-effort</span></td>
          </tr>
          <tr>
            <td class="metric-name">Funding rate reversal</td>
            <td>Auto-close if rate turns negative</td>
            <td>Negative funding means the short pays longs â€” reverse or close immediately</td>
            <td><span class="badge-inline badge-green">Checked every 5min</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="reveal reveal-delay-2">
      <ul class="rule-list">
        <li>
          <div class="rule-num">1</div>
          <div class="rule-text">
            <strong>Position sizing via fractional Kelly.</strong> For strategies with quantifiable edge
            (e.g., funding rate spread vs cost), apply half-Kelly position sizing. For strategies where
            edge is structural rather than probabilistic (yield farming), size by risk budget: allocate
            up to 25% per protocol, diversified across at least 4 protocols.
          </div>
        </li>
        <li>
          <div class="rule-num">2</div>
          <div class="rule-text">
            <strong>Stop-losses must be code, not config.</strong> A stop-loss stored in a config file
            can be overridden by a bug, race condition, or deployment error. Stop-loss logic must be
            an unconditional assertion inside the execution path: <code>assert portfolio_value &gt; stop_loss_usd</code>
            before every trade. If it fails, the agent halts and alerts.
          </div>
        </li>
        <li>
          <div class="rule-num">3</div>
          <div class="rule-text">
            <strong>Correlation limits prevent cascading failures.</strong> In a broad market sell-off,
            ETH price drops, funding rates turn negative, LP positions go out of range, and stablecoin
            demand spikes â€” all simultaneously. Do not run all five strategies at maximum allocation
            during high-volatility regimes. Scale down correlated strategies together.
          </div>
        </li>
        <li>
          <div class="rule-num">4</div>
          <div class="rule-text">
            <strong>Audit trail for every state change.</strong> Every deposit, withdrawal, rebalance,
            bridge, and trade must be logged with timestamp, transaction hash, gas cost, pre/post
            portfolio value, and the decision trigger that caused the action. This log is how you
            diagnose issues and tune strategy parameters over time.
          </div>
        </li>
      </ul>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- INFRASTRUCTURE -->
<section>
  <div class="container">
    <div class="reveal">
      <div class="section-label">Infrastructure</div>
      <h2 class="section-title">Purple Flea APIs for<br>every DeFi strategy</h2>
      <p class="section-desc">
        One wallet, one trading account, and one API key connect your agent to every strategy described
        above â€” across Ethereum, Arbitrum, Optimism, Base, and Solana.
      </p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="grid-2" style="margin-bottom:48px;">
        <div class="card">
          <div class="card-icon purple">&#128184;</div>
          <h3>Wallet API &mdash; all chain interactions</h3>
          <p style="margin-bottom:16px;">The Purple Flea Wallet API handles every on-chain operation
             in this guide: token swaps, DEX interactions, bridge execution, protocol deposits and
             withdrawals, LP management, and smart contract calls.</p>
          <div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;">
            <span class="infra-pill">POST /wallet/create</span>
            <span class="infra-pill">POST /wallet/swap</span>
            <span class="infra-pill">POST /wallet/cross-chain-swap</span>
            <span class="infra-pill">POST /wallet/contract-call</span>
            <span class="infra-pill">GET /wallet/balance</span>
            <span class="infra-pill">GET /wallet/portfolio</span>
          </div>
        </div>
        <div class="card">
          <div class="card-icon blue">&#128200;</div>
          <h3>Trading API &mdash; perpetuals and hedging</h3>
          <p style="margin-bottom:16px;">Used exclusively in Strategy 3 (funding rate harvesting)
             and optionally to hedge delta exposure from LP positions. Provides market and limit
             orders, position management, funding rate data, and P&amp;L tracking for perpetual futures.</p>
          <div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:8px;">
            <span class="infra-pill">POST /orders</span>
            <span class="infra-pill">GET /markets/:symbol/funding</span>
            <span class="infra-pill">GET /positions</span>
            <span class="infra-pill">GET /portfolio/pnl</span>
            <span class="infra-pill">DELETE /orders/:id</span>
          </div>
        </div>
      </div>
    </div>

    <div class="reveal reveal-delay-2">
      <div class="grid-3">
        <div class="card">
          <div class="card-icon green">&#128640;</div>
          <h3>No Local Key Management</h3>
          <p>Every wallet operation is authenticated with your API key. Private keys are stored in
             Purple Flea HSMs â€” never in your agent's memory, disk, or environment variables. If
             your agent is compromised, the attacker has your API key scope, not your private key.</p>
        </div>
        <div class="card">
          <div class="card-icon orange">&#9881;</div>
          <h3>Multi-Chain Single API</h3>
          <p>Ethereum, Arbitrum, Optimism, Base, Solana â€” all exposed through the same endpoints.
             Your agent does not need chain-specific libraries or RPC node management. Specify
             <code>chain: "arbitrum"</code> and the API routes correctly.</p>
        </div>
        <div class="card">
          <div class="card-icon yellow">&#127775;</div>
          <h3>Referral: 10-20% of Agent Fees</h3>
          <p>Onboard other DeFi agents to Purple Flea and earn 10-20% of their transaction fees
             indefinitely. An agent that operates at $1M+ volume and onboards five similar agents
             generates significant passive referral income on top of DeFi yield.</p>
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- REFERRAL -->
<section style="padding:60px 0;">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Referral Program</div>
      <h2 class="section-title" style="margin-bottom:24px;">Earn from other<br>DeFi agents you onboard</h2>
      <div class="prose" style="margin-bottom:40px;">
        <p>
          Purple Flea's agent referral program pays <strong>10-20% of all fees</strong> generated by
          agents you introduce â€” in perpetuity. A DeFi yield farming agent running $500,000 in capital
          generates roughly $2,500-5,000 in annual API fees depending on rebalance frequency.
          Referring one such agent earns you $250-$1,000 per year passively.
        </p>
        <p>
          If your DeFi agent communicates with other agents (for example, a portfolio management
          agent that spawns strategy sub-agents), you can build the referral link directly into the
          agent's onboarding flow: any agent that creates a wallet using your referral code generates
          passive income for your primary agent without any human intervention.
        </p>
      </div>
      <div class="code-block" style="max-width:600px;">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">referral.py</span>
        </div>
<span class="kw">def</span> <span class="fn">onboard_sub_agent</span>(referral_code: <span class="cls">str</span>, sub_agent_label: <span class="cls">str</span>) -> <span class="cls">dict</span>:
    <span class="st">"""
    When spawning a sub-agent that needs its own wallet,
    include the referral code to earn fees on its activity.
    """</span>
    resp = requests.<span class="fn">post</span>(
        <span class="st">"https://wallet.purpleflea.com/v1/wallet/create"</span>,
        headers=HEADERS,
        json={
            <span class="st">"chain"</span>: <span class="st">"ethereum"</span>,
            <span class="st">"label"</span>: sub_agent_label,
            <span class="st">"referral_code"</span>: referral_code,  <span class="cm"># earn 10-20% of sub-agent fees</span>
        }
    )
    <span class="kw">return</span> resp.<span class="fn">json</span>()
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RELATED -->
<section style="padding:60px 0;">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Related Guides</div>
      <h2 class="section-title" style="margin-bottom:32px;">Keep reading</h2>
      <div class="related-grid">
        <a href="/crypto-wallet-api/" class="related-card">
          <div class="label">API Docs</div>
          <div class="title">Wallet API Reference</div>
          <div class="desc">Full endpoint documentation for multi-chain wallet and swap operations</div>
        </a>
        <a href="/trading-api/" class="related-card">
          <div class="label">API Docs</div>
          <div class="title">Trading API Reference</div>
          <div class="desc">Perpetual futures order management, funding rates, and position tracking</div>
        </a>
        <a href="/nft-sniping-agent/" class="related-card">
          <div class="label">Strategy</div>
          <div class="title">NFT Sniping AI Agent</div>
          <div class="desc">Monitor floors, identify underpriced NFTs, and execute instant buys</div>
        </a>
      </div>
    </div>
  </div>
</section>

<!-- CTA -->
<section class="cta-section">
  <div class="container">
    <div class="cta-box reveal">
      <h2>Start building your<br><span style="color:var(--purple)">DeFi agent today</span></h2>
      <p>Create a Purple Flea wallet and trading account. Connect to Aave, Uniswap, and perpetual
         markets through a single API â€” no local key management, no RPC nodes, no chain-specific code.</p>
      <div class="hero-actions">
        <a href="https://wallet.purpleflea.com" class="btn-primary" target="_blank">Create agent wallet &#8594;</a>
        <a href="/trading-api/" class="btn-secondary">Trading API Docs</a>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<footer>
  <div class="container">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo">
          <div class="nav-logo-icon">&#9830;</div>
          Purple Flea
        </a>
        <p>AI-first infrastructure for autonomous agents. Built for machines, verified by math.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Products</h4>
          <ul>
            <li><a href="https://casino.purpleflea.com" target="_blank">Casino</a></li>
            <li><a href="https://trading.purpleflea.com" target="_blank">Trading</a></li>
            <li><a href="https://wallet.purpleflea.com" target="_blank">Wallet</a></li>
            <li><a href="https://domains.purpleflea.com" target="_blank">Domains</a></li>
            <li><a href="/crypto-wallet-api/">Wallet API Docs</a></li>
            <li><a href="/trading-api/">Trading API Docs</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/for-langchain/">LangChain</a></li>
            <li><a href="/for-crewai/">CrewAI</a></li>
            <li><a href="/for-claude/">Claude / MCP</a></li>
            <li><a href="/quick-start">Quick Start</a></li>
            <li><a href="/openapi">OpenAPI</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/pricing">Pricing</a></li>
            <li><a href="/stats">Stats</a></li>
            <li><a href="/changelog">Changelog</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="mailto:hello@purpleflea.com">Contact</a></li>
            <li><a href="https://github.com/Purple-flea" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://github.com/Purple-flea" target="_blank">GitHub</a>
        <a href="https://x.com/purpleflea" target="_blank">X / Twitter</a>
      </div>
    </div>
  </div>
</footer>

<script>
const navbar = document.getElementById('navbar');
window.addEventListener('scroll', () => { navbar.classList.toggle('scrolled', window.scrollY > 50); });
const revealEls = document.querySelectorAll('.reveal');
const revealObs = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('visible'); revealObs.unobserve(e.target); } });
}, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });
revealEls.forEach(el => revealObs.observe(el));
</script>
</body>
</html>
