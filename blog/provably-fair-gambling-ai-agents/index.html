<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Why AI Agents Need Cryptographic Randomness | Purple Flea Blog</title>
<meta name="description" content="Black-box RNG is a security vulnerability for gambling AI agents. Learn how provably fair algorithms work using HMAC-SHA256, how to verify outcomes in Python, and why it matters.">
<link rel="canonical" href="https://purpleflea.com/blog/provably-fair-gambling-ai-agents/">
<meta property="og:title" content="Why AI Agents Need Cryptographic Randomness | Purple Flea Blog">
<meta property="og:description" content="Black-box RNG is a security vulnerability for gambling AI agents. Learn how provably fair algorithms work using HMAC-SHA256, how to verify outcomes in Python, and why it matters.">
<meta property="og:url" content="https://purpleflea.com/blog/provably-fair-gambling-ai-agents/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="Why AI Agents Need Cryptographic Randomness">
<meta name="twitter:description" content="Black-box RNG is a security vulnerability for gambling AI agents. Learn how provably fair algorithms work using HMAC-SHA256, how to verify outcomes in Python, and why it matters.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why AI Agents Need Cryptographic Randomness",
  "description": "Black-box RNG is a security vulnerability for gambling AI agents. Learn how provably fair algorithms work using HMAC-SHA256, how to verify outcomes in Python, and why it matters.",
  "datePublished": "2026-02-22",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" },
  "author": { "@type": "Organization", "name": "Purple Flea Team" },
  "url": "https://purpleflea.com/blog/provably-fair-gambling-ai-agents/",
  "keywords": ["provably fair", "HMAC-SHA256", "AI agents", "casino", "cryptographic randomness", "gambling", "LangChain"]
}
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;450;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7;
  --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B;
  --bg-card: rgba(255, 255, 255, 0.03);
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(168, 85, 247, 0.3);
  --text: #FAFAFA;
  --text-secondary: #A1A1AA;
  --text-muted: #71717A;
  --radius: 16px;
  --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168, 85, 247, 0.3); border-radius: 3px; }
::selection { background: rgba(168, 85, 247, 0.4); color: white; }
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9, 9, 11, 0.8); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* ARTICLE LAYOUT */
.article-wrapper { max-width: 720px; margin: 0 auto; padding: 120px 24px 80px; }

/* BREADCRUMB */
.breadcrumb { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-muted); margin-bottom: 32px; }
.breadcrumb a { color: var(--text-muted); text-decoration: none; transition: color 0.2s; }
.breadcrumb a:hover { color: var(--purple); }
.breadcrumb-sep { color: var(--border-hover); }

/* ARTICLE META */
.article-meta { display: flex; align-items: center; gap: 16px; margin-bottom: 28px; flex-wrap: wrap; }
.tag-chip { display: inline-block; padding: 4px 12px; border-radius: 100px; font-size: 11px; font-weight: 600; letter-spacing: 0.05em; text-transform: uppercase; }
.tag-casino { background: rgba(168,85,247,0.12); color: var(--purple); border: 1px solid rgba(168,85,247,0.2); }
.article-date { font-size: 13px; color: var(--text-muted); }
.article-read-time { font-size: 13px; color: var(--text-muted); }
.article-author { font-size: 13px; color: var(--text-muted); }
.meta-dot { width: 3px; height: 3px; background: var(--text-muted); border-radius: 50%; }

/* ARTICLE TYPOGRAPHY */
.article-title { font-size: clamp(1.9rem, 4vw, 2.8rem); font-weight: 800; letter-spacing: -0.03em; line-height: 1.1; margin-bottom: 40px; }
.article-body { font-size: 1.05rem; line-height: 1.8; color: var(--text-secondary); }
.article-body p { margin-bottom: 1.4em; }
.article-body h2 { font-size: 1.5rem; font-weight: 700; color: var(--text); letter-spacing: -0.02em; margin: 2.4em 0 0.8em; line-height: 1.25; }
.article-body h3 { font-size: 1.15rem; font-weight: 600; color: var(--text); letter-spacing: -0.01em; margin: 1.8em 0 0.6em; }
.article-body a { color: var(--purple); text-decoration: none; border-bottom: 1px solid rgba(168,85,247,0.3); transition: border-color 0.2s; }
.article-body a:hover { border-color: var(--purple); }
.article-body ul, .article-body ol { padding-left: 1.4em; margin-bottom: 1.4em; }
.article-body li { margin-bottom: 0.5em; }
.article-body strong { color: var(--text); font-weight: 600; }
.article-body code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: rgba(168,85,247,0.1); color: var(--purple); padding: 2px 7px; border-radius: 4px; }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.7; overflow-x: auto; position: relative; margin: 1.8em 0; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }

/* CALLOUT */
.callout { background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.2); border-left: 3px solid var(--purple); border-radius: var(--radius-sm); padding: 20px 24px; margin: 1.8em 0; }
.callout p { margin: 0; color: var(--text-secondary); font-size: 0.95rem; }
.callout strong { color: var(--purple); }

/* ARTICLE DIVIDER */
.article-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 2.5em 0; }

/* RELATED */
.related-section { margin-top: 3em; padding-top: 2.5em; border-top: 1px solid var(--border); }
.related-section h3 { font-size: 12px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 20px; }
.related-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
@media (max-width: 700px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; line-height: 1.35; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }
</style>
</head>
<body>

<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &rarr;</a></li>
    </ul>
  </div>
</nav>

<div class="article-wrapper">

  <!-- BREADCRUMB -->
  <nav class="breadcrumb" aria-label="Breadcrumb">
    <a href="/blog/">Blog</a>
    <span class="breadcrumb-sep">/</span>
    <span>Casino</span>
  </nav>

  <!-- META -->
  <div class="article-meta">
    <span class="tag-chip tag-casino">Casino</span>
    <div class="meta-dot"></div>
    <span class="article-date">February 22, 2026</span>
    <div class="meta-dot"></div>
    <span class="article-read-time">6 min read</span>
    <div class="meta-dot"></div>
    <span class="article-author">Purple Flea Team</span>
  </div>

  <!-- TITLE -->
  <h1 class="article-title">Why AI Agents Need Cryptographic Randomness</h1>

  <!-- BODY -->
  <div class="article-body">

    <p>Most gambling software treats randomness as an implementation detail. The casino picks a number, you win or lose, the house takes its edge. For human players, this arrangement is barely tolerable — you're trusting a third party with your money on every single bet. For AI agents, it is a critical security vulnerability.</p>

    <p>This article explains why black-box random number generation is dangerous for autonomous gambling agents, how provably fair algorithms eliminate the trust problem using HMAC-SHA256, and how to implement full bet verification in Python and LangChain.</p>

    <h2>The Problem with Black-Box RNG</h2>

    <p>Most online casino APIs use server-side random number generators that are completely opaque to clients. The server picks a number, maps it to an outcome, and reports the result. There is no way to verify that the reported outcome matches what the RNG actually produced.</p>

    <p>For human players this is risky — you're trusting the casino. For AI agents, it's worse: an automated agent has no intuition to detect cheating, no ability to complain to regulators, and often no human oversight. A malicious casino API could return losing outcomes to agents disproportionately and the agent would never know.</p>

    <p>This is not a theoretical risk. In traditional online gambling, house edge manipulation has been documented in multiple jurisdictions. Operators have been caught adjusting RNG parameters mid-session, selectively applying favorable seeds for human reviewers while serving different outcomes to regular traffic, and simply lying about payout percentages in their software certificates. For AI agents making thousands of automated bets, even a <strong>0.5% undeclared additional edge</strong> compounds into significant losses. An agent placing 10,000 bets per day at $1 each with a hidden 1% extra edge loses an additional $100 every day — $36,500 per year — with no mechanism to detect the fraud.</p>

    <p>The asymmetry is severe. A human notices something feels wrong. An agent does not. The agent just keeps betting.</p>

    <h2>What is Provably Fair?</h2>

    <p>Provably fair gambling uses a <strong>commitment scheme</strong> from cryptography to make outcomes verifiable after the fact without revealing the server's secret beforehand. The core idea was pioneered by early Bitcoin casinos around 2012 and has since become the gold standard for trustless gambling infrastructure.</p>

    <p>The protocol works as follows:</p>

    <ol>
      <li>Before the game starts, the casino commits to its random seed by publishing a hash of that seed. The hash is a one-way function — knowing the hash tells you nothing about the original seed.</li>
      <li>The player provides their own seed (the <strong>client seed</strong>). This can be anything random — a UUID, a timestamp, a hash of a blockchain block.</li>
      <li>The outcome is derived deterministically from both seeds combined using HMAC-SHA256. Neither party can predict the outcome: the casino doesn't know what client seed you'll provide, and you can't reverse-engineer the server seed from its hash.</li>
      <li>After the game resolves, the casino reveals its server seed. You verify that <code>sha256(server_seed) == server_seed_hash</code>, then recompute the outcome yourself. If your calculation matches what the casino reported, the result was fair.</li>
    </ol>

    <p>This makes cheating <strong>mathematically impossible</strong>: the casino cannot change the server seed after seeing your bet because the hash would no longer match, and you cannot predict the outcome in advance because HMAC-SHA256 is computationally irreversible.</p>

    <div class="callout">
      <p><strong>Key property:</strong> The commitment scheme binds the casino to its randomness before your bet is placed. Any post-hoc manipulation of the server seed produces a hash mismatch that anyone can detect. The protocol converts "trust the casino" into "verify the math."</p>
    </div>

    <h2>The HMAC-SHA256 Construction</h2>

    <p>The full algorithm, step by step:</p>

    <ol>
      <li>Server generates 32 cryptographically random bytes: <code>server_seed = os.urandom(32).hex()</code></li>
      <li>Server commits: <code>server_seed_hash = hashlib.sha256(server_seed.encode()).hexdigest()</code></li>
      <li>Game round begins — <code>server_seed_hash</code> is published to the client before any bet is placed.</li>
      <li>Client provides: <code>client_seed</code> (any random string the client chooses)</li>
      <li>A <code>nonce</code> increments with each bet so every bet in a session produces a unique outcome even with the same seeds.</li>
      <li>The raw outcome bytes: <code>outcome_bytes = hmac.new(server_seed.encode(), f"{client_seed}:{nonce}".encode(), hashlib.sha256).digest()</code></li>
      <li>Convert to a float in [0, 1): <code>outcome_float = int.from_bytes(outcome_bytes[:4], 'big') / (2**32)</code></li>
      <li>Map to game result — for a coin flip with 1% house edge: <strong>heads if <code>outcome_float &lt; 0.49</code></strong>, tails otherwise (both sides lose 2% of the time to the house).</li>
    </ol>

    <p>The HMAC construction is important. Using raw SHA256 of the concatenation would allow length-extension attacks. HMAC-SHA256 with the server seed as the key and <code>client_seed:nonce</code> as the message is provably secure under the random oracle model.</p>

    <h2>Verifying in Python — Full Code</h2>

    <p>Here is a complete, self-contained Python function that verifies a single casino bet given the revealed server seed and all other bet parameters:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">verify_bet.py</span>
      </div>
<span class="kw">import</span> hashlib
<span class="kw">import</span> hmac <span class="kw">as</span> hmac_lib


<span class="kw">def</span> <span class="fn">verify_casino_bet</span>(
    server_seed: <span class="cls">str</span>,
    server_seed_hash: <span class="cls">str</span>,
    client_seed: <span class="cls">str</span>,
    nonce: <span class="cls">int</span>,
    result: <span class="cls">str</span>,
    game: <span class="cls">str</span> = <span class="st">"coinflip"</span>,
) -> <span class="cls">bool</span>:
    <span class="st">"""
    Verify that a reported casino outcome is consistent with the
    server seed and client seed using HMAC-SHA256.

    Args:
        server_seed:      The revealed server seed (hex string).
        server_seed_hash: The committed hash published before the bet.
        client_seed:      The client seed used for this bet.
        nonce:            The per-bet nonce (increments each bet).
        result:           The reported outcome, e.g. "heads" or "tails".
        game:             Game type — "coinflip", "dice", "roulette".

    Returns:
        True if the result is cryptographically consistent, False otherwise.
    """</span>
    <span class="cm"># Step 1: Verify the commitment — server_seed must hash to server_seed_hash</span>
    computed_hash = hashlib.<span class="fn">sha256</span>(server_seed.<span class="fn">encode</span>()).<span class="fn">hexdigest</span>()
    <span class="kw">if</span> computed_hash != server_seed_hash:
        <span class="kw">raise</span> <span class="cls">ValueError</span>(
            <span class="st">f"Hash mismatch! server_seed does not match server_seed_hash.\n"</span>
            <span class="st">f"  Expected: {server_seed_hash}\n"</span>
            <span class="st">f"  Got:      {computed_hash}\n"</span>
            <span class="st">f"  => Casino has ALTERED the server seed after your bet. Stop immediately."</span>
        )

    <span class="cm"># Step 2: Recompute the outcome from HMAC-SHA256</span>
    message = <span class="st">f"{client_seed}:{nonce}"</span>.<span class="fn">encode</span>()
    outcome_bytes = hmac_lib.<span class="fn">new</span>(
        server_seed.<span class="fn">encode</span>(),
        message,
        hashlib.sha256,
    ).<span class="fn">digest</span>()

    <span class="cm"># Step 3: Convert first 4 bytes to a float in [0, 1)</span>
    outcome_float = <span class="fn">int</span>.<span class="fn">from_bytes</span>(outcome_bytes[:<span class="num">4</span>], <span class="st">"big"</span>) / (<span class="num">2</span> ** <span class="num">32</span>)

    <span class="cm"># Step 4: Map to game result and compare</span>
    <span class="kw">if</span> game == <span class="st">"coinflip"</span>:
        <span class="cm"># House edge ~2%: heads if < 0.49, tails if >= 0.51, house wins in between</span>
        <span class="kw">if</span> outcome_float < <span class="num">0.49</span>:
            computed_result = <span class="st">"heads"</span>
        <span class="kw">elif</span> outcome_float >= <span class="num">0.51</span>:
            computed_result = <span class="st">"tails"</span>
        <span class="kw">else</span>:
            computed_result = <span class="st">"house"</span>
    <span class="kw">elif</span> game == <span class="st">"dice"</span>:
        <span class="cm"># Returns 1-100 inclusive, fair range is typically 1-98 for 2% edge</span>
        computed_result = <span class="fn">str</span>(<span class="fn">int</span>(outcome_float * <span class="num">100</span>) + <span class="num">1</span>)
    <span class="kw">else</span>:
        <span class="cm"># Generic: return the raw float truncated to 6 decimal places</span>
        computed_result = <span class="st">f"{outcome_float:.6f}"</span>

    <span class="kw">return</span> computed_result == result


<span class="cm"># Example usage</span>
<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="cm"># Simulate a full round</span>
    <span class="kw">import</span> os

    server_seed = os.<span class="fn">urandom</span>(<span class="num">32</span>).<span class="fn">hex</span>()
    server_seed_hash = hashlib.<span class="fn">sha256</span>(server_seed.<span class="fn">encode</span>()).<span class="fn">hexdigest</span>()
    client_seed = <span class="st">"my-agent-seed-abc123"</span>
    nonce = <span class="num">1</span>

    <span class="cm"># Casino reports "heads" — verify it</span>
    is_valid = <span class="fn">verify_casino_bet</span>(
        server_seed=server_seed,
        server_seed_hash=server_seed_hash,
        client_seed=client_seed,
        nonce=nonce,
        result=<span class="st">"heads"</span>,
        game=<span class="st">"coinflip"</span>,
    )
    <span class="fn">print</span>(<span class="st">f"Bet verified: {is_valid}"</span>)
    </div>

    <h2>Why This Matters for Autonomous Agents</h2>

    <p>AI agents are the most vulnerable gambling participants. They operate at scale, automatically, often without human oversight. The properties that make agents powerful — speed, persistence, tirelessness — are exactly the properties that make manipulation profitable for bad actors.</p>

    <p>Consider the attack surface. A human player might place 100 bets in an evening session. An agent places 10,000 bets per day. A hidden 0.5% extra house edge is nearly undetectable at 100 bets but creates a statistically significant and measurable loss at 10,000. More importantly, a targeted agent attack doesn't need to be subtle — if the casino knows a given API key belongs to an agent with no human oversight, it can apply a much larger undeclared edge with minimal risk of detection or complaint.</p>

    <p>Provably fair is not a nice-to-have feature for agent gambling infrastructure. It is a <strong>prerequisite</strong>. Any casino API that does not implement provably fair should be treated as untrustworthy by default.</p>

    <p>The good news: agents can <strong>automate the verification</strong>. After every bet, call <code>POST /casino/verify</code> with the revealed <code>server_seed</code>. If the hash check ever fails, stop betting immediately and flag the anomaly. This turns provably fair from a manual audit tool into a real-time integrity monitor that runs on every single bet without any human involvement.</p>

    <h2>Implementing Verification in LangChain</h2>

    <p>Here is a <code>VerifyCasinoBetTool</code> that wraps the verification logic as a LangChain <code>BaseTool</code>. Drop this into your agent's tool list and it will automatically verify every bet response from the Purple Flea Casino API:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">casino_tools.py</span>
      </div>
<span class="kw">import</span> hashlib
<span class="kw">import</span> hmac <span class="kw">as</span> hmac_lib
<span class="kw">from</span> typing <span class="kw">import</span> <span class="cls">Type</span>
<span class="kw">from</span> pydantic <span class="kw">import</span> <span class="cls">BaseModel</span>, <span class="cls">Field</span>
<span class="kw">from</span> langchain.tools <span class="kw">import</span> <span class="cls">BaseTool</span>
<span class="kw">import</span> requests


<span class="kw">class</span> <span class="cls">VerifyBetInput</span>(<span class="cls">BaseModel</span>):
    server_seed: <span class="cls">str</span> = <span class="cls">Field</span>(description=<span class="st">"Revealed server seed from casino after the bet"</span>)
    server_seed_hash: <span class="cls">str</span> = <span class="cls">Field</span>(description=<span class="st">"Server seed hash published before the bet"</span>)
    client_seed: <span class="cls">str</span> = <span class="cls">Field</span>(description=<span class="st">"Client seed used for this bet"</span>)
    nonce: <span class="cls">int</span> = <span class="cls">Field</span>(description=<span class="st">"Bet nonce (increments per bet)"</span>)
    reported_result: <span class="cls">str</span> = <span class="cls">Field</span>(description=<span class="st">"The outcome the casino reported"</span>)
    game: <span class="cls">str</span> = <span class="cls">Field</span>(default=<span class="st">"coinflip"</span>, description=<span class="st">"Game type: coinflip, dice, roulette"</span>)


<span class="kw">class</span> <span class="cls">VerifyCasinoBetTool</span>(<span class="cls">BaseTool</span>):
    <span class="at">name</span>: <span class="cls">str</span> = <span class="st">"verify_casino_bet"</span>
    <span class="at">description</span>: <span class="cls">str</span> = (
        <span class="st">"Verify that a casino bet outcome is cryptographically fair using HMAC-SHA256. "</span>
        <span class="st">"Call this after every bet with the revealed server_seed. "</span>
        <span class="st">"Returns 'VERIFIED' if fair or raises an error if the casino cheated."</span>
    )
    <span class="at">args_schema</span>: <span class="cls">Type</span>[<span class="cls">BaseModel</span>] = <span class="cls">VerifyBetInput</span>

    <span class="kw">def</span> <span class="fn">_run</span>(
        <span class="kw">self</span>,
        server_seed: <span class="cls">str</span>,
        server_seed_hash: <span class="cls">str</span>,
        client_seed: <span class="cls">str</span>,
        nonce: <span class="cls">int</span>,
        reported_result: <span class="cls">str</span>,
        game: <span class="cls">str</span> = <span class="st">"coinflip"</span>,
    ) -> <span class="cls">str</span>:
        <span class="cm"># 1. Verify the commitment</span>
        computed_hash = hashlib.<span class="fn">sha256</span>(server_seed.<span class="fn">encode</span>()).<span class="fn">hexdigest</span>()
        <span class="kw">if</span> computed_hash != server_seed_hash:
            <span class="kw">return</span> (
                <span class="st">f"FRAUD DETECTED: server_seed hash mismatch. "</span>
                <span class="st">f"Expected {server_seed_hash[:16]}... got {computed_hash[:16]}... "</span>
                <span class="st">f"STOP BETTING IMMEDIATELY."</span>
            )

        <span class="cm"># 2. Recompute outcome</span>
        message = <span class="st">f"{client_seed}:{nonce}"</span>.<span class="fn">encode</span>()
        outcome_bytes = hmac_lib.<span class="fn">new</span>(
            server_seed.<span class="fn">encode</span>(), message, hashlib.sha256
        ).<span class="fn">digest</span>()
        outcome_float = <span class="fn">int</span>.<span class="fn">from_bytes</span>(outcome_bytes[:<span class="num">4</span>], <span class="st">"big"</span>) / (<span class="num">2</span> ** <span class="num">32</span>)

        <span class="cm"># 3. Map to result</span>
        <span class="kw">if</span> game == <span class="st">"coinflip"</span>:
            <span class="kw">if</span> outcome_float < <span class="num">0.49</span>:
                expected = <span class="st">"heads"</span>
            <span class="kw">elif</span> outcome_float >= <span class="num">0.51</span>:
                expected = <span class="st">"tails"</span>
            <span class="kw">else</span>:
                expected = <span class="st">"house"</span>
        <span class="kw">elif</span> game == <span class="st">"dice"</span>:
            expected = <span class="fn">str</span>(<span class="fn">int</span>(outcome_float * <span class="num">100</span>) + <span class="num">1</span>)
        <span class="kw">else</span>:
            expected = <span class="st">f"{outcome_float:.6f}"</span>

        <span class="kw">if</span> expected == reported_result:
            <span class="kw">return</span> <span class="st">f"VERIFIED: outcome '{reported_result}' is cryptographically correct."</span>
        <span class="kw">else</span>:
            <span class="kw">return</span> (
                <span class="st">f"FRAUD DETECTED: casino reported '{reported_result}' "</span>
                <span class="st">f"but HMAC-SHA256 produces '{expected}'. STOP BETTING IMMEDIATELY."</span>
            )

    <span class="kw">async def</span> <span class="fn">_arun</span>(<span class="kw">self</span>, **kwargs) -> <span class="cls">str</span>:
        <span class="kw">return</span> <span class="kw">self</span>.<span class="fn">_run</span>(**kwargs)
    </div>

    <p>Adding this tool to your agent is one line:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">from</span> langchain.agents <span class="kw">import</span> <span class="fn">initialize_agent</span>, <span class="cls">AgentType</span>
<span class="kw">from</span> langchain_openai <span class="kw">import</span> <span class="cls">ChatOpenAI</span>

tools = [
    <span class="cls">VerifyCasinoBetTool</span>(),
    <span class="cm"># ... your other Purple Flea casino tools</span>
]

agent = <span class="fn">initialize_agent</span>(
    tools=tools,
    llm=<span class="cls">ChatOpenAI</span>(model=<span class="st">"gpt-4o"</span>),
    agent=<span class="cls">AgentType</span>.OPENAI_FUNCTIONS,
    verbose=<span class="cls">True</span>,
)
    </div>

    <h2>The Purple Flea Casino API</h2>

    <p>Purple Flea implements provably fair for all games: <strong>coin flip, dice, roulette, and crash</strong>. House edges are 1-2% depending on the game variant, fully documented in the <a href="/casino-api/">Casino API docs</a>. Every game response includes the three fields needed for verification:</p>

    <ul>
      <li><code>server_seed_hash</code> — committed before the bet, returned in the pre-game response</li>
      <li><code>client_seed</code> — the seed you provided (or an auto-generated one if you didn't provide one)</li>
      <li><code>nonce</code> — a monotonically increasing integer scoped to your session</li>
    </ul>

    <p>After each completed game round, the API reveals <code>server_seed</code>. You can verify in-process using the Python code above, or make a dedicated call to the verification endpoint:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">verify_via_api.py</span>
      </div>
<span class="kw">import</span> requests

response = requests.<span class="fn">post</span>(
    <span class="st">"https://casino.purpleflea.com/v1/verify"</span>,
    headers={<span class="st">"Authorization"</span>: <span class="st">f"Bearer {API_KEY}"</span>},
    json={
        <span class="st">"server_seed"</span>: <span class="st">"&lt;revealed after round&gt;"</span>,
        <span class="st">"server_seed_hash"</span>: <span class="st">"&lt;committed before round&gt;"</span>,
        <span class="st">"client_seed"</span>: <span class="st">"my-agent-seed-abc123"</span>,
        <span class="st">"nonce"</span>: <span class="num">42</span>,
        <span class="st">"game"</span>: <span class="st">"coinflip"</span>,
    },
)

data = response.<span class="fn">json</span>()
<span class="cm"># {"verified": true, "computed_outcome": "heads", "reported_outcome": "heads"}</span>

<span class="kw">if</span> <span class="kw">not</span> data[<span class="st">"verified"</span>]:
    <span class="kw">raise</span> <span class="cls">RuntimeError</span>(<span class="st">f"Casino fraud detected: {data}"</span>)
    </div>

    <p>The server-side verification endpoint exists primarily for logging and audit trails. For security-critical agents, you should <strong>always verify locally</strong> in addition to calling the API — the whole point of provably fair is that you don't have to trust the server's verification claims either.</p>

    <h2>Conclusion</h2>

    <p>Cryptographic fairness is infrastructure — as fundamental to gambling agents as HTTPS is to web security. It's not a feature you add later. It's a correctness property that either the system has or it doesn't.</p>

    <p>If you're building a gambling agent, treat provably fair as a non-negotiable requirement when evaluating casino APIs. Ask for the HMAC construction details before integrating. Implement local verification from day one. Run the verification function on every single bet, not as a periodic audit. The code overhead is trivial. The protection it provides is not.</p>

    <p>For agents operating at scale, a casino that won't provide provably fair is not a casino you should be connecting to — regardless of how attractive the house edge looks on paper.</p>

    <hr class="article-divider">

    <!-- RELATED ARTICLES -->
    <div class="related-section">
      <h3>Related Articles</h3>
      <div class="related-grid">
        <a href="/blog/crypto-wallet-for-ai-agents/" class="related-card">
          <div class="label">Wallets</div>
          <div class="title">How to Give Your AI Agent a Crypto Wallet in 60 Seconds</div>
          <div class="desc">BIP-39 HD wallets via the Purple Flea Wallet API.</div>
        </a>
        <a href="/blog/autonomous-trading-hyperliquid/" class="related-card">
          <div class="label">Trading</div>
          <div class="title">The Complete Guide to Autonomous AI Trading</div>
          <div class="desc">Perpetual futures and position management for agents.</div>
        </a>
        <a href="/casino-api/" class="related-card">
          <div class="label">Docs</div>
          <div class="title">Provably Fair Casino API Docs</div>
          <div class="desc">Full reference for Purple Flea Casino endpoints.</div>
        </a>
      </div>
    </div>

  </div><!-- /.article-body -->
</div><!-- /.article-wrapper -->

<footer>
  <div class="container">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo">
          <div class="nav-logo-icon">&#9830;</div>
          Purple Flea
        </a>
        <p>AI-first infrastructure for autonomous agents. Built for machines, verified by math.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Products</h4>
          <ul>
            <li><a href="https://casino.purpleflea.com" target="_blank">Casino</a></li>
            <li><a href="https://trading.purpleflea.com" target="_blank">Trading</a></li>
            <li><a href="https://wallet.purpleflea.com" target="_blank">Wallet</a></li>
            <li><a href="https://domains.purpleflea.com" target="_blank">Domains</a></li>
            <li><a href="/crypto-wallet-api/">Wallet API Docs</a></li>
            <li><a href="/trading-api/">Trading API Docs</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/for-langchain/">LangChain</a></li>
            <li><a href="/for-crewai/">CrewAI</a></li>
            <li><a href="/for-claude/">Claude / MCP</a></li>
            <li><a href="/quick-start">Quick Start</a></li>
            <li><a href="/openapi">OpenAPI</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/pricing">Pricing</a></li>
            <li><a href="/stats">Stats</a></li>
            <li><a href="/changelog">Changelog</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="mailto:hello@purpleflea.com">Contact</a></li>
            <li><a href="https://github.com/Purple-flea" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://github.com/Purple-flea" target="_blank">GitHub</a>
        <a href="https://x.com/purpleflea" target="_blank">X / Twitter</a>
      </div>
    </div>
  </div>
</footer>

<script>
  const navbar = document.getElementById('navbar');
  window.addEventListener('scroll', () => {
    navbar.classList.toggle('scrolled', window.scrollY > 20);
  });
</script>

</body>
</html>
