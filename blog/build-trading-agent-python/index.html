<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Build a Crypto Trading Agent in Python â€” Step by Step | Purple Flea Blog</title>
<meta name="description" content="Complete tutorial: build an autonomous crypto trading agent in Python using the Purple Flea Trading API. Covers market data, order execution, position management, and risk controls.">
<link rel="canonical" href="https://purpleflea.com/blog/build-trading-agent-python/">
<meta property="og:title" content="Build a Crypto Trading Agent in Python â€” Step by Step | Purple Flea Blog">
<meta property="og:description" content="Complete tutorial: build an autonomous crypto trading agent in Python using the Purple Flea Trading API. Covers market data, order execution, position management, and risk controls.">
<meta property="og:url" content="https://purpleflea.com/blog/build-trading-agent-python/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="Build a Crypto Trading Agent in Python â€” Step by Step">
<meta name="twitter:description" content="Complete tutorial: build an autonomous crypto trading agent in Python using the Purple Flea Trading API.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Build a Crypto Trading Agent in Python â€” Step by Step",
  "description": "Complete tutorial: build an autonomous crypto trading agent in Python using the Purple Flea Trading API.",
  "datePublished": "2026-02-20",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" },
  "url": "https://purpleflea.com/blog/build-trading-agent-python/"
}
</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŸ£</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7;
  --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B;
  --bg-card: rgba(255, 255, 255, 0.03);
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(168, 85, 247, 0.3);
  --text: #FAFAFA;
  --text-secondary: #A1A1AA;
  --text-muted: #71717A;
  --radius: 16px;
  --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168, 85, 247, 0.3); border-radius: 3px; }
::selection { background: rgba(168, 85, 247, 0.4); color: white; }
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9, 9, 11, 0.8); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* ARTICLE LAYOUT */
.article-wrapper { max-width: 720px; margin: 0 auto; padding: 120px 24px 80px; }

/* BREADCRUMB */
.breadcrumb { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-muted); margin-bottom: 32px; }
.breadcrumb a { color: var(--text-muted); text-decoration: none; transition: color 0.2s; }
.breadcrumb a:hover { color: var(--purple); }
.breadcrumb-sep { color: var(--border-hover); }

/* ARTICLE META */
.article-meta { display: flex; align-items: center; gap: 16px; margin-bottom: 28px; flex-wrap: wrap; }
.tag-chip { display: inline-block; padding: 4px 12px; border-radius: 100px; font-size: 11px; font-weight: 600; letter-spacing: 0.05em; text-transform: uppercase; }
.tag-trading { background: rgba(34,197,94,0.12); color: #22C55E; border: 1px solid rgba(34,197,94,0.2); }
.tag-langchain { background: rgba(251,146,60,0.12); color: #FB923C; border: 1px solid rgba(251,146,60,0.2); }
.tag-claude { background: rgba(168,85,247,0.12); color: var(--purple); border: 1px solid rgba(168,85,247,0.2); }
.article-date { font-size: 13px; color: var(--text-muted); }
.article-read-time { font-size: 13px; color: var(--text-muted); }
.meta-dot { width: 3px; height: 3px; background: var(--text-muted); border-radius: 50%; }

/* ARTICLE TYPOGRAPHY */
.article-title { font-size: clamp(1.9rem, 4vw, 2.8rem); font-weight: 800; letter-spacing: -0.03em; line-height: 1.1; margin-bottom: 40px; }
.article-body { font-size: 1.05rem; line-height: 1.8; color: var(--text-secondary); }
.article-body p { margin-bottom: 1.4em; }
.article-body h2 { font-size: 1.5rem; font-weight: 700; color: var(--text); letter-spacing: -0.02em; margin: 2.4em 0 0.8em; line-height: 1.25; }
.article-body h3 { font-size: 1.15rem; font-weight: 600; color: var(--text); letter-spacing: -0.01em; margin: 1.8em 0 0.6em; }
.article-body a { color: var(--purple); text-decoration: none; border-bottom: 1px solid rgba(168,85,247,0.3); transition: border-color 0.2s; }
.article-body a:hover { border-color: var(--purple); }
.article-body ul, .article-body ol { padding-left: 1.4em; margin-bottom: 1.4em; }
.article-body li { margin-bottom: 0.5em; }
.article-body strong { color: var(--text); font-weight: 600; }
.article-body code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: rgba(168,85,247,0.1); color: var(--purple); padding: 2px 7px; border-radius: 4px; }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.7; overflow-x: auto; position: relative; margin: 1.8em 0; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }

/* CALLOUT */
.callout { background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.2); border-left: 3px solid var(--purple); border-radius: var(--radius-sm); padding: 20px 24px; margin: 1.8em 0; }
.callout p { margin: 0; color: var(--text-secondary); font-size: 0.95rem; }
.callout strong { color: var(--purple); }

/* ARTICLE DIVIDER */
.article-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 2.5em 0; }

/* RELATED */
.related-section { margin-top: 3em; padding-top: 2.5em; border-top: 1px solid var(--border); }
.related-section h3 { font-size: 12px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 20px; }
.related-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
@media (max-width: 600px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; line-height: 1.35; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }
</style>
</head>
<body>

<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &rarr;</a></li>
    </ul>
  </div>
</nav>

<div class="article-wrapper">

  <!-- BREADCRUMB -->
  <nav class="breadcrumb" aria-label="Breadcrumb">
    <a href="/blog/">Blog</a>
    <span class="breadcrumb-sep">/</span>
    <span>Trading</span>
  </nav>

  <!-- META -->
  <div class="article-meta">
    <span class="tag-chip tag-trading">Trading</span>
    <div class="meta-dot"></div>
    <span class="article-date">Feb 20, 2026</span>
    <div class="meta-dot"></div>
    <span class="article-read-time">10 min read</span>
  </div>

  <!-- TITLE -->
  <h1 class="article-title">Build a Crypto Trading Agent in Python â€” Step by Step</h1>

  <!-- BODY -->
  <div class="article-body">

    <h2>Introduction</h2>

    <p>Markets never sleep. Bitcoin trades at 3 a.m. on a Tuesday, ETH perpetuals gap up on a Sunday morning, and macro events hit without warning at any hour. Human traders can't maintain 24/7 vigilance â€” but software can. A trading agent runs indefinitely, reacting to signals in seconds, executing orders with zero hesitation, and logging every decision without fatigue or emotion clouding the process.</p>

    <p>Beyond the obvious uptime advantage, algorithmic agents enforce consistency. A human trader might override their own stop-loss in a moment of hope; an agent won't. The rules you write are the rules that run â€” every time, without exception. That discipline is worth more than any edge a discretionary trader thinks they have.</p>

    <p>This tutorial builds a fully autonomous EMA crossover trading agent from scratch using Python and the <a href="/trading-api/">Purple Flea Trading API</a>. By the end you'll have a working agent that monitors BTC-PERP, identifies trend signals, manages a leveraged position, and enforces hard risk limits â€” all without touching a UI.</p>

    <h2>What We're Building</h2>

    <p>The agent we're building does the following on a one-minute loop:</p>

    <ul>
      <li>Fetches the last 100 one-minute candles for <strong>BTC-PERP</strong> from the Purple Flea Trading API</li>
      <li>Calculates a fast <strong>EMA-20</strong> and a slow <strong>EMA-50</strong> over closing prices</li>
      <li>Opens a <strong>long position</strong> when EMA-20 crosses above EMA-50 (golden cross)</li>
      <li>Opens a <strong>short position</strong> when EMA-20 crosses below EMA-50 (death cross)</li>
      <li>Applies <strong>5x leverage</strong> with a hard <strong>2% stop-loss</strong> on each position</li>
      <li>Closes any open position when the reverse signal fires</li>
      <li>Enforces a daily loss limit and a maximum drawdown halt</li>
    </ul>

    <p>EMA crossover is deliberately simple â€” it's not the point. The point is the scaffolding: authenticated API calls, clean position management, layered risk controls, and a resilient main loop you can drop any strategy into.</p>

    <h2>Prerequisites</h2>

    <p>You'll need Python 3.9 or later, a Purple Flea API key (register free at <a href="https://wallet.purpleflea.com" target="_blank">wallet.purpleflea.com</a>), and the following packages:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">terminal</span>
      </div>
pip install purpleflea pandas numpy
    </div>

    <p>Set your API key as an environment variable before running anything:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">.env</span>
      </div>
PURPLEFLEA_API_KEY=pf_sk_your_key_here
    </div>

    <h2>Step 1: Setup and Authentication</h2>

    <p>Start by initializing the Purple Flea client and confirming connectivity. A failed health check at startup is far better than a silent failure during a live trade.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">import</span> os
<span class="kw">import</span> time
<span class="kw">import</span> logging
<span class="kw">import</span> requests

API_KEY = os.environ[<span class="st">"PURPLEFLEA_API_KEY"</span>]
BASE_URL = <span class="st">"https://api.purpleflea.com"</span>
HEADERS = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {API_KEY}"</span>, <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>}

<span class="kw">def</span> <span class="fn">check_health</span>():
    r = requests.get(<span class="st">f"{BASE_URL}/health"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    r.raise_for_status()
    data = r.json()
    <span class="kw">assert</span> data[<span class="st">"status"</span>] == <span class="st">"ok"</span>, <span class="st">f"Unhealthy API: {data}"</span>
    logging.info(<span class="st">"API health check passed. Latency: %sms"</span>, data.get(<span class="st">"latency_ms"</span>))

check_health()
    </div>

    <p>If <code>check_health()</code> raises, your API key is wrong, the network is down, or the service is degraded. Fix it before going further â€” never skip this step before starting a live loop.</p>

    <h2>Step 2: Fetch Market Data</h2>

    <p>The <code>GET /trading/candles</code> endpoint returns OHLCV data for any of the 275 perpetual markets. We'll request 100 one-minute candles â€” enough history for a stable EMA-50.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">import</span> pandas <span class="kw">as</span> pd

<span class="kw">def</span> <span class="fn">get_price_history</span>(symbol: str, periods: int = <span class="num">100</span>) -> pd.Series:
    <span class="st">"""Return closing prices as a pandas Series, newest last."""</span>
    r = requests.get(
        <span class="st">f"{BASE_URL}/trading/candles"</span>,
        headers=HEADERS,
        params={
            <span class="st">"symbol"</span>: symbol,
            <span class="st">"interval"</span>: <span class="st">"1m"</span>,
            <span class="st">"limit"</span>: periods,
        },
        timeout=<span class="num">10</span>,
    )
    r.raise_for_status()
    candles = r.json()[<span class="st">"candles"</span>]
    closes = [<span class="fn">float</span>(c[<span class="st">"close"</span>]) <span class="kw">for</span> c <span class="kw">in</span> candles]
    <span class="kw">return</span> pd.Series(closes)
    </div>

    <h2>Step 3: Calculate EMAs</h2>

    <p>Pandas makes EMA calculation a one-liner. We compute both the fast (20-period) and slow (50-period) exponential moving averages and return only the most recent value of each, since that's all the signal logic needs.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">def</span> <span class="fn">calculate_emas</span>(prices: pd.Series) -> tuple[<span class="fn">float</span>, <span class="fn">float</span>]:
    <span class="st">"""Return (ema_fast, ema_slow) â€” most recent values only."""</span>
    ema_fast = prices.ewm(span=<span class="num">20</span>, adjust=<span class="kw">False</span>).mean().iloc[-<span class="num">1</span>]
    ema_slow = prices.ewm(span=<span class="num">50</span>, adjust=<span class="kw">False</span>).mean().iloc[-<span class="num">1</span>]
    <span class="kw">return</span> <span class="fn">float</span>(ema_fast), <span class="fn">float</span>(ema_slow)

<span class="kw">def</span> <span class="fn">calculate_previous_emas</span>(prices: pd.Series) -> tuple[<span class="fn">float</span>, <span class="fn">float</span>]:
    <span class="st">"""Return EMAs from one bar ago â€” needed to detect the crossover."""</span>
    ema_fast = prices.ewm(span=<span class="num">20</span>, adjust=<span class="kw">False</span>).mean().iloc[-<span class="num">2</span>]
    ema_slow = prices.ewm(span=<span class="num">50</span>, adjust=<span class="kw">False</span>).mean().iloc[-<span class="num">2</span>]
    <span class="kw">return</span> <span class="fn">float</span>(ema_fast), <span class="fn">float</span>(ema_slow)
    </div>

    <h2>Step 4: Signal Logic</h2>

    <p>A crossover signal requires comparing the current bar's EMA relationship against the previous bar's relationship. If EMA-20 was below EMA-50 one bar ago and is above EMA-50 now, a golden cross just occurred. The reverse is a death cross. If neither condition is true, the signal is <code>"hold"</code>.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">def</span> <span class="fn">get_signal</span>(prices: pd.Series) -> str:
    <span class="st">"""Return 'long', 'short', or 'hold'."""</span>
    fast_now, slow_now = <span class="fn">calculate_emas</span>(prices)
    fast_prev, slow_prev = <span class="fn">calculate_previous_emas</span>(prices)

    <span class="cm"># Golden cross: fast crossed above slow</span>
    <span class="kw">if</span> fast_prev &lt; slow_prev <span class="kw">and</span> fast_now &gt; slow_now:
        logging.info(<span class="st">"SIGNAL: long  (EMA20=%.2f, EMA50=%.2f)"</span>, fast_now, slow_now)
        <span class="kw">return</span> <span class="st">"long"</span>

    <span class="cm"># Death cross: fast crossed below slow</span>
    <span class="kw">if</span> fast_prev &gt; slow_prev <span class="kw">and</span> fast_now &lt; slow_now:
        logging.info(<span class="st">"SIGNAL: short (EMA20=%.2f, EMA50=%.2f)"</span>, fast_now, slow_now)
        <span class="kw">return</span> <span class="st">"short"</span>

    <span class="kw">return</span> <span class="st">"hold"</span>
    </div>

    <h2>Step 5: Position Management</h2>

    <p>The <code>PositionManager</code> class wraps the Purple Flea REST endpoints for opening and closing positions. It tracks the current position side and entry price so the rest of the agent can query state without extra API calls.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">class</span> <span class="cls">PositionManager</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(<span class="kw">self</span>, symbol: str, leverage: int = <span class="num">5</span>):
        <span class="kw">self</span>.symbol = symbol
        <span class="kw">self</span>.leverage = leverage
        <span class="kw">self</span>.current_side = <span class="kw">None</span>   <span class="cm"># "long" | "short" | None</span>
        <span class="kw">self</span>.entry_price = <span class="kw">None</span>
        <span class="kw">self</span>.position_id = <span class="kw">None</span>

    <span class="kw">def</span> <span class="fn">open_long</span>(<span class="kw">self</span>, size_usd: <span class="fn">float</span>):
        <span class="kw">return self</span>.<span class="fn">_open</span>(<span class="st">"long"</span>, size_usd)

    <span class="kw">def</span> <span class="fn">open_short</span>(<span class="kw">self</span>, size_usd: <span class="fn">float</span>):
        <span class="kw">return self</span>.<span class="fn">_open</span>(<span class="st">"short"</span>, size_usd)

    <span class="kw">def</span> <span class="fn">_open</span>(<span class="kw">self</span>, side: str, size_usd: <span class="fn">float</span>):
        r = requests.post(
            <span class="st">f"{BASE_URL}/trading/positions"</span>,
            headers=HEADERS,
            json={
                <span class="st">"symbol"</span>: <span class="kw">self</span>.symbol,
                <span class="st">"side"</span>: side,
                <span class="st">"size_usd"</span>: size_usd,
                <span class="st">"leverage"</span>: <span class="kw">self</span>.leverage,
                <span class="st">"order_type"</span>: <span class="st">"market"</span>,
            },
            timeout=<span class="num">15</span>,
        )
        r.raise_for_status()
        result = r.json()
        <span class="kw">self</span>.current_side = side
        <span class="kw">self</span>.entry_price = <span class="fn">float</span>(result[<span class="st">"fill_price"</span>])
        <span class="kw">self</span>.position_id = result[<span class="st">"position_id"</span>]
        logging.info(<span class="st">"Opened %s at %.2f (id=%s)"</span>, side, <span class="kw">self</span>.entry_price, <span class="kw">self</span>.position_id)
        <span class="kw">return</span> result

    <span class="kw">def</span> <span class="fn">close_position</span>(<span class="kw">self</span>):
        <span class="kw">if not self</span>.position_id:
            <span class="kw">return</span>
        r = requests.delete(
            <span class="st">f"{BASE_URL}/trading/positions/{self.position_id}"</span>,
            headers=HEADERS,
            timeout=<span class="num">15</span>,
        )
        r.raise_for_status()
        logging.info(<span class="st">"Closed position %s"</span>, <span class="kw">self</span>.position_id)
        <span class="kw">self</span>.current_side = <span class="kw">None</span>
        <span class="kw">self</span>.entry_price = <span class="kw">None</span>
        <span class="kw">self</span>.position_id = <span class="kw">None</span>
    </div>

    <h2>Step 6: Risk Controls</h2>

    <p>Risk management is not optional. Without it, a single bad trade or API anomaly can wipe the account. The <code>RiskGuard</code> class enforces four independent safeguards that run before every order.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">class</span> <span class="cls">RiskGuard</span>:
    MAX_POSITION_PCT  = <span class="num">0.02</span>   <span class="cm"># 2% of portfolio per trade</span>
    STOP_LOSS_PCT     = <span class="num">0.02</span>   <span class="cm"># exit if unrealised loss exceeds 2%</span>
    MAX_DRAWDOWN_PCT  = <span class="num">0.20</span>   <span class="cm"># halt all trading if portfolio down 20%</span>
    DAILY_LOSS_LIMIT  = <span class="num">0.05</span>   <span class="cm"># halt if daily P&L down 5%</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(<span class="kw">self</span>, starting_equity: <span class="fn">float</span>):
        <span class="kw">self</span>.starting_equity = starting_equity
        <span class="kw">self</span>.peak_equity = starting_equity
        <span class="kw">self</span>.daily_start_equity = starting_equity
        <span class="kw">self</span>.halted = <span class="kw">False</span>

    <span class="kw">def</span> <span class="fn">position_size_usd</span>(<span class="kw">self</span>, equity: <span class="fn">float</span>) -> <span class="fn">float</span>:
        <span class="st">"""Return maximum order size in USD."""</span>
        <span class="kw">return</span> equity * <span class="kw">self</span>.MAX_POSITION_PCT

    <span class="kw">def</span> <span class="fn">check_stop_loss</span>(<span class="kw">self</span>, entry: <span class="fn">float</span>, current: <span class="fn">float</span>, side: str) -> bool:
        <span class="st">"""Return True if stop-loss should trigger."""</span>
        <span class="kw">if</span> side == <span class="st">"long"</span>:
            <span class="kw">return</span> (entry - current) / entry >= <span class="kw">self</span>.STOP_LOSS_PCT
        <span class="kw">else</span>:
            <span class="kw">return</span> (current - entry) / entry >= <span class="kw">self</span>.STOP_LOSS_PCT

    <span class="kw">def</span> <span class="fn">update_and_check</span>(<span class="kw">self</span>, current_equity: <span class="fn">float</span>) -> bool:
        <span class="st">"""Update equity state. Return True if trading should halt."""</span>
        <span class="kw">if self</span>.halted:
            <span class="kw">return True</span>
        <span class="kw">self</span>.peak_equity = <span class="fn">max</span>(<span class="kw">self</span>.peak_equity, current_equity)
        drawdown = (<span class="kw">self</span>.peak_equity - current_equity) / <span class="kw">self</span>.peak_equity
        daily_loss = (<span class="kw">self</span>.daily_start_equity - current_equity) / <span class="kw">self</span>.daily_start_equity
        <span class="kw">if</span> drawdown >= <span class="kw">self</span>.MAX_DRAWDOWN_PCT <span class="kw">or</span> daily_loss >= <span class="kw">self</span>.DAILY_LOSS_LIMIT:
            logging.critical(<span class="st">"RISK HALT: drawdown=%.1f%% daily_loss=%.1f%%"</span>,
                             drawdown * <span class="num">100</span>, daily_loss * <span class="num">100</span>)
            <span class="kw">self</span>.halted = <span class="kw">True</span>
            <span class="kw">return True</span>
        <span class="kw">return False</span>
    </div>

    <div class="callout">
      <p><strong>Leverage warning:</strong> This agent uses 5x leverage. A 20% adverse move against a 5x position results in a 100% loss of margin. Always test with minimal size and paper-trade before deploying real capital. Never risk more than you can afford to lose.</p>
    </div>

    <h2>Step 7: The Main Loop</h2>

    <p>The main loop ties everything together. It runs every 60 seconds: fetch prices, compute signal, consult risk guard, execute if appropriate, then sleep. Any exception is caught and logged â€” the loop continues rather than crashing.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">agent.py</span>
      </div>
<span class="kw">import</span> asyncio

SYMBOL = <span class="st">"BTC-PERP"</span>
LOOP_INTERVAL = <span class="num">60</span>  <span class="cm"># seconds</span>

<span class="kw">async def</span> <span class="fn">main</span>():
    logging.<span class="fn">basicConfig</span>(level=logging.INFO,
                        format=<span class="st">"%(asctime)s %(levelname)s %(message)s"</span>)
    <span class="fn">check_health</span>()

    pm = <span class="cls">PositionManager</span>(SYMBOL, leverage=<span class="num">5</span>)

    <span class="cm"># Fetch starting equity from wallet</span>
    equity_resp = requests.get(<span class="st">f"{BASE_URL}/wallet/balance"</span>, headers=HEADERS)
    equity = <span class="fn">float</span>(equity_resp.json()[<span class="st">"total_usd"</span>])
    rg = <span class="cls">RiskGuard</span>(starting_equity=equity)

    logging.info(<span class="st">"Agent started. Symbol=%s Equity=%.2f"</span>, SYMBOL, equity)

    <span class="kw">while True</span>:
        <span class="kw">try</span>:
            <span class="cm"># 1. Refresh equity</span>
            equity_resp = requests.get(<span class="st">f"{BASE_URL}/wallet/balance"</span>, headers=HEADERS)
            equity = <span class="fn">float</span>(equity_resp.json()[<span class="st">"total_usd"</span>])

            <span class="cm"># 2. Check drawdown / daily loss halt</span>
            <span class="kw">if</span> rg.<span class="fn">update_and_check</span>(equity):
                logging.warning(<span class="st">"Trading halted by RiskGuard. Closing any open position."</span>)
                pm.<span class="fn">close_position</span>()
                <span class="kw">break</span>

            <span class="cm"># 3. Check stop-loss on open position</span>
            <span class="kw">if</span> pm.current_side <span class="kw">and</span> pm.entry_price:
                prices = <span class="fn">get_price_history</span>(SYMBOL, <span class="num">1</span>)
                current_price = prices.iloc[-<span class="num">1</span>]
                <span class="kw">if</span> rg.<span class="fn">check_stop_loss</span>(pm.entry_price, current_price, pm.current_side):
                    logging.warning(<span class="st">"Stop-loss triggered at %.2f"</span>, current_price)
                    pm.<span class="fn">close_position</span>()

            <span class="cm"># 4. Compute signal</span>
            prices = <span class="fn">get_price_history</span>(SYMBOL, <span class="num">100</span>)
            signal = <span class="fn">get_signal</span>(prices)

            <span class="cm"># 5. Execute</span>
            <span class="kw">if</span> signal == <span class="st">"long"</span> <span class="kw">and</span> pm.current_side != <span class="st">"long"</span>:
                pm.<span class="fn">close_position</span>()
                pm.<span class="fn">open_long</span>(rg.<span class="fn">position_size_usd</span>(equity))
            <span class="kw">elif</span> signal == <span class="st">"short"</span> <span class="kw">and</span> pm.current_side != <span class="st">"short"</span>:
                pm.<span class="fn">close_position</span>()
                pm.<span class="fn">open_short</span>(rg.<span class="fn">position_size_usd</span>(equity))

        <span class="kw">except Exception as</span> e:
            logging.error(<span class="st">"Loop error: %s"</span>, e, exc_info=<span class="kw">True</span>)

        <span class="kw">await</span> asyncio.<span class="fn">sleep</span>(LOOP_INTERVAL)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    asyncio.<span class="fn">run</span>(<span class="fn">main</span>())
    </div>

    <h2>Step 8: Logging and Monitoring</h2>

    <p>Structured JSON logging makes it trivial to pipe output into log aggregators like Datadog, Loki, or CloudWatch. Add a webhook notification whenever a fill occurs so you're alerted on your phone even when the agent is running unattended.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">logging_setup.py</span>
      </div>
<span class="kw">import</span> json, logging, os
<span class="kw">from</span> datetime <span class="kw">import</span> datetime, timezone

<span class="kw">class</span> <span class="cls">JsonFormatter</span>(logging.Formatter):
    <span class="kw">def</span> <span class="fn">format</span>(<span class="kw">self</span>, record):
        payload = {
            <span class="st">"ts"</span>: datetime.<span class="fn">now</span>(timezone.utc).<span class="fn">isoformat</span>(),
            <span class="st">"level"</span>: record.levelname,
            <span class="st">"msg"</span>: record.getMessage(),
        }
        <span class="kw">return</span> json.<span class="fn">dumps</span>(payload)

<span class="kw">def</span> <span class="fn">setup_logging</span>(log_file: str = <span class="st">"agent.log"</span>):
    handler = logging.<span class="fn">FileHandler</span>(log_file)
    handler.<span class="fn">setFormatter</span>(<span class="cls">JsonFormatter</span>())
    logging.getLogger().<span class="fn">addHandler</span>(handler)
    logging.getLogger().<span class="fn">setLevel</span>(logging.INFO)

WEBHOOK_URL = os.environ.<span class="fn">get</span>(<span class="st">"ALERT_WEBHOOK_URL"</span>)

<span class="kw">def</span> <span class="fn">notify_fill</span>(side: str, price: <span class="fn">float</span>, size_usd: <span class="fn">float</span>):
    <span class="kw">if not</span> WEBHOOK_URL:
        <span class="kw">return</span>
    <span class="kw">import</span> requests
    requests.post(WEBHOOK_URL, json={
        <span class="st">"text"</span>: <span class="st">f"Fill: {side.upper()} ${size_usd:.0f} @ ${price:,.2f}"</span>
    }, timeout=<span class="num">5</span>)
    </div>

    <h2>Deployment</h2>

    <p>For production deployment, run the agent as a managed process with PM2 or systemd so it restarts automatically on crash or reboot.</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">ecosystem.config.cjs</span>
      </div>
module.exports = {
  apps: [{
    name: <span class="st">"trading-agent"</span>,
    script: <span class="st">"python"</span>,
    args: <span class="st">"agent.py"</span>,
    autorestart: <span class="kw">true</span>,
    watch: <span class="kw">false</span>,
    env: {
      PURPLEFLEA_API_KEY: process.env.PURPLEFLEA_API_KEY,
      ALERT_WEBHOOK_URL: process.env.ALERT_WEBHOOK_URL,
    }
  }]
}
    </div>

    <p>Start with <code>pm2 start ecosystem.config.cjs</code> and monitor with <code>pm2 logs trading-agent</code>. You can also poll open positions directly via <code>GET /trading/positions</code> to confirm the agent's state from any HTTP client.</p>

    <h2>Results and Backtesting</h2>

    <p>Before running this agent with real funds, backtest it against historical data. Past performance is never indicative of future results, but backtesting will reveal edge cases in your signal logic, help you calibrate position sizes, and expose bugs in the risk guard that you don't want to find live.</p>

    <p>Purple Flea provides historical candle data via the same endpoint with a historical flag:</p>

    <div class="code-block">
      <div class="code-header">
        <div class="code-dot red"></div>
        <div class="code-dot yellow"></div>
        <div class="code-dot green"></div>
        <span class="code-filename">backtest.py</span>
      </div>
r = requests.get(
    <span class="st">f"{BASE_URL}/trading/candles"</span>,
    headers=HEADERS,
    params={
        <span class="st">"symbol"</span>: <span class="st">"BTC-PERP"</span>,
        <span class="st">"interval"</span>: <span class="st">"1m"</span>,
        <span class="st">"limit"</span>: <span class="num">10000</span>,
        <span class="st">"historical"</span>: <span class="st">"true"</span>,
        <span class="st">"start"</span>: <span class="st">"2026-01-01T00:00:00Z"</span>,
    }
)
historical_candles = r.json()[<span class="st">"candles"</span>]
    </div>

    <p>Run your signal logic over the historical candles in a simulation loop. Track each hypothetical trade's entry/exit price, P&amp;L, and drawdown. Only deploy live when the strategy shows a positive expectation across at least 200 trades in the backtest.</p>

    <h2>Conclusion</h2>

    <p>You've built a complete end-to-end autonomous trading agent: authenticated API connectivity, real-time market data, EMA crossover signal logic, 5x leveraged position management, and four independent risk controls â€” all wrapped in a resilient 60-second async loop with structured logging and webhook alerting.</p>

    <p>The architecture is strategy-agnostic. Swap out the EMA logic for RSI divergence, funding rate arbitrage, order book imbalance, or an LLM-generated signal â€” the position management and risk layers stay exactly the same. That separation of concerns is what makes the agent maintainable as complexity grows.</p>

    <p>The full <a href="/trading-api/">Trading API reference</a> documents every available endpoint including limit orders, take-profit targets, and funding rate queries. Ready to start? <a href="https://wallet.purpleflea.com" target="_blank">Register your account</a> and get your API key in under a minute.</p>

    <hr class="article-divider">

    <!-- RELATED ARTICLES -->
    <div class="related-section">
      <h3>Related</h3>
      <div class="related-grid">
        <a href="/blog/autonomous-trading-hyperliquid/" class="related-card">
          <div class="label">Trading</div>
          <div class="title">Autonomous AI Trading on Hyperliquid</div>
          <div class="desc">Complete guide to live-trading agents on 275 perpetual markets.</div>
        </a>
        <a href="/trading-api/" class="related-card">
          <div class="label">Docs</div>
          <div class="title">Trading API Reference</div>
          <div class="desc">Full endpoint documentation for perpetual futures trading.</div>
        </a>
        <a href="/kelly-criterion-ai-trading/" class="related-card">
          <div class="label">Strategy</div>
          <div class="title">Kelly Criterion for AI Trading Agents</div>
          <div class="desc">Optimal position sizing using the Kelly formula in Python.</div>
        </a>
      </div>
    </div>

  </div>
</div>

<footer>
  <div class="container">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo">
          <div class="nav-logo-icon">&#9830;</div>
          Purple Flea
        </a>
        <p>AI-first infrastructure for autonomous agents. Built for machines, verified by math.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Products</h4>
          <ul>
            <li><a href="https://casino.purpleflea.com" target="_blank">Casino</a></li>
            <li><a href="https://trading.purpleflea.com" target="_blank">Trading</a></li>
            <li><a href="https://wallet.purpleflea.com" target="_blank">Wallet</a></li>
            <li><a href="https://domains.purpleflea.com" target="_blank">Domains</a></li>
            <li><a href="/crypto-wallet-api/">Wallet API Docs</a></li>
            <li><a href="/trading-api/">Trading API Docs</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/for-langchain/">LangChain</a></li>
            <li><a href="/for-crewai/">CrewAI</a></li>
            <li><a href="/for-claude/">Claude / MCP</a></li>
            <li><a href="/quick-start">Quick Start</a></li>
            <li><a href="/openapi">OpenAPI</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/pricing">Pricing</a></li>
            <li><a href="/stats">Stats</a></li>
            <li><a href="/changelog">Changelog</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="mailto:hello@purpleflea.com">Contact</a></li>
            <li><a href="https://github.com/Purple-flea" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://github.com/Purple-flea" target="_blank">GitHub</a>
        <a href="https://x.com/purpleflea" target="_blank">X / Twitter</a>
      </div>
    </div>
  </div>
</footer>

<script>
const navbar = document.getElementById('navbar');
window.addEventListener('scroll', () => { navbar.classList.toggle('scrolled', window.scrollY > 50); });
</script>
</body>
</html>
