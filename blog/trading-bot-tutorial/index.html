<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Build a Crypto Trading Bot with Python and Purple Flea in 15 Minutes | Purple Flea Blog</title>
<meta name="description" content="Step-by-step tutorial: build a fully functional crypto trading bot in Python using the Purple Flea Trading API. Open positions, monitor PnL, apply risk management, and deploy 24/7 with pm2.">
<link rel="canonical" href="https://purpleflea.com/blog/trading-bot-tutorial">
<meta property="og:title" content="Build a Crypto Trading Bot with Python and Purple Flea in 15 Minutes | Purple Flea Blog">
<meta property="og:description" content="Step-by-step tutorial: build a fully functional crypto trading bot in Python using the Purple Flea Trading API. Open positions, monitor PnL, apply risk management, and deploy 24/7 with pm2.">
<meta property="og:url" content="https://purpleflea.com/blog/trading-bot-tutorial">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="Build a Crypto Trading Bot with Python and Purple Flea in 15 Minutes">
<meta name="twitter:description" content="Step-by-step tutorial: build a fully functional crypto trading bot in Python using the Purple Flea Trading API.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Build a Crypto Trading Bot with Python and Purple Flea in 15 Minutes",
  "description": "Step-by-step tutorial: build a fully functional crypto trading bot in Python using the Purple Flea Trading API. Open positions, monitor PnL, apply risk management, and deploy 24/7 with pm2.",
  "datePublished": "2026-02-27",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" },
  "url": "https://purpleflea.com/blog/trading-bot-tutorial"
}
</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1F7E3;</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7;
  --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B;
  --bg-card: rgba(255, 255, 255, 0.03);
  --bg-card-hover: rgba(255, 255, 255, 0.06);
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(168, 85, 247, 0.3);
  --text: #FAFAFA;
  --text-secondary: #A1A1AA;
  --text-muted: #71717A;
  --radius: 16px;
  --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168, 85, 247, 0.3); border-radius: 3px; }
::selection { background: rgba(168, 85, 247, 0.4); color: white; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9, 9, 11, 0.85); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* PAGE LAYOUT */
.page-outer { display: grid; grid-template-columns: 1fr min(720px, 100%) 280px; gap: 0; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
@media (max-width: 1100px) { .page-outer { grid-template-columns: 1fr; } }
.article-wrapper { padding: 120px 48px 80px 0; }
@media (max-width: 1100px) { .article-wrapper { padding: 120px 0 80px; } }

/* TOC SIDEBAR */
.toc-sidebar { padding-top: 136px; }
@media (max-width: 1100px) { .toc-sidebar { display: none; } }
.toc-sticky { position: sticky; top: 100px; }
.toc-label { font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 14px; }
.toc-list { list-style: none; display: flex; flex-direction: column; gap: 2px; }
.toc-list li a { display: block; font-size: 12.5px; color: var(--text-muted); text-decoration: none; padding: 5px 10px; border-left: 2px solid var(--border); transition: all 0.2s; line-height: 1.4; }
.toc-list li a:hover { color: var(--text-secondary); border-left-color: rgba(168,85,247,0.4); }
.toc-list li a.active { color: var(--purple); border-left-color: var(--purple); }

/* BREADCRUMB */
.breadcrumb { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-muted); margin-bottom: 32px; }
.breadcrumb a { color: var(--text-muted); text-decoration: none; transition: color 0.2s; }
.breadcrumb a:hover { color: var(--purple); }
.breadcrumb-sep { color: var(--border-hover); }

/* ARTICLE META */
.article-meta { display: flex; align-items: center; gap: 16px; margin-bottom: 28px; flex-wrap: wrap; }
.tag-chip { display: inline-block; padding: 4px 12px; border-radius: 100px; font-size: 11px; font-weight: 700; letter-spacing: 0.06em; text-transform: uppercase; }
.tag-tutorial { background: rgba(168,85,247,0.12); color: var(--purple); border: 1px solid rgba(168,85,247,0.25); }
.article-date { font-size: 13px; color: var(--text-muted); }
.article-read-time { font-size: 13px; color: var(--text-muted); }
.meta-dot { width: 3px; height: 3px; background: var(--text-muted); border-radius: 50%; }

/* ARTICLE TYPOGRAPHY */
.article-title { font-size: clamp(1.8rem, 4vw, 2.75rem); font-weight: 800; letter-spacing: -0.03em; line-height: 1.1; margin-bottom: 40px; }
.article-body { font-size: 1.05rem; line-height: 1.8; color: var(--text-secondary); }
.article-body p { margin-bottom: 1.4em; }
.article-body h2 { font-size: 1.45rem; font-weight: 700; color: var(--text); letter-spacing: -0.02em; margin: 2.8em 0 0.8em; line-height: 1.25; scroll-margin-top: 100px; }
.article-body h3 { font-size: 1.1rem; font-weight: 600; color: var(--text); letter-spacing: -0.01em; margin: 1.8em 0 0.6em; scroll-margin-top: 100px; }
.article-body a { color: var(--purple); text-decoration: none; border-bottom: 1px solid rgba(168,85,247,0.3); transition: border-color 0.2s; }
.article-body a:hover { border-color: var(--purple); }
.article-body ul, .article-body ol { padding-left: 1.4em; margin-bottom: 1.4em; }
.article-body li { margin-bottom: 0.5em; }
.article-body strong { color: var(--text); font-weight: 600; }
.article-body code { font-family: 'JetBrains Mono', monospace; font-size: 0.84em; background: rgba(168,85,247,0.1); color: var(--purple); padding: 2px 7px; border-radius: 4px; }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.5); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.75; overflow-x: auto; position: relative; margin: 1.8em 0; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }
.op { color: #94A3B8; }
.bl { color: #67E8F9; }

/* STEP HEADER */
.step-header { display: flex; align-items: center; gap: 14px; margin: 2.8em 0 0.8em; scroll-margin-top: 100px; }
.step-num { width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 700; color: white; flex-shrink: 0; }
.step-header h2 { font-size: 1.45rem; font-weight: 700; color: var(--text); letter-spacing: -0.02em; line-height: 1.25; margin: 0; }

/* CALLOUT */
.callout { background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.18); border-left: 3px solid var(--purple); border-radius: var(--radius-sm); padding: 20px 24px; margin: 1.8em 0; }
.callout p { margin: 0; color: var(--text-secondary); font-size: 0.95rem; }
.callout strong { color: var(--purple); }
.callout-warning { background: rgba(251,146,60,0.06); border-color: rgba(251,146,60,0.15); border-left-color: #FB923C; }
.callout-warning p { color: var(--text-secondary); }
.callout-warning strong { color: #FB923C; }
.callout-green { background: rgba(34,197,94,0.06); border-color: rgba(34,197,94,0.15); border-left-color: #22C55E; }
.callout-green strong { color: #22C55E; }

/* ARTICLE DIVIDER */
.article-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 2.5em 0; }

/* INLINE TOC (mobile) */
.toc-inline { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 24px 28px; margin-bottom: 2.4em; }
.toc-inline .toc-label { margin-bottom: 12px; }
.toc-inline ol { padding-left: 1.2em; display: flex; flex-direction: column; gap: 6px; }
.toc-inline ol li a { font-size: 14px; color: var(--text-secondary); text-decoration: none; transition: color 0.2s; border-bottom: none; }
.toc-inline ol li a:hover { color: var(--purple); }
@media (min-width: 1101px) { .toc-inline { display: none; } }

/* RELATED */
.related-section { margin-top: 3em; padding-top: 2.5em; border-top: 1px solid var(--border); }
.related-section h3 { font-size: 12px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 20px; }
.related-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
@media (max-width: 600px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; line-height: 1.35; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-inner { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }
</style>
</head>
<body>

<!-- NAV -->
<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &rarr;</a></li>
    </ul>
  </div>
</nav>

<!-- PAGE OUTER GRID -->
<div class="page-outer">

  <!-- EMPTY LEFT COLUMN (spacer) -->
  <div></div>

  <!-- ARTICLE COLUMN -->
  <article class="article-wrapper">

    <!-- BREADCRUMB -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
      <a href="/blog/">Blog</a>
      <span class="breadcrumb-sep">/</span>
      <span>Tutorial</span>
    </nav>

    <!-- META -->
    <div class="article-meta">
      <span class="tag-chip tag-tutorial">Tutorial</span>
      <div class="meta-dot"></div>
      <span class="article-date">Feb 27, 2026</span>
      <div class="meta-dot"></div>
      <span class="article-read-time">12 min read</span>
    </div>

    <!-- TITLE -->
    <h1 class="article-title">Build a Crypto Trading Bot with Python and Purple Flea in 15 Minutes</h1>

    <!-- INLINE TOC (shown on smaller screens) -->
    <div class="toc-inline">
      <div class="toc-label">Table of Contents</div>
      <ol>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#step-1">Step 1 &mdash; Register and get your API key</a></li>
        <li><a href="#step-2">Step 2 &mdash; Explore available markets</a></li>
        <li><a href="#step-3">Step 3 &mdash; Open your first position</a></li>
        <li><a href="#step-4">Step 4 &mdash; Monitor the position</a></li>
        <li><a href="#step-5">Step 5 &mdash; Close for profit</a></li>
        <li><a href="#step-6">Step 6 &mdash; Build a momentum strategy</a></li>
        <li><a href="#step-7">Step 7 &mdash; Add risk management</a></li>
        <li><a href="#step-8">Step 8 &mdash; Deploy with pm2</a></li>
        <li><a href="#full-bot">Complete combined bot</a></li>
        <li><a href="#next-steps">What to do next</a></li>
      </ol>
    </div>

    <!-- BODY -->
    <div class="article-body">

      <!-- INTRODUCTION -->
      <h2 id="introduction">Introduction</h2>

      <p>Crypto markets operate around the clock, every day of the year. By the time you wake up, prices may have moved 5% on a single piece of macro news. Human traders are limited by biology &mdash; they need sleep, make emotional decisions, and can only watch a handful of charts at once. Automated trading bots have none of these constraints.</p>

      <p>A well-constructed trading bot does exactly what you tell it to, every time, without hesitation. It can scan dozens of markets simultaneously, respond to price movements in milliseconds, and enforce hard risk limits that a human trader might override in a moment of greed or panic. That consistency is worth more than most technical edges.</p>

      <p>Python is the ideal language for building trading bots. Its ecosystem is mature (pandas, numpy, requests), the syntax stays readable even in complex logic, and deployment is straightforward. The <a href="https://trading.purpleflea.com" target="_blank">Purple Flea Trading API</a> gives you a clean REST interface to real perpetual futures markets: open and close leveraged positions, stream live prices, and query your account state, all from a handful of HTTP calls.</p>

      <p>By the end of this tutorial you will have a fully functional bot that checks for momentum signals every minute, trades BTC, ETH, and SOL perpetuals with configurable leverage, enforces position size caps and daily loss limits, and runs unattended 24/7 on a server using pm2. Every code block is self-contained and copy-paste ready.</p>

      <!-- PREREQUISITES -->
      <h2 id="prerequisites">Prerequisites</h2>

      <p>You will need the following before we start writing code:</p>

      <ul>
        <li><strong>Python 3.8 or higher</strong> &mdash; check with <code>python3 --version</code></li>
        <li><strong>requests</strong> &mdash; the only third-party library required for the API calls</li>
        <li><strong>A basic understanding of crypto markets</strong> &mdash; you should know what a long position, leverage, and funding rate mean; no quant background required</li>
        <li><strong>A Purple Flea account</strong> &mdash; free to create, no KYC needed to start on testnet</li>
      </ul>

      <p>Install the single dependency now:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">terminal</span>
        </div>
pip install requests
      </div>

      <p>That is genuinely all you need. No heavyweight SDKs, no async frameworks. The bot we build in this tutorial makes plain HTTP requests against the Purple Flea REST API, which means you can adapt every pattern here to any language that has an HTTP client.</p>

      <div class="callout">
        <p><strong>Testnet first.</strong> Purple Flea provides a sandboxed testnet environment at <code>trading.purpleflea.com</code> with paper money. Run every step in this tutorial against testnet before committing real capital. The API endpoints and response shapes are identical between testnet and production.</p>
      </div>

      <!-- STEP 1 -->
      <div class="step-header" id="step-1">
        <div class="step-num">1</div>
        <h2>Register and get your API key</h2>
      </div>

      <p>The Purple Flea Trading API uses bearer token authentication. Every request must include your API key in the <code>Authorization</code> header. You obtain a key by posting your email to the registration endpoint &mdash; no password required at this stage, the key itself is your credential.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">register.py</span>
        </div>
<span class="kw">import</span> requests

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>

<span class="cm"># POST your email to create an account and receive an API key</span>
resp = requests.<span class="fn">post</span>(
    <span class="st">f"{BASE_URL}/v1/auth/register"</span>,
    json={<span class="st">"email"</span>: <span class="st">"you@example.com"</span>},
    timeout=<span class="num">10</span>,
)
resp.raise_for_status()

data = resp.json()
api_key = data[<span class="st">"api_key"</span>]
<span class="fn">print</span>(<span class="st">f"Your API key: {api_key}"</span>)

<span class="cm"># Store it safely &mdash; treat this like a password</span>
<span class="cm"># Add to your shell profile or a .env file:</span>
<span class="cm"># export PURPLEFLEA_API_KEY="pf_sk_..."</span>
      </div>

      <p>The response JSON contains a single field: <code>api_key</code>. Copy it and store it as an environment variable. Never hardcode it in source files or commit it to version control.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">.env</span>
        </div>
PURPLEFLEA_API_KEY=pf_sk_your_key_here
      </div>

      <p>All subsequent examples read the key from the environment. Build the shared headers object once and reuse it everywhere:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">bot.py</span>
        </div>
<span class="kw">import</span> os
<span class="kw">import</span> requests

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
API_KEY  = os.environ[<span class="st">"PURPLEFLEA_API_KEY"</span>]

HEADERS = {
    <span class="st">"Authorization"</span>: <span class="st">f"Bearer {API_KEY}"</span>,
    <span class="st">"Content-Type"</span>:  <span class="st">"application/json"</span>,
}

<span class="cm"># Quick connectivity check &mdash; raises immediately if credentials are wrong</span>
<span class="kw">def</span> <span class="fn">ping</span>():
    r = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/markets"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    r.raise_for_status()
    <span class="fn">print</span>(<span class="st">"Connected. Markets available:"</span>, <span class="fn">len</span>(r.json()))

<span class="fn">ping</span>()
      </div>

      <!-- STEP 2 -->
      <div class="step-header" id="step-2">
        <div class="step-num">2</div>
        <h2>Explore available markets</h2>
      </div>

      <p>Before placing any orders you need to know what instruments are available, what their current prices are, and what funding rates you are paying to hold open positions. <code>GET /v1/markets</code> returns all of this in one call.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">explore_markets.py</span>
        </div>
<span class="kw">import</span> requests, os

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
HEADERS  = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {os.environ['PURPLEFLEA_API_KEY']}"</span>}

resp = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/markets"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
resp.raise_for_status()
markets = resp.json()

<span class="cm"># Each market object looks like:</span>
<span class="cm"># {</span>
<span class="cm">#   "coin": "BTC",</span>
<span class="cm">#   "mark_price": 67432.10,</span>
<span class="cm">#   "funding_rate": 0.0001   # per 8h, annualised ~10.95%</span>
<span class="cm"># }</span>

<span class="cm"># Print BTC, ETH, SOL specifically</span>
target_coins = {<span class="st">"BTC"</span>, <span class="st">"ETH"</span>, <span class="st">"SOL"</span>}
<span class="kw">for</span> m <span class="kw">in</span> markets:
    <span class="kw">if</span> m[<span class="st">"coin"</span>] <span class="kw">in</span> target_coins:
        funding_pct = m[<span class="st">"funding_rate"</span>] * <span class="num">100</span>
        <span class="fn">print</span>(
            <span class="st">f"{m['coin']:&lt;6} mark={m['mark_price']:>12,.2f}  "</span>
            <span class="st">f"funding={funding_pct:+.4f}% / 8h"</span>
        )
      </div>

      <p>Sample output:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">output</span>
        </div>
BTC    mark=   67,432.10  funding=+0.0100% / 8h
ETH    mark=    3,521.44  funding=+0.0083% / 8h
SOL    mark=      187.92  funding=+0.0061% / 8h
      </div>

      <p>Funding rate is the periodic payment exchanged between long and short holders. A positive rate means longs pay shorts &mdash; the market is leaning long. If you plan to hold a position for days, funding costs will eat into your PnL. Always factor it in when sizing trades.</p>

      <p>Cache the market data in your bot and refresh it every few minutes rather than on every signal check &mdash; it reduces latency and avoids rate limits:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">bot.py</span>
        </div>
<span class="kw">import</span> time

_markets_cache = {}
_markets_ts    = <span class="num">0</span>
CACHE_TTL      = <span class="num">120</span>  <span class="cm"># seconds</span>

<span class="kw">def</span> <span class="fn">get_markets</span>():
    <span class="kw">global</span> _markets_cache, _markets_ts
    <span class="kw">if</span> time.<span class="fn">time</span>() - _markets_ts &lt; CACHE_TTL:
        <span class="kw">return</span> _markets_cache
    resp = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/markets"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    resp.raise_for_status()
    _markets_cache = {m[<span class="st">"coin"</span>]: m <span class="kw">for</span> m <span class="kw">in</span> resp.json()}
    _markets_ts    = time.<span class="fn">time</span>()
    <span class="kw">return</span> _markets_cache

<span class="kw">def</span> <span class="fn">get_mark_price</span>(coin: <span class="bl">str</span>) -> <span class="bl">float</span>:
    <span class="kw">return</span> <span class="fn">get_markets</span>()[coin][<span class="st">"mark_price"</span>]
      </div>

      <!-- STEP 3 -->
      <div class="step-header" id="step-3">
        <div class="step-num">3</div>
        <h2>Open your first position</h2>
      </div>

      <p>With markets confirmed, open a BTC long. You specify the coin, direction, notional size in USD, and leverage multiplier. The API returns a position ID and the entry price at which you were filled.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">open_position.py</span>
        </div>
<span class="kw">import</span> requests, os

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
HEADERS  = {
    <span class="st">"Authorization"</span>: <span class="st">f"Bearer {os.environ['PURPLEFLEA_API_KEY']}"</span>,
    <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>,
}

resp = requests.<span class="fn">post</span>(
    <span class="st">f"{BASE_URL}/v1/trade/open"</span>,
    headers=HEADERS,
    json={
        <span class="st">"coin"</span>:     <span class="st">"BTC"</span>,
        <span class="st">"side"</span>:     <span class="st">"long"</span>,   <span class="cm"># "long" or "short"</span>
        <span class="st">"size_usd"</span>: <span class="num">100</span>,        <span class="cm"># $100 notional (margin = $20 at 5x)</span>
        <span class="st">"leverage"</span>: <span class="num">5</span>,
    },
    timeout=<span class="num">10</span>,
)
resp.raise_for_status()
result = resp.json()

position_id  = result[<span class="st">"position_id"</span>]
entry_price  = result[<span class="st">"entry_price"</span>]
<span class="fn">print</span>(<span class="st">f"Opened BTC long  id={position_id}  entry={entry_price:,.2f}"</span>)
      </div>

      <p>Note the distinction between <strong>notional size</strong> and <strong>margin</strong>. When you open a $100 position at 5x leverage, you are controlling $100 worth of BTC but only putting up $20 of margin. A 1% price move in your favour returns $1 on a $20 margin investment &mdash; a 5% return on capital. A 1% adverse move costs $1 and erodes 5% of your margin. Leverage amplifies both gains and losses proportionally.</p>

      <div class="callout callout-warning">
        <p><strong>Liquidation risk.</strong> At 5x leverage your position is liquidated (forcibly closed at a loss) if the price moves approximately 18&ndash;20% against you, depending on the funding accrued. Always set a stop-loss well before the liquidation price. Step 7 covers this in detail.</p>
      </div>

      <!-- STEP 4 -->
      <div class="step-header" id="step-4">
        <div class="step-num">4</div>
        <h2>Monitor the position</h2>
      </div>

      <p><code>GET /v1/trade/positions</code> returns all your currently open positions, including unrealized PnL calculated against the latest mark price. Poll this endpoint to track how your trades are performing in real time.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">monitor.py</span>
        </div>
<span class="kw">import</span> requests, os, time

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
HEADERS  = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {os.environ['PURPLEFLEA_API_KEY']}"</span>}

<span class="kw">def</span> <span class="fn">get_positions</span>():
    r = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/trade/positions"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    r.raise_for_status()
    <span class="kw">return</span> r.json()

<span class="cm"># Poll every 5 seconds and print a summary</span>
<span class="kw">while</span> <span class="bl">True</span>:
    positions = <span class="fn">get_positions</span>()
    <span class="kw">if</span> <span class="kw">not</span> positions:
        <span class="fn">print</span>(<span class="st">"No open positions."</span>)
    <span class="kw">else</span>:
        <span class="fn">print</span>(<span class="st">f"{'ID':&lt;12} {'Coin':&lt;6} {'Side':&lt;6} {'Entry':>10} {'Mark':>10} {'PnL':>10}"</span>)
        <span class="fn">print</span>(<span class="st">"-"</span> * <span class="num">60</span>)
        <span class="kw">for</span> p <span class="kw">in</span> positions:
            pnl_sign = <span class="st">"+"</span> <span class="kw">if</span> p[<span class="st">"unrealized_pnl"</span>] >= <span class="num">0</span> <span class="kw">else</span> <span class="st">""</span>
            <span class="fn">print</span>(
                <span class="st">f"{p['position_id']:&lt;12} {p['coin']:&lt;6} {p['side']:&lt;6} "</span>
                <span class="st">f"{p['entry_price']:>10,.2f} {p['mark_price']:>10,.2f} "</span>
                <span class="st">f"{pnl_sign}{p['unrealized_pnl']:>9.2f}"</span>
            )
    <span class="fn">print</span>()
    time.<span class="fn">sleep</span>(<span class="num">5</span>)
      </div>

      <p>Each position object in the array contains:</p>

      <ul>
        <li><code>position_id</code> &mdash; the unique ID you need to close the trade</li>
        <li><code>coin</code> &mdash; the asset being traded</li>
        <li><code>side</code> &mdash; <code>"long"</code> or <code>"short"</code></li>
        <li><code>entry_price</code> &mdash; the price at which you entered</li>
        <li><code>mark_price</code> &mdash; current fair-value price used for PnL and liquidation calculations</li>
        <li><code>unrealized_pnl</code> &mdash; floating profit or loss in USD, updated in real time</li>
      </ul>

      <!-- STEP 5 -->
      <div class="step-header" id="step-5">
        <div class="step-num">5</div>
        <h2>Close for profit</h2>
      </div>

      <p>When your strategy says to exit, post the position ID to <code>/v1/trade/close</code>. The API closes the position at the current mark price and returns the realized PnL &mdash; positive for a profit, negative for a loss.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">close_position.py</span>
        </div>
<span class="kw">import</span> requests, os

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
HEADERS  = {
    <span class="st">"Authorization"</span>: <span class="st">f"Bearer {os.environ['PURPLEFLEA_API_KEY']}"</span>,
    <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>,
}

<span class="kw">def</span> <span class="fn">close_position</span>(position_id: <span class="bl">str</span>) -> <span class="bl">dict</span>:
    resp = requests.<span class="fn">post</span>(
        <span class="st">f"{BASE_URL}/v1/trade/close"</span>,
        headers=HEADERS,
        json={<span class="st">"position_id"</span>: position_id},
        timeout=<span class="num">10</span>,
    )
    resp.raise_for_status()
    result = resp.json()
    <span class="fn">print</span>(<span class="st">f"Closed {position_id}  realized PnL: {result['pnl']:+.2f} USD"</span>)
    <span class="kw">return</span> result

<span class="cm"># Example usage after reading position_id from GET /v1/trade/positions:</span>
<span class="cm"># close_position("pos_abc123")</span>
      </div>

      <p>The response <code>pnl</code> field reflects the realized gain or loss in USD after fees are deducted. Track these values to calculate your total daily PnL and enforce the daily loss limit we add in Step 7.</p>

      <!-- STEP 6 -->
      <div class="step-header" id="step-6">
        <div class="step-num">6</div>
        <h2>Build a simple momentum strategy</h2>
      </div>

      <p>Now for the actual strategy logic. Momentum is one of the most well-studied effects in financial markets: assets that have been rising recently tend to keep rising, and vice versa, over short to medium time horizons. We will use 1-hour price change as our signal:</p>

      <ul>
        <li>If BTC 1h change &gt; +1% &rarr; go <strong>long</strong></li>
        <li>If BTC 1h change &lt; &minus;1% &rarr; go <strong>short</strong></li>
        <li>Otherwise &rarr; stay flat (no trade, or hold existing position)</li>
      </ul>

      <p>The Purple Flea market endpoint gives us the current mark price. To compute the 1-hour change we compare it to the price we recorded 60 minutes ago. The bot keeps a rolling price history in memory for exactly this purpose.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">momentum_strategy.py</span>
        </div>
<span class="kw">import</span> os, time, logging, collections
<span class="kw">import</span> requests

logging.<span class="fn">basicConfig</span>(level=logging.INFO, format=<span class="st">"%(asctime)s %(levelname)s %(message)s"</span>)

BASE_URL = <span class="st">"https://trading.purpleflea.com"</span>
HEADERS  = {
    <span class="st">"Authorization"</span>: <span class="st">f"Bearer {os.environ['PURPLEFLEA_API_KEY']}"</span>,
    <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>,
}

COIN            = <span class="st">"BTC"</span>
MOMENTUM_WINDOW = <span class="num">60</span>    <span class="cm"># minutes of price history to keep</span>
THRESHOLD_PCT   = <span class="num">1.0</span>   <span class="cm"># 1% 1h change triggers a trade</span>
SIZE_USD        = <span class="num">100</span>   <span class="cm"># notional size per trade</span>
LEVERAGE        = <span class="num">5</span>     <span class="cm"># 5x leverage</span>


<span class="kw">class</span> <span class="cls">MomentumBot</span>:

    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        <span class="cm"># Deque stores (timestamp, price) tuples; maxlen caps memory use</span>
        self.price_history = collections.<span class="fn">deque</span>(maxlen=MOMENTUM_WINDOW + <span class="num">5</span>)
        self.open_position  = <span class="bl">None</span>  <span class="cm"># dict with position_id, side</span>

    <span class="kw">def</span> <span class="fn">fetch_price</span>(self) -> <span class="bl">float</span>:
        r = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/markets"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
        r.raise_for_status()
        <span class="kw">for</span> m <span class="kw">in</span> r.json():
            <span class="kw">if</span> m[<span class="st">"coin"</span>] == COIN:
                <span class="kw">return</span> <span class="bl">float</span>(m[<span class="st">"mark_price"</span>])
        <span class="kw">raise</span> <span class="bl">ValueError</span>(<span class="st">f"{COIN} not found in markets"</span>)

    <span class="kw">def</span> <span class="fn">get_signal</span>(self) -> <span class="bl">str</span> | <span class="bl">None</span>:
        <span class="cm"># Need at least 60 data points (60 minutes of 1-min samples)</span>
        <span class="kw">if</span> <span class="fn">len</span>(self.price_history) &lt; MOMENTUM_WINDOW:
            <span class="kw">return</span> <span class="bl">None</span>
        now_price  = self.price_history[-<span class="num">1</span>][<span class="num">1</span>]
        hour_price = self.price_history[-MOMENTUM_WINDOW][<span class="num">1</span>]
        change_pct = (now_price - hour_price) / hour_price * <span class="num">100</span>
        logging.<span class="fn">info</span>(<span class="st">f"{COIN} 1h change: {change_pct:+.3f}%"</span>)
        <span class="kw">if</span> change_pct &gt;  THRESHOLD_PCT: <span class="kw">return</span> <span class="st">"long"</span>
        <span class="kw">if</span> change_pct &lt; -THRESHOLD_PCT: <span class="kw">return</span> <span class="st">"short"</span>
        <span class="kw">return</span> <span class="bl">None</span>

    <span class="kw">def</span> <span class="fn">open_trade</span>(self, side: <span class="bl">str</span>):
        resp = requests.<span class="fn">post</span>(
            <span class="st">f"{BASE_URL}/v1/trade/open"</span>,
            headers=HEADERS,
            json={<span class="st">"coin"</span>: COIN, <span class="st">"side"</span>: side, <span class="st">"size_usd"</span>: SIZE_USD, <span class="st">"leverage"</span>: LEVERAGE},
            timeout=<span class="num">10</span>,
        )
        resp.raise_for_status()
        data = resp.json()
        self.open_position = {<span class="st">"position_id"</span>: data[<span class="st">"position_id"</span>], <span class="st">"side"</span>: side}
        logging.<span class="fn">info</span>(<span class="st">f"Opened {side} id={data['position_id']} entry={data['entry_price']:,.2f}"</span>)

    <span class="kw">def</span> <span class="fn">close_trade</span>(self):
        <span class="kw">if</span> <span class="kw">not</span> self.open_position:
            <span class="kw">return</span>
        resp = requests.<span class="fn">post</span>(
            <span class="st">f"{BASE_URL}/v1/trade/close"</span>,
            headers=HEADERS,
            json={<span class="st">"position_id"</span>: self.open_position[<span class="st">"position_id"</span>]},
            timeout=<span class="num">10</span>,
        )
        resp.raise_for_status()
        pnl = resp.json()[<span class="st">"pnl"</span>]
        logging.<span class="fn">info</span>(<span class="st">f"Closed id={self.open_position['position_id']}  PnL={pnl:+.2f}"</span>)
        self.open_position = <span class="bl">None</span>
        <span class="kw">return</span> pnl

    <span class="kw">def</span> <span class="fn">tick</span>(self):
        price = self.<span class="fn">fetch_price</span>()
        self.price_history.<span class="fn">append</span>((time.<span class="fn">time</span>(), price))
        signal = self.<span class="fn">get_signal</span>()

        <span class="kw">if</span> signal <span class="kw">is</span> <span class="bl">None</span>:
            <span class="kw">return</span>   <span class="cm"># no clear signal, hold</span>

        <span class="cm"># If already in the right direction, do nothing</span>
        <span class="kw">if</span> self.open_position <span class="kw">and</span> self.open_position[<span class="st">"side"</span>] == signal:
            <span class="kw">return</span>

        <span class="cm"># Close existing position if direction changed</span>
        <span class="kw">if</span> self.open_position:
            self.<span class="fn">close_trade</span>()

        <span class="cm"># Open new position in signal direction</span>
        self.<span class="fn">open_trade</span>(signal)

    <span class="kw">def</span> <span class="fn">run</span>(self):
        logging.<span class="fn">info</span>(<span class="st">"Momentum bot started. Collecting price history..."</span>)
        <span class="kw">while</span> <span class="bl">True</span>:
            <span class="kw">try</span>:
                self.<span class="fn">tick</span>()
            <span class="kw">except</span> <span class="bl">Exception</span> <span class="kw">as</span> e:
                logging.<span class="fn">error</span>(<span class="st">f"Tick error: {e}"</span>)
            time.<span class="fn">sleep</span>(<span class="num">60</span>)


<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="cls">MomentumBot</span>().<span class="fn">run</span>()
      </div>

      <p>The bot starts collecting price samples immediately. After 60 minutes of data it will fire its first signal. The <code>tick()</code> method is intentionally concise: fetch, record, evaluate, act. Each responsibility is isolated in its own method, making it easy to swap the strategy logic without touching the order management code.</p>

      <!-- STEP 7 -->
      <div class="step-header" id="step-7">
        <div class="step-num">7</div>
        <h2>Add risk management</h2>
      </div>

      <p>A bot without risk management is a disaster waiting to happen. Even excellent strategies have losing streaks, and a single runaway loss can wipe out weeks of gains. We add three layers of protection:</p>

      <ol>
        <li><strong>Maximum position size</strong> &mdash; cap the notional USD exposed to any single coin</li>
        <li><strong>Daily loss limit</strong> &mdash; halt all trading if cumulative daily losses exceed a threshold</li>
        <li><strong>Per-trade stop-loss</strong> &mdash; close a position automatically if unrealized loss exceeds a percentage of margin</li>
      </ol>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">risk_manager.py</span>
        </div>
<span class="kw">import</span> time, logging

<span class="kw">class</span> <span class="cls">RiskManager</span>:
    <span class="st">"""
    Enforces hard risk limits for the trading bot.
    Call check_before_open() before every new trade.
    Call update_pnl() after every position close.
    Call check_stop_loss() on every tick while a position is open.
    """</span>

    <span class="kw">def</span> <span class="fn">__init__</span>(
        self,
        max_position_usd: <span class="bl">float</span> = <span class="num">500</span>,    <span class="cm"># max notional per coin, $500</span>
        daily_loss_limit: <span class="bl">float</span> = <span class="num">50</span>,     <span class="cm"># halt after $50 loss in one day</span>
        stop_loss_pct:    <span class="bl">float</span> = <span class="num">2.0</span>,    <span class="cm"># close if unrealized loss > 2% of notional</span>
    ):
        self.max_position_usd = max_position_usd
        self.daily_loss_limit = daily_loss_limit
        self.stop_loss_pct    = stop_loss_pct / <span class="num">100</span>

        self.daily_pnl     = <span class="num">0.0</span>
        self.day_start     = self.<span class="fn">_today</span>()
        self.trading_halted = <span class="bl">False</span>

    <span class="kw">def</span> <span class="fn">_today</span>(self) -> <span class="bl">str</span>:
        <span class="kw">import</span> datetime
        <span class="kw">return</span> datetime.date.today().<span class="fn">isoformat</span>()

    <span class="kw">def</span> <span class="fn">_reset_if_new_day</span>(self):
        <span class="kw">if</span> self.<span class="fn">_today</span>() != self.day_start:
            logging.<span class="fn">info</span>(<span class="st">f"New day: resetting daily PnL (was {self.daily_pnl:+.2f})"</span>)
            self.daily_pnl      = <span class="num">0.0</span>
            self.day_start      = self.<span class="fn">_today</span>()
            self.trading_halted = <span class="bl">False</span>

    <span class="kw">def</span> <span class="fn">check_before_open</span>(self, proposed_size_usd: <span class="bl">float</span>) -> <span class="bl">bool</span>:
        <span class="st">"""Returns True if the trade is allowed to proceed."""</span>
        self.<span class="fn">_reset_if_new_day</span>()

        <span class="kw">if</span> self.trading_halted:
            logging.<span class="fn">warning</span>(<span class="st">"Trading halted: daily loss limit reached. Skipping trade."</span>)
            <span class="kw">return</span> <span class="bl">False</span>

        <span class="kw">if</span> proposed_size_usd &gt; self.max_position_usd:
            logging.<span class="fn">warning</span>(
                <span class="st">f"Trade rejected: size {proposed_size_usd} exceeds max {self.max_position_usd}"</span>
            )
            <span class="kw">return</span> <span class="bl">False</span>

        <span class="kw">return</span> <span class="bl">True</span>

    <span class="kw">def</span> <span class="fn">update_pnl</span>(self, realized_pnl: <span class="bl">float</span>):
        <span class="st">"""Call after each position close with the realized PnL."""</span>
        self.<span class="fn">_reset_if_new_day</span>()
        self.daily_pnl += realized_pnl
        logging.<span class="fn">info</span>(<span class="st">f"Daily PnL updated: {self.daily_pnl:+.2f}"</span>)

        <span class="kw">if</span> self.daily_pnl &lt;= -self.daily_loss_limit:
            self.trading_halted = <span class="bl">True</span>
            logging.<span class="fn">warning</span>(
                <span class="st">f"DAILY LOSS LIMIT HIT ({self.daily_pnl:+.2f}). Halting until tomorrow."</span>
            )

    <span class="kw">def</span> <span class="fn">check_stop_loss</span>(
        self,
        entry_price:    <span class="bl">float</span>,
        current_price:  <span class="bl">float</span>,
        side:           <span class="bl">str</span>,
        size_usd:       <span class="bl">float</span>,
    ) -> <span class="bl">bool</span>:
        <span class="st">"""Returns True if the stop-loss is triggered and position should be closed."""</span>
        <span class="kw">if</span> side == <span class="st">"long"</span>:
            raw_pnl = (current_price - entry_price) / entry_price * size_usd
        <span class="kw">else</span>:
            raw_pnl = (entry_price - current_price) / entry_price * size_usd

        loss_pct = raw_pnl / size_usd
        <span class="kw">if</span> loss_pct &lt;= -self.stop_loss_pct:
            logging.<span class="fn">warning</span>(
                <span class="st">f"Stop-loss triggered: {loss_pct*100:.2f}% loss on {side} entry={entry_price}"</span>
            )
            <span class="kw">return</span> <span class="bl">True</span>
        <span class="kw">return</span> <span class="bl">False</span>
      </div>

      <div class="callout callout-green">
        <p><strong>Good defaults to start with:</strong> max position $500 USD notional, daily loss limit $50, stop-loss at 2% of notional (which equals a 10% adverse move at 5x leverage). Adjust these after you understand your strategy's typical volatility profile.</p>
      </div>

      <!-- STEP 8 -->
      <div class="step-header" id="step-8">
        <div class="step-num">8</div>
        <h2>Deploy with pm2 for 24/7 running</h2>
      </div>

      <p>Your local machine will not run the bot indefinitely. You need a server &mdash; a $6/month VPS works fine &mdash; and a process manager that restarts the bot automatically if it crashes. pm2 is the standard tool for this. Despite being a Node.js utility, it manages any process including plain Python scripts.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">terminal</span>
        </div>
<span class="cm"># Install pm2 globally (requires Node.js)</span>
npm install -g pm2

<span class="cm"># Start the bot</span>
pm2 start bot.py \
  --name purpleflea-bot \
  --interpreter python3 \
  --env PURPLEFLEA_API_KEY=pf_sk_your_key_here

<span class="cm"># Save the process list so it restarts after server reboots</span>
pm2 save
pm2 startup   <span class="cm"># follow the printed command to enable autostart</span>

<span class="cm"># Useful commands</span>
pm2 logs purpleflea-bot      <span class="cm"># tail live logs</span>
pm2 status                   <span class="cm"># see all processes</span>
pm2 restart purpleflea-bot   <span class="cm"># restart after a code change</span>
pm2 stop    purpleflea-bot   <span class="cm"># stop the bot</span>
      </div>

      <p>For cleaner configuration, use an ecosystem file instead of inline flags. This makes environment variable management explicit and keeps your deployment reproducible:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">ecosystem.config.cjs</span>
        </div>
module.exports = {
  apps: [
    {
      name:        <span class="st">"purpleflea-bot"</span>,
      script:      <span class="st">"bot.py"</span>,
      interpreter: <span class="st">"python3"</span>,
      watch:       <span class="bl">false</span>,
      max_restarts: <span class="num">10</span>,
      restart_delay: <span class="num">5000</span>,  <span class="cm">// 5s between restarts</span>
      env: {
        PURPLEFLEA_API_KEY: <span class="st">"pf_sk_your_key_here"</span>,
      },
    },
  ],
};
      </div>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">terminal</span>
        </div>
pm2 start ecosystem.config.cjs
      </div>

      <div class="callout">
        <p><strong>Note on the .cjs extension.</strong> If your project has <code>"type": "module"</code> in its package.json, use the <code>.cjs</code> extension for the pm2 ecosystem config so Node.js treats it as CommonJS and the <code>module.exports</code> syntax works correctly.</p>
      </div>

      <!-- FULL BOT -->
      <h2 id="full-bot">Complete combined bot</h2>

      <p>Here is the complete bot &mdash; strategy, risk management, API calls, and main loop &mdash; in a single self-contained file. Copy it, set your API key, and run it.</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">bot.py</span>
        </div>
<span class="st">"""
Purple Flea Momentum Trading Bot
---------------------------------
Strategy : 1-hour momentum (BTC, ETH, SOL)
Risk     : max position size, daily loss limit, per-trade stop-loss
Deploy   : pm2 start bot.py --interpreter python3
Requires : requests  (pip install requests)
Env var  : PURPLEFLEA_API_KEY
"""</span>

<span class="kw">import</span> os
<span class="kw">import</span> time
<span class="kw">import</span> logging
<span class="kw">import</span> datetime
<span class="kw">import</span> collections
<span class="kw">import</span> requests

<span class="cm">#  Config </span>
BASE_URL         = <span class="st">"https://trading.purpleflea.com"</span>
API_KEY          = os.environ[<span class="st">"PURPLEFLEA_API_KEY"</span>]
HEADERS          = {
    <span class="st">"Authorization"</span>: <span class="st">f"Bearer {API_KEY}"</span>,
    <span class="st">"Content-Type"</span>:  <span class="st">"application/json"</span>,
}
COINS            = [<span class="st">"BTC"</span>, <span class="st">"ETH"</span>, <span class="st">"SOL"</span>]
TICK_INTERVAL    = <span class="num">60</span>     <span class="cm"># seconds between each main loop iteration</span>
MOMENTUM_WINDOW  = <span class="num">60</span>     <span class="cm"># lookback window in ticks (= 60 minutes at 1-min ticks)</span>
THRESHOLD_PCT    = <span class="num">1.0</span>    <span class="cm"># minimum 1h change % to trigger a trade</span>
SIZE_USD         = <span class="num">100</span>    <span class="cm"># notional USD per position</span>
LEVERAGE         = <span class="num">5</span>      <span class="cm"># leverage multiplier</span>
MAX_POS_USD      = <span class="num">500</span>    <span class="cm"># maximum notional per coin</span>
DAILY_LOSS_LIMIT = <span class="num">50</span>     <span class="cm"># halt trading after $50 daily loss</span>
STOP_LOSS_PCT    = <span class="num">2.0</span>    <span class="cm"># close position if loss exceeds 2% of notional</span>
MARKET_CACHE_TTL = <span class="num">120</span>    <span class="cm"># seconds to cache /v1/markets response</span>

logging.<span class="fn">basicConfig</span>(
    level=logging.INFO,
    format=<span class="st">"%(asctime)s %(levelname)-8s %(message)s"</span>,
    datefmt=<span class="st">"%Y-%m-%d %H:%M:%S"</span>,
)

<span class="cm">#  API helpers </span>
_markets_cache: <span class="bl">dict</span> = {}
_markets_ts:    <span class="bl">float</span> = <span class="num">0</span>

<span class="kw">def</span> <span class="fn">fetch_markets</span>() -> <span class="bl">dict</span>:
    <span class="kw">global</span> _markets_cache, _markets_ts
    <span class="kw">if</span> time.<span class="fn">time</span>() - _markets_ts &lt; MARKET_CACHE_TTL:
        <span class="kw">return</span> _markets_cache
    r = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/markets"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    r.raise_for_status()
    _markets_cache = {m[<span class="st">"coin"</span>]: m <span class="kw">for</span> m <span class="kw">in</span> r.json()}
    _markets_ts    = time.<span class="fn">time</span>()
    <span class="kw">return</span> _markets_cache

<span class="kw">def</span> <span class="fn">get_mark_price</span>(coin: <span class="bl">str</span>) -> <span class="bl">float</span>:
    <span class="kw">return</span> <span class="bl">float</span>(<span class="fn">fetch_markets</span>()[coin][<span class="st">"mark_price"</span>])

<span class="kw">def</span> <span class="fn">open_position</span>(coin: <span class="bl">str</span>, side: <span class="bl">str</span>) -> <span class="bl">dict</span>:
    r = requests.<span class="fn">post</span>(
        <span class="st">f"{BASE_URL}/v1/trade/open"</span>, headers=HEADERS,
        json={<span class="st">"coin"</span>: coin, <span class="st">"side"</span>: side, <span class="st">"size_usd"</span>: SIZE_USD, <span class="st">"leverage"</span>: LEVERAGE},
        timeout=<span class="num">10</span>,
    )
    r.raise_for_status()
    <span class="kw">return</span> r.json()

<span class="kw">def</span> <span class="fn">close_position</span>(position_id: <span class="bl">str</span>) -> <span class="bl">float</span>:
    r = requests.<span class="fn">post</span>(
        <span class="st">f"{BASE_URL}/v1/trade/close"</span>, headers=HEADERS,
        json={<span class="st">"position_id"</span>: position_id}, timeout=<span class="num">10</span>,
    )
    r.raise_for_status()
    <span class="kw">return</span> r.json()[<span class="st">"pnl"</span>]

<span class="kw">def</span> <span class="fn">get_positions</span>() -> <span class="bl">list</span>:
    r = requests.<span class="fn">get</span>(<span class="st">f"{BASE_URL}/v1/trade/positions"</span>, headers=HEADERS, timeout=<span class="num">10</span>)
    r.raise_for_status()
    <span class="kw">return</span> r.json()

<span class="cm">#  Risk manager </span>
<span class="kw">class</span> <span class="cls">RiskManager</span>:

    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.daily_pnl      = <span class="num">0.0</span>
        self.day_start      = datetime.date.today().<span class="fn">isoformat</span>()
        self.trading_halted = <span class="bl">False</span>

    <span class="kw">def</span> <span class="fn">_reset_if_new_day</span>(self):
        today = datetime.date.today().<span class="fn">isoformat</span>()
        <span class="kw">if</span> today != self.day_start:
            logging.<span class="fn">info</span>(<span class="st">f"New trading day. Previous daily PnL: {self.daily_pnl:+.2f}"</span>)
            self.daily_pnl      = <span class="num">0.0</span>
            self.day_start      = today
            self.trading_halted = <span class="bl">False</span>

    <span class="kw">def</span> <span class="fn">can_trade</span>(self) -> <span class="bl">bool</span>:
        self.<span class="fn">_reset_if_new_day</span>()
        <span class="kw">if</span> self.trading_halted:
            logging.<span class="fn">warning</span>(<span class="st">"Trading halted: daily loss limit reached."</span>)
        <span class="kw">return</span> <span class="kw">not</span> self.trading_halted

    <span class="kw">def</span> <span class="fn">record_close</span>(self, pnl: <span class="bl">float</span>):
        self.daily_pnl += pnl
        logging.<span class="fn">info</span>(<span class="st">f"Daily PnL: {self.daily_pnl:+.2f} (limit: -{DAILY_LOSS_LIMIT})"</span>)
        <span class="kw">if</span> self.daily_pnl &lt;= -DAILY_LOSS_LIMIT:
            self.trading_halted = <span class="bl">True</span>
            logging.<span class="fn">warning</span>(<span class="st">"DAILY LOSS LIMIT HIT. No new trades until tomorrow."</span>)

    <span class="kw">def</span> <span class="fn">is_stop_loss</span>(self, entry: <span class="bl">float</span>, current: <span class="bl">float</span>, side: <span class="bl">str</span>) -> <span class="bl">bool</span>:
        change = (current - entry) / entry
        pnl_pct = change <span class="kw">if</span> side == <span class="st">"long"</span> <span class="kw">else</span> -change
        <span class="kw">if</span> pnl_pct &lt;= -(STOP_LOSS_PCT / <span class="num">100</span>):
            logging.<span class="fn">warning</span>(<span class="st">f"Stop-loss: {pnl_pct*100:.2f}% on {side} entry={entry:.2f}"</span>)
            <span class="kw">return</span> <span class="bl">True</span>
        <span class="kw">return</span> <span class="bl">False</span>

<span class="cm">#  Main bot </span>
<span class="kw">class</span> <span class="cls">MomentumBot</span>:

    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.risk = <span class="cls">RiskManager</span>()
        <span class="cm"># price_history[coin] = deque of (timestamp, price)</span>
        self.price_history: <span class="bl">dict</span>[<span class="bl">str</span>, collections.deque] = {
            coin: collections.<span class="fn">deque</span>(maxlen=MOMENTUM_WINDOW + <span class="num">5</span>)
            <span class="kw">for</span> coin <span class="kw">in</span> COINS
        }
        <span class="cm"># open_positions[coin] = {position_id, side, entry_price}</span>
        self.open_positions: <span class="bl">dict</span>[<span class="bl">str</span>, <span class="bl">dict</span>] = {}

    <span class="kw">def</span> <span class="fn">_signal</span>(self, coin: <span class="bl">str</span>) -> <span class="bl">str</span> | <span class="bl">None</span>:
        hist = self.price_history[coin]
        <span class="kw">if</span> <span class="fn">len</span>(hist) &lt; MOMENTUM_WINDOW:
            <span class="kw">return</span> <span class="bl">None</span>
        now_p  = hist[-<span class="num">1</span>][<span class="num">1</span>]
        prev_p = hist[-MOMENTUM_WINDOW][<span class="num">1</span>]
        chg    = (now_p - prev_p) / prev_p * <span class="num">100</span>
        logging.<span class="fn">debug</span>(<span class="st">f"{coin} 1h chg: {chg:+.3f}%"</span>)
        <span class="kw">if</span> chg &gt;  THRESHOLD_PCT: <span class="kw">return</span> <span class="st">"long"</span>
        <span class="kw">if</span> chg &lt; -THRESHOLD_PCT: <span class="kw">return</span> <span class="st">"short"</span>
        <span class="kw">return</span> <span class="bl">None</span>

    <span class="kw">def</span> <span class="fn">_maybe_stop_loss</span>(self, coin: <span class="bl">str</span>, current_price: <span class="bl">float</span>):
        pos = self.open_positions.get(coin)
        <span class="kw">if</span> <span class="kw">not</span> pos:
            <span class="kw">return</span>
        <span class="kw">if</span> self.risk.<span class="fn">is_stop_loss</span>(pos[<span class="st">"entry_price"</span>], current_price, pos[<span class="st">"side"</span>]):
            pnl = <span class="fn">close_position</span>(pos[<span class="st">"position_id"</span>])
            logging.<span class="fn">info</span>(<span class="st">f"[{coin}] stop-loss close PnL={pnl:+.2f}"</span>)
            self.risk.<span class="fn">record_close</span>(pnl)
            <span class="kw">del</span> self.open_positions[coin]

    <span class="kw">def</span> <span class="fn">tick</span>(self):
        markets = <span class="fn">fetch_markets</span>()

        <span class="kw">for</span> coin <span class="kw">in</span> COINS:
            <span class="kw">if</span> coin <span class="kw">not in</span> markets:
                <span class="kw">continue</span>
            price = <span class="bl">float</span>(markets[coin][<span class="st">"mark_price"</span>])
            self.price_history[coin].<span class="fn">append</span>((time.<span class="fn">time</span>(), price))

            <span class="cm"># 1. Check stop-loss on open positions</span>
            self.<span class="fn">_maybe_stop_loss</span>(coin, price)

            <span class="cm"># 2. Get momentum signal</span>
            <span class="kw">if</span> <span class="kw">not</span> self.risk.<span class="fn">can_trade</span>():
                <span class="kw">continue</span>

            signal = self.<span class="fn">_signal</span>(coin)
            <span class="kw">if</span> signal <span class="kw">is</span> <span class="bl">None</span>:
                <span class="kw">continue</span>

            pos = self.open_positions.get(coin)

            <span class="cm"># Already in the right direction  hold</span>
            <span class="kw">if</span> pos <span class="kw">and</span> pos[<span class="st">"side"</span>] == signal:
                <span class="kw">continue</span>

            <span class="cm"># Close existing position if direction reversed</span>
            <span class="kw">if</span> pos:
                pnl = <span class="fn">close_position</span>(pos[<span class="st">"position_id"</span>])
                logging.<span class="fn">info</span>(<span class="st">f"[{coin}] closed {pos['side']} PnL={pnl:+.2f}"</span>)
                self.risk.<span class="fn">record_close</span>(pnl)
                <span class="kw">del</span> self.open_positions[coin]

            <span class="cm"># Recheck after close (daily limit may have triggered)</span>
            <span class="kw">if</span> <span class="kw">not</span> self.risk.<span class="fn">can_trade</span>():
                <span class="kw">continue</span>

            <span class="cm"># Open new position</span>
            result = <span class="fn">open_position</span>(coin, signal)
            self.open_positions[coin] = {
                <span class="st">"position_id"</span>:  result[<span class="st">"position_id"</span>],
                <span class="st">"side"</span>:         signal,
                <span class="st">"entry_price"</span>:  result[<span class="st">"entry_price"</span>],
            }
            logging.<span class="fn">info</span>(
                <span class="st">f"[{coin}] opened {signal} id={result['position_id']} "</span>
                <span class="st">f"entry={result['entry_price']:,.2f}"</span>
            )

    <span class="kw">def</span> <span class="fn">run</span>(self):
        logging.<span class="fn">info</span>(<span class="st">"Bot started. Coins: %s  Threshold: %.1f%%  Leverage: %dx"</span>,
                     COINS, THRESHOLD_PCT, LEVERAGE)
        logging.<span class="fn">info</span>(<span class="st">"Collecting %d minutes of price history before first signal..."</span>,
                     MOMENTUM_WINDOW)
        <span class="kw">while</span> <span class="bl">True</span>:
            <span class="kw">try</span>:
                self.<span class="fn">tick</span>()
            <span class="kw">except</span> requests.RequestException <span class="kw">as</span> e:
                logging.<span class="fn">error</span>(<span class="st">"Network error: %s (retrying next tick)"</span>, e)
            <span class="kw">except</span> <span class="bl">Exception</span> <span class="kw">as</span> e:
                logging.<span class="fn">exception</span>(<span class="st">"Unexpected error: %s"</span>, e)
            time.<span class="fn">sleep</span>(TICK_INTERVAL)


<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="cls">MomentumBot</span>().<span class="fn">run</span>()
      </div>

      <p>Save the file as <code>bot.py</code>, export your API key, and launch it:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">terminal</span>
        </div>
<span class="kw">export</span> PURPLEFLEA_API_KEY=pf_sk_your_key_here
python3 bot.py
      </div>

      <p>You will see log output like:</p>

      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">logs</span>
        </div>
2026-02-27 09:00:00 INFO     Bot started. Coins: ['BTC', 'ETH', 'SOL']  Threshold: 1.0%  Leverage: 5x
2026-02-27 09:00:00 INFO     Collecting 60 minutes of price history before first signal...
2026-02-27 09:01:00 INFO     Market cache refreshed. 24 coins available.
2026-02-27 10:00:00 INFO     [BTC] 1h chg: +1.43%
2026-02-27 10:00:01 INFO     [BTC] opened long id=pos_7a2f1c entry=67,812.50
2026-02-27 11:00:00 INFO     [BTC] 1h chg: +0.31%
2026-02-27 12:00:00 INFO     [BTC] 1h chg: -1.18%
2026-02-27 12:00:01 INFO     [BTC] closed long PnL=+4.72
2026-02-27 12:00:01 INFO     Daily PnL: +4.72 (limit: -50)
2026-02-27 12:00:02 INFO     [BTC] opened short id=pos_9c3d8e entry=67,680.00
      </div>

      <!-- NEXT STEPS -->
      <h2 id="next-steps">What to do next</h2>

      <p>You now have a working trading bot. Here are the most valuable directions to take it further:</p>

      <h3>Add more trading pairs</h3>
      <p>The bot already supports multiple coins &mdash; it is iterating over the <code>COINS</code> list. Add <code>"DOGE"</code>, <code>"AVAX"</code>, or any coin returned by <code>GET /v1/markets</code>. Each coin runs its own independent momentum calculation and maintains its own open position. The risk manager's daily loss limit applies across the entire portfolio.</p>

      <h3>Backtest before going live</h3>
      <p>Download historical price data, replay it through <code>_signal()</code>, and measure what the strategy would have returned. A proper backtest accounts for fees (typically 0.05% per trade on perpetuals), funding costs, slippage, and the market impact of your own orders. Python's pandas library makes this straightforward. Start small on testnet, then compare live results against your backtest expectations before increasing size.</p>

      <h3>Connect to LangChain for AI-driven signals</h3>
      <p>LangChain makes it easy to build an LLM agent that reads on-chain data, news sentiment, and social signals alongside price data, then reasons about what position to take. The <a href="/blog/langchain-crypto-tools/">LangChain crypto tools guide</a> walks through wiring a Claude-backed agent to the Purple Flea API. You keep the same order execution and risk management code built here; only the signal generation changes.</p>

      <h3>Improve the strategy itself</h3>
      <p>Momentum works but it is simple. Consider adding a volatility filter (skip trades when ATR is unusually low or high), a trend confirmation indicator (only take long signals when price is above a 200-period moving average), or a funding rate filter (avoid longs when funding is deeply positive). Each filter reduces trade frequency but tends to improve the quality of signals that do fire.</p>

      <hr class="article-divider">

      <p>The complete Purple Flea Trading API reference is at <a href="https://trading.purpleflea.com/docs" target="_blank">trading.purpleflea.com/docs</a>. The endpoint list in this tutorial covers everything you need to build production-grade bots; additional endpoints expose historical candles, liquidation prices, and account-level PnL summaries. Questions? Reach the team on the <a href="https://discord.gg/purpleflea" target="_blank">Purple Flea Discord</a>.</p>

    </div><!-- /.article-body -->

    <!-- RELATED -->
    <div class="related-section">
      <h3>Related articles</h3>
      <div class="related-grid">
        <a href="/blog/build-trading-agent-python/" class="related-card">
          <div class="label">Tutorial</div>
          <div class="title">Build a Crypto Trading Agent in Python &mdash; Step by Step</div>
          <div class="desc">EMA crossover agent with full risk controls</div>
        </a>
        <a href="/blog/langchain-crypto-tools/" class="related-card">
          <div class="label">Integration</div>
          <div class="title">LangChain Crypto Tools with Purple Flea</div>
          <div class="desc">Wire an LLM agent to live trading endpoints</div>
        </a>
        <a href="/blog/autonomous-trading-hyperliquid/" class="related-card">
          <div class="label">Guide</div>
          <div class="title">Autonomous Trading on Hyperliquid</div>
          <div class="desc">Cross-chain perpetuals with onchain settlement</div>
        </a>
        <a href="/blog/mcp-servers-ai-agents/" class="related-card">
          <div class="label">Guide</div>
          <div class="title">MCP Servers for AI Agents</div>
          <div class="desc">Tool-calling infrastructure for autonomous agents</div>
        </a>
      </div>
    </div>

  </article><!-- /.article-wrapper -->

  <!-- TOC SIDEBAR -->
  <aside class="toc-sidebar">
    <div class="toc-sticky">
      <div class="toc-label">On this page</div>
      <ul class="toc-list">
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#step-1">1 &mdash; Register &amp; API key</a></li>
        <li><a href="#step-2">2 &mdash; Explore markets</a></li>
        <li><a href="#step-3">3 &mdash; Open a position</a></li>
        <li><a href="#step-4">4 &mdash; Monitor position</a></li>
        <li><a href="#step-5">5 &mdash; Close for profit</a></li>
        <li><a href="#step-6">6 &mdash; Momentum strategy</a></li>
        <li><a href="#step-7">7 &mdash; Risk management</a></li>
        <li><a href="#step-8">8 &mdash; Deploy with pm2</a></li>
        <li><a href="#full-bot">Complete bot code</a></li>
        <li><a href="#next-steps">What to do next</a></li>
      </ul>
    </div>
  </aside>

</div><!-- /.page-outer -->

<!-- FOOTER -->
<footer>
  <div class="footer-inner">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo" style="display:inline-flex;">
          <div class="nav-logo-icon" style="margin-right:10px;">&#9830;</div>
          Purple Flea
        </a>
        <p>The crypto wallet and trading platform built for AI agents and developers.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Product</h4>
          <ul>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/trading-api">Trading API</a></li>
            <li><a href="/integrations">Integrations</a></li>
            <li><a href="/pricing">Pricing</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Documentation</a></li>
            <li><a href="/docs/quickstart">Quickstart</a></li>
            <li><a href="/blog">Blog</a></li>
            <li><a href="https://github.com/purpleflea" target="_blank">GitHub</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/about">About</a></li>
            <li><a href="/privacy">Privacy</a></li>
            <li><a href="/terms">Terms</a></li>
            <li><a href="https://discord.gg/purpleflea" target="_blank">Discord</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://twitter.com/purpleflea" target="_blank">Twitter</a>
        <a href="https://discord.gg/purpleflea" target="_blank">Discord</a>
        <a href="https://github.com/purpleflea" target="_blank">GitHub</a>
      </div>
    </div>
  </div>
</footer>

<script>
// Scrolled nav
const navbar = document.getElementById('navbar');
window.addEventListener('scroll', () => {
  navbar.classList.toggle('scrolled', window.scrollY > 20);
}, { passive: true });

// TOC active link highlighting
const tocLinks = document.querySelectorAll('.toc-list a');
const headings = document.querySelectorAll('.article-body h2[id], .step-header[id]');

const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const id = entry.target.id;
      tocLinks.forEach(a => {
        a.classList.toggle('active', a.getAttribute('href') === '#' + id);
      });
    }
  });
}, { rootMargin: '-80px 0px -60% 0px', threshold: 0 });

headings.forEach(h => observer.observe(h));
</script>

</body>
</html>
