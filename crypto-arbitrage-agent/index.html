<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crypto Arbitrage Agent â€” Funding Rate, Cross-Chain &amp; Stat Arb Bots</title>
<meta name="description" content="Build a profitable crypto arbitrage bot using Purple Flea APIs. Funding rate arbitrage, cross-chain price arb, and statistical arb â€” full Python code, backtesting, and risk management.">
<link rel="canonical" href="https://purpleflea.com/crypto-arbitrage-agent">
<meta property="og:title" content="Crypto Arbitrage Agent â€” Funding Rate, Cross-Chain &amp; Stat Arb Bots">
<meta property="og:description" content="Build a profitable crypto arbitrage bot using Purple Flea APIs. Funding rate arbitrage, cross-chain price arb, and statistical arb â€” full Python code, backtesting, and risk management.">
<meta property="og:url" content="https://purpleflea.com/crypto-arbitrage-agent">
<meta property="og:type" content="website">
<meta property="og:site_name" content="Purple Flea">
<meta property="og:image" content="https://purpleflea.com/flea.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@purpleflea">
<meta name="twitter:title" content="Crypto Arbitrage Agent â€” Funding Rate, Cross-Chain &amp; Stat Arb Bots">
<meta name="twitter:description" content="Build a profitable crypto arbitrage bot: funding rate arb, cross-chain price arb, statistical arb. Full Python code via Purple Flea APIs.">
<meta name="twitter:image" content="https://purpleflea.com/flea.jpg">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "name": "Crypto Arbitrage Agent",
  "url": "https://purpleflea.com/crypto-arbitrage-agent",
  "description": "Build a profitable crypto arbitrage bot using Purple Flea APIs. Funding rate arbitrage, cross-chain price arb, and statistical arb â€” full Python code, backtesting, and risk management.",
  "publisher": { "@type": "Organization", "name": "Purple Flea", "url": "https://purpleflea.com" }
}
</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŸ£</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --purple: #A855F7; --purple-dim: #7C3AED;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --purple-subtle: rgba(168, 85, 247, 0.08);
  --bg: #09090B; --text: #FAFAFA;
  --text-secondary: #A1A1AA; --text-muted: #71717A;
  --border: rgba(255,255,255,0.06); --bg-card: rgba(255,255,255,0.03);
  --bg-card-hover: rgba(255,255,255,0.06);
  --border-hover: rgba(168,85,247,0.3);
  --radius: 16px; --radius-sm: 10px;
}
html { scroll-behavior: smooth; }
body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
body::before { content: ''; position: fixed; inset: 0; z-index: 9999; pointer-events: none; opacity: 0.025; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); background-repeat: repeat; background-size: 180px; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(168,85,247,0.3); border-radius: 3px; }
::selection { background: rgba(168,85,247,0.4); color: white; }
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.reveal { opacity: 0; transform: translateY(30px); transition: opacity 0.8s cubic-bezier(0.16,1,0.3,1), transform 0.8s cubic-bezier(0.16,1,0.3,1); }
.reveal.visible { opacity: 1; transform: translateY(0); }
.reveal-delay-1 { transition-delay: 0.1s; }
.reveal-delay-2 { transition-delay: 0.2s; }
.reveal-delay-3 { transition-delay: 0.3s; }

/* NAV */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; padding: 16px 0; transition: all 0.3s ease; }
nav.scrolled { background: rgba(9,9,11,0.85); backdrop-filter: blur(20px) saturate(1.5); border-bottom: 1px solid var(--border); }
.nav-inner { display: flex; align-items: center; justify-content: space-between; max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.nav-logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--purple), var(--purple-dim)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }
.nav-links { display: flex; align-items: center; gap: 32px; list-style: none; }
.nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 450; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-cta { display: inline-flex; align-items: center; gap: 6px; padding: 8px 18px; background: var(--purple); color: white !important; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: all 0.2s; }
.nav-cta:hover { background: var(--purple-dim); transform: translateY(-1px); }
@media (max-width: 768px) { .nav-links { display: none; } }

/* HERO */
.hero { min-height: 82vh; display: flex; align-items: center; justify-content: center; position: relative; padding: 130px 0 80px; overflow: hidden; }
.hero-bg { position: absolute; inset: 0; overflow: hidden; }
.hero-gradient-1 { position: absolute; top: -30%; left: 50%; transform: translateX(-50%); width: 960px; height: 640px; background: radial-gradient(ellipse, rgba(168,85,247,0.15) 0%, transparent 70%); filter: blur(60px); }
.hero-grid { position: absolute; inset: 0; background-image: linear-gradient(rgba(168,85,247,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(168,85,247,0.03) 1px, transparent 1px); background-size: 60px 60px; mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); -webkit-mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 30%, transparent 100%); }
.hero-content { position: relative; text-align: center; max-width: 880px; margin: 0 auto; padding: 0 24px; }
.hero-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 16px 6px 8px; background: var(--purple-subtle); border: 1px solid rgba(168,85,247,0.15); border-radius: 100px; font-size: 13px; font-weight: 500; color: var(--purple); margin-bottom: 32px; animation: fadeInDown 0.8s ease; }
.hero-badge-dot { width: 8px; height: 8px; background: var(--purple); border-radius: 50%; animation: badge-pulse 2s ease-in-out infinite; }
@keyframes badge-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
@keyframes fadeInDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
@keyframes gradient-shift { 0% { background-position: 0% center; } 50% { background-position: 100% center; } 100% { background-position: 0% center; } }
.hero h1 { font-size: clamp(2.6rem, 6vw, 4.6rem); font-weight: 800; line-height: 1.05; letter-spacing: -0.03em; margin-bottom: 24px; animation: fadeInUp 0.8s ease 0.1s both; }
.hero h1 .gradient { background: linear-gradient(135deg, var(--purple) 0%, #C084FC 50%, var(--purple) 100%); background-size: 200% auto; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: gradient-shift 5s ease infinite; }
.hero-desc { font-size: clamp(1rem, 2vw, 1.2rem); color: var(--text-secondary); margin-bottom: 40px; line-height: 1.7; animation: fadeInUp 0.8s ease 0.2s both; }
.hero-actions { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; animation: fadeInUp 0.8s ease 0.3s both; }
.btn-primary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--purple); color: white; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px; text-decoration: none; transition: all 0.2s; box-shadow: 0 0 30px rgba(168,85,247,0.3); }
.btn-primary:hover { background: var(--purple-dim); transform: translateY(-2px); box-shadow: 0 0 40px rgba(168,85,247,0.5); }
.btn-secondary { display: inline-flex; align-items: center; gap: 8px; padding: 14px 28px; background: var(--bg-card); color: var(--text); border-radius: var(--radius-sm); font-weight: 500; font-size: 15px; text-decoration: none; border: 1px solid var(--border); transition: all 0.2s; }
.btn-secondary:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }

/* SECTIONS */
section { padding: 100px 0; position: relative; }
.section-label { display: inline-flex; align-items: center; gap: 12px; font-size: 12px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: var(--purple); margin-bottom: 20px; }
.section-label::before { content: ''; width: 24px; height: 1px; background: var(--purple); }
.section-title { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; }
.section-desc { font-size: 1.1rem; color: var(--text-secondary); max-width: 640px; margin-bottom: 60px; line-height: 1.7; }
.section-divider { border: none; height: 1px; background: linear-gradient(90deg, transparent, var(--border), transparent); margin: 0; }

/* STRATEGY SECTION HEADER */
.strategy-header { display: flex; align-items: flex-start; gap: 20px; margin-bottom: 40px; }
.strategy-number { font-size: clamp(3rem, 6vw, 5rem); font-weight: 900; line-height: 1; color: rgba(168,85,247,0.12); letter-spacing: -0.04em; min-width: 80px; }
.strategy-meta { flex: 1; }
.strategy-meta h2 { font-size: clamp(1.6rem, 3vw, 2.4rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 10px; }
.strategy-meta p { color: var(--text-secondary); font-size: 1rem; line-height: 1.7; max-width: 680px; }
.strategy-tag { display: inline-block; padding: 3px 10px; border-radius: 20px; font-size: 11px; font-weight: 600; letter-spacing: 0.06em; text-transform: uppercase; margin-bottom: 12px; }
.tag-reliable { background: rgba(34,197,94,0.12); color: #4ADE80; border: 1px solid rgba(34,197,94,0.2); }
.tag-advanced { background: rgba(96,165,250,0.12); color: #60A5FA; border: 1px solid rgba(96,165,250,0.2); }
.tag-quant { background: rgba(251,146,60,0.12); color: #FB923C; border: 1px solid rgba(251,146,60,0.2); }

/* CODE BLOCK */
.code-block { background: rgba(0,0,0,0.45); border: 1px solid var(--border); border-radius: var(--radius); padding: 28px; font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 13px; line-height: 1.75; overflow-x: auto; position: relative; }
.code-block .code-header { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
.code-dot { width: 12px; height: 12px; border-radius: 50%; }
.code-dot.red { background: #EF4444; }
.code-dot.yellow { background: #FBBF24; }
.code-dot.green { background: #22C55E; }
.code-filename { margin-left: 8px; font-size: 12px; color: var(--text-muted); }
.kw { color: #C084FC; }
.fn { color: #93C5FD; }
.st { color: #86EFAC; }
.cm { color: var(--text-muted); font-style: italic; }
.num { color: #FDE68A; }
.cls { color: #F9A8D4; }
.at { color: #A855F7; }

/* GRID */
.grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; }
.grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; }
@media (max-width: 900px) { .grid-3 { grid-template-columns: repeat(2, 1fr); } }
@media (max-width: 768px) { .grid-2, .grid-3 { grid-template-columns: 1fr; } }

/* CARDS */
.card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); padding: 32px; transition: all 0.3s ease; }
.card:hover { background: var(--bg-card-hover); border-color: var(--border-hover); transform: translateY(-4px); box-shadow: 0 20px 60px rgba(0,0,0,0.4), 0 0 30px rgba(168,85,247,0.05); }
.card-icon { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 22px; margin-bottom: 20px; }
.card-icon.purple { background: rgba(168,85,247,0.15); }
.card-icon.blue { background: rgba(96,165,250,0.15); }
.card-icon.green { background: rgba(34,197,94,0.15); }
.card-icon.orange { background: rgba(251,146,60,0.15); }
.card h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; }
.card p { color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6; }

/* STAT ROW */
.stat-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 48px 0; }
@media (max-width: 768px) { .stat-row { grid-template-columns: repeat(2, 1fr); } }
.stat-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 24px; text-align: center; }
.stat-value { font-size: 2rem; font-weight: 800; color: var(--purple); letter-spacing: -0.02em; }
.stat-label { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; text-transform: uppercase; letter-spacing: 0.06em; font-weight: 500; }

/* PROSE */
.prose { max-width: 800px; }
.prose h3 { font-size: 1.15rem; font-weight: 600; margin-bottom: 12px; margin-top: 32px; color: var(--text); }
.prose p { color: var(--text-secondary); font-size: 1rem; line-height: 1.8; margin-bottom: 20px; }
.prose ul, .prose ol { color: var(--text-secondary); font-size: 1rem; line-height: 1.8; margin-bottom: 20px; padding-left: 24px; }
.prose li { margin-bottom: 8px; }
.prose strong { color: var(--text); font-weight: 600; }
.prose code { font-family: 'JetBrains Mono', monospace; font-size: 0.875em; background: rgba(168,85,247,0.1); color: var(--purple); padding: 2px 7px; border-radius: 4px; }

/* FORMULA */
.formula-block { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-left: 3px solid var(--purple); border-radius: var(--radius-sm); padding: 20px 24px; font-family: 'JetBrains Mono', monospace; font-size: 13px; color: var(--text-secondary); margin: 24px 0; line-height: 1.9; }
.formula-block .highlight { color: var(--purple); font-weight: 600; }

/* INFO / WARNING */
.info-box { background: rgba(168,85,247,0.06); border: 1px solid rgba(168,85,247,0.2); border-radius: var(--radius-sm); padding: 20px 24px; margin: 24px 0; }
.info-box p { color: var(--text-secondary); font-size: 0.95rem; margin: 0; line-height: 1.7; }
.info-box strong { color: var(--purple); }
.warning-box { background: rgba(251,146,60,0.06); border: 1px solid rgba(251,146,60,0.25); border-radius: var(--radius-sm); padding: 20px 24px; margin: 24px 0; }
.warning-box .warning-title { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: #FB923C; margin-bottom: 8px; }
.warning-box p { color: var(--text-secondary); font-size: 0.95rem; margin: 0; line-height: 1.7; }

/* RISK TABLE */
.risk-table { width: 100%; border-collapse: collapse; margin: 32px 0; }
.risk-table th { text-align: left; padding: 12px 16px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); border-bottom: 1px solid var(--border); }
.risk-table td { padding: 14px 16px; font-size: 14px; border-bottom: 1px solid rgba(255,255,255,0.03); color: var(--text-secondary); vertical-align: top; }
.risk-table tr:hover td { background: var(--bg-card); }
.risk-table .risk-high { color: #EF4444; font-weight: 600; }
.risk-table .risk-med { color: #FBBF24; font-weight: 600; }
.risk-table .risk-low { color: #4ADE80; font-weight: 600; }

/* PERF TABLE */
.perf-table { width: 100%; border-collapse: collapse; margin: 32px 0; }
.perf-table th { text-align: left; padding: 12px 16px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); border-bottom: 1px solid var(--border); }
.perf-table td { padding: 14px 16px; font-size: 14px; border-bottom: 1px solid rgba(255,255,255,0.03); color: var(--text-secondary); }
.perf-table tr:hover td { background: var(--bg-card); }
.perf-table .positive { color: #4ADE80; font-weight: 600; }

/* CTA */
.cta-section { text-align: center; padding: 100px 0; }
.cta-box { background: linear-gradient(135deg, rgba(168,85,247,0.08) 0%, rgba(124,58,237,0.05) 100%); border: 1px solid rgba(168,85,247,0.2); border-radius: 24px; padding: 80px 40px; position: relative; overflow: hidden; }
.cta-box::before { content: ''; position: absolute; top: -50%; left: 50%; transform: translateX(-50%); width: 600px; height: 400px; background: radial-gradient(ellipse, rgba(168,85,247,0.1) 0%, transparent 70%); filter: blur(40px); pointer-events: none; }
.cta-box h2 { font-size: clamp(2rem, 4vw, 3rem); font-weight: 800; letter-spacing: -0.02em; margin-bottom: 20px; position: relative; }
.cta-box p { color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 40px; position: relative; }
.cta-apis { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; margin-bottom: 40px; position: relative; }
.cta-api-pill { display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px; background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 100px; font-size: 13px; color: var(--text-secondary); }
.cta-api-pill .dot { width: 6px; height: 6px; border-radius: 50%; background: #4ADE80; }

/* FOOTER */
footer { padding: 60px 0 40px; border-top: 1px solid var(--border); }
.footer-top { display: grid; grid-template-columns: 1fr 2fr; gap: 60px; margin-bottom: 60px; }
.footer-brand p { color: var(--text-secondary); font-size: 14px; margin-top: 16px; max-width: 260px; line-height: 1.6; }
.footer-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; }
.footer-col h4 { font-size: 13px; font-weight: 600; margin-bottom: 16px; }
.footer-col ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
.footer-col a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-col a:hover { color: var(--text); }
.footer-bottom { display: flex; align-items: center; justify-content: space-between; padding-top: 24px; border-top: 1px solid var(--border); }
.footer-bottom p { color: var(--text-muted); font-size: 13px; }
.footer-social { display: flex; gap: 24px; }
.footer-social a { color: var(--text-muted); text-decoration: none; font-size: 13px; transition: color 0.2s; }
.footer-social a:hover { color: var(--text); }
@media (max-width: 768px) { .footer-top { grid-template-columns: 1fr; gap: 40px; } .footer-columns { grid-template-columns: repeat(2, 1fr); } .footer-bottom { flex-direction: column; gap: 16px; text-align: center; } }

/* RELATED */
.related-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
@media (max-width: 768px) { .related-grid { grid-template-columns: 1fr; } }
.related-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 20px 24px; text-decoration: none; color: var(--text); display: block; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); background: var(--bg-card-hover); transform: translateY(-2px); }
.related-card .label { font-size: 11px; color: var(--purple); font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 6px; }
.related-card .title { font-size: 14px; font-weight: 600; }
.related-card .desc { font-size: 13px; color: var(--text-muted); margin-top: 4px; }
</style>
</head>
<body>

<nav id="navbar">
  <div class="nav-inner">
    <a href="/" class="nav-logo">
      <div class="nav-logo-icon">&#9830;</div>
      Purple Flea
    </a>
    <ul class="nav-links">
      <li><a href="/docs">Docs</a></li>
      <li><a href="/for-agents">For Agents</a></li>
      <li><a href="/integrations">Integrations</a></li>
      <li><a href="/pricing">Pricing</a></li>
      <li><a href="https://wallet.purpleflea.com" target="_blank" class="nav-cta">Get Started &rarr;</a></li>
    </ul>
  </div>
</nav>

<!-- HERO -->
<section class="hero">
  <div class="hero-bg">
    <div class="hero-gradient-1"></div>
    <div class="hero-grid"></div>
  </div>
  <div class="hero-content">
    <div class="hero-badge">
      <div class="hero-badge-dot"></div>
      Crypto Arbitrage Agent
    </div>
    <h1>Build a <span class="gradient">Profitable<br>Arbitrage Bot</span></h1>
    <p class="hero-desc">
      Three proven strategies â€” funding rate arbitrage, cross-chain price arb, and statistical arb â€” with complete Python code, backtesting, and production deployment. Powered by Purple Flea's Trading and Wallet APIs.
    </p>
    <div class="hero-actions">
      <a href="https://trading.purpleflea.com" class="btn-primary" target="_blank">Start Trading &rarr;</a>
      <a href="https://wallet.purpleflea.com" class="btn-secondary" target="_blank">Wallet API</a>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- OVERVIEW STATS -->
<section style="padding: 60px 0;">
  <div class="container">
    <div class="stat-row reveal">
      <div class="stat-card">
        <div class="stat-value">275+</div>
        <div class="stat-label">Perp Markets</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">50x</div>
        <div class="stat-label">Max Leverage</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">8h</div>
        <div class="stat-label">Funding Cycle</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">8+</div>
        <div class="stat-label">Chains Supported</div>
      </div>
    </div>
    <div class="prose reveal reveal-delay-1">
      <p>
        Purple Flea gives your agent two dedicated APIs: <strong>trading.purpleflea.com</strong> for perpetual futures (275+ markets, real-time funding rates, up to 50x leverage) and <strong>wallet.purpleflea.com</strong> for multi-chain HD wallets and cross-chain swaps. Together, they cover every leg of every major arbitrage strategy without managing six separate exchange SDKs or bridging complexity.
      </p>
      <p>
        The strategies below are ordered by reliability and ease of implementation. Funding rate arbitrage is the safest starting point. Cross-chain price arb has higher edge but requires faster execution. Statistical arbitrage carries directional risk and is best for quant-oriented builders.
      </p>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY A: FUNDING RATE ARBITRAGE -->
<section id="funding-rate">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy A</div>
      <div class="strategy-header">
        <div class="strategy-number">01</div>
        <div class="strategy-meta">
          <div class="strategy-tag tag-reliable">Most Reliable</div>
          <h2>Funding Rate Arbitrage</h2>
          <p>When BTC perpetual futures funding exceeds 0.05% per 8-hour period, go long spot and short the perp in equal size. Your position is delta-neutral â€” you profit from the funding payment regardless of price direction.</p>
        </div>
      </div>
    </div>

    <div class="prose reveal reveal-delay-1">
      <h3>Theory</h3>
      <p>
        Perpetual futures do not expire, so exchanges use a funding rate mechanism to keep their price anchored to spot. When the perp trades above spot â€” almost always during bull markets â€” longs pay shorts every 8 hours. The rate is typically 0.01% per period at equilibrium, but can spike to 0.1%&ndash;0.3% during frenzied markets.
      </p>
      <p>
        By holding equal-and-opposite positions â€” long spot BTC on the wallet side, short BTC-PERP on the trading side â€” your net BTC exposure is zero. You cannot be liquidated by price movement because both positions move in opposite directions. Your only exposure is the funding rate itself reversing to negative.
      </p>

      <h3>The Math</h3>
    </div>

    <div class="formula-block reveal reveal-delay-1">
      Position size: $10,000<br>
      Funding rate: 0.1% per 8h period<br><br>
      <span class="highlight">Gross income per period = $10,000 &times; 0.001 = $10.00</span><br>
      Periods per day: 3<br>
      <span class="highlight">Daily income = $10 &times; 3 = $30.00</span><br>
      <span class="highlight">Monthly income = $30 &times; 30 = $900.00</span><br>
      Annual yield on $10k = 108%<br><br>
      At a more conservative 0.05% rate:<br>
      Daily = $15 &nbsp;&nbsp; Monthly = $450 &nbsp;&nbsp; Annual yield = 54%<br><br>
      Costs: exchange fee ~0.02% per leg (paid once on entry and exit)<br>
      Break-even funding rate to cover entry+exit costs: ~0.005%
    </div>

    <div class="info-box reveal reveal-delay-1">
      <p><strong>Why this works:</strong> Bull markets create sustained demand for leveraged long exposure. Retail traders pay a premium to hold long perp positions rather than buying spot. Your bot extracts this premium as passive income while remaining completely market-neutral.</p>
    </div>

    <div class="reveal reveal-delay-2" style="margin-top: 48px;">
      <div style="margin-bottom: 16px;">
        <div class="section-label">Python Implementation</div>
        <h3 style="font-size: 1.3rem; font-weight: 700; margin-bottom: 8px;">Funding Rate Monitor Bot</h3>
        <p style="color: var(--text-secondary); font-size: 0.95rem; margin-bottom: 20px;">Polls the top 10 funding rates every 8 hours, opens a delta-neutral position when rate exceeds 0.05%, and closes when rate falls below 0.01%. Enforces a 20% max portfolio allocation per trade.</p>
      </div>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">funding_arb_bot.py</span>
        </div>
<span class="kw">import</span> requests, time, logging
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass
<span class="kw">from</span> typing <span class="kw">import</span> <span class="cls">Optional</span>

logging.<span class="fn">basicConfig</span>(level=logging.INFO, format=<span class="st">"%(asctime)s %(levelname)s %(message)s"</span>)
log = logging.<span class="fn">getLogger</span>(<span class="st">"funding_arb"</span>)

TRADING_API  = <span class="st">"https://trading.purpleflea.com"</span>
WALLET_API   = <span class="st">"https://wallet.purpleflea.com"</span>
TRADING_KEY  = <span class="st">"pf_trade_sk_..."</span>
WALLET_KEY   = <span class="st">"pf_wallet_sk_..."</span>

OPEN_THRESHOLD  = <span class="num">0.0005</span>   <span class="cm"># 0.05% per 8h - enter position</span>
CLOSE_THRESHOLD = <span class="num">0.0001</span>   <span class="cm"># 0.01% per 8h - exit position</span>
MAX_ALLOC_PCT   = <span class="num">0.20</span>     <span class="cm"># max 20% of portfolio in any single trade</span>
CHECK_INTERVAL  = <span class="num">28800</span>    <span class="cm"># 8 hours in seconds</span>
TOP_N_MARKETS   = <span class="num">10</span>       <span class="cm"># scan top N markets by funding rate</span>

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">Position</span>:
    coin: <span class="cls">str</span>
    size_usd: <span class="cls">float</span>
    entry_funding_rate: <span class="cls">float</span>
    perp_position_id: <span class="cls">str</span>
    spot_amount: <span class="cls">float</span>
    total_funding_earned: <span class="cls">float</span> = <span class="num">0.0</span>

<span class="kw">def</span> <span class="fn">trading_get</span>(path: <span class="cls">str</span>, params: <span class="cls">dict</span> = <span class="kw">None</span>) -&gt; <span class="cls">dict</span>:
    r = requests.<span class="fn">get</span>(<span class="st">f"{TRADING_API}{path}"</span>, params=params,
                     headers={<span class="st">"Authorization"</span>: <span class="st">f"Bearer {TRADING_KEY}"</span>}, timeout=<span class="num">10</span>)
    r.<span class="fn">raise_for_status</span>()
    <span class="kw">return</span> r.<span class="fn">json</span>()

<span class="kw">def</span> <span class="fn">trading_post</span>(path: <span class="cls">str</span>, body: <span class="cls">dict</span>) -&gt; <span class="cls">dict</span>:
    r = requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}{path}"</span>, json=body,
                      headers={<span class="st">"Authorization"</span>: <span class="st">f"Bearer {TRADING_KEY}"</span>}, timeout=<span class="num">10</span>)
    r.<span class="fn">raise_for_status</span>()
    <span class="kw">return</span> r.<span class="fn">json</span>()

<span class="kw">def</span> <span class="fn">wallet_post</span>(path: <span class="cls">str</span>, body: <span class="cls">dict</span>) -&gt; <span class="cls">dict</span>:
    r = requests.<span class="fn">post</span>(<span class="st">f"{WALLET_API}{path}"</span>, json=body,
                      headers={<span class="st">"Authorization"</span>: <span class="st">f"Bearer {WALLET_KEY}"</span>}, timeout=<span class="num">15</span>)
    r.<span class="fn">raise_for_status</span>()
    <span class="kw">return</span> r.<span class="fn">json</span>()

<span class="kw">def</span> <span class="fn">get_portfolio_value</span>() -&gt; <span class="cls">float</span>:
    <span class="cm"># GET /v1/wallet/balance - returns total_usd across all chains</span>
    data = requests.<span class="fn">get</span>(<span class="st">f"{WALLET_API}/v1/wallet/balance"</span>,
                       headers={<span class="st">"Authorization"</span>: <span class="st">f"Bearer {WALLET_KEY}"</span>}).<span class="fn">json</span>()
    <span class="kw">return</span> data[<span class="st">"total_usd"</span>]

<span class="kw">def</span> <span class="fn">get_top_funding_markets</span>() -&gt; <span class="cls">list</span>[<span class="cls">dict</span>]:
    <span class="cm"># GET /v1/markets - returns coins with funding_rate and mark_price</span>
    markets = <span class="fn">trading_get</span>(<span class="st">"/v1/markets"</span>)
    positive = [m <span class="kw">for</span> m <span class="kw">in</span> markets <span class="kw">if</span> m[<span class="st">"funding_rate"</span>] &gt; OPEN_THRESHOLD]
    <span class="kw">return</span> <span class="fn">sorted</span>(positive, key=<span class="kw">lambda</span> x: x[<span class="st">"funding_rate"</span>], reverse=<span class="kw">True</span>)[:TOP_N_MARKETS]

<span class="kw">def</span> <span class="fn">open_funding_arb</span>(coin: <span class="cls">str</span>, funding_rate: <span class="cls">float</span>,
                      mark_price: <span class="cls">float</span>) -&gt; <span class="cls">Optional</span>[<span class="cls">Position</span>]:
    portfolio = <span class="fn">get_portfolio_value</span>()
    size_usd  = <span class="fn">min</span>(portfolio * MAX_ALLOC_PCT, <span class="num">10000</span>)
    coin_amt  = size_usd / mark_price

    log.<span class="fn">info</span>(<span class="st">f"Opening arb: {coin} rate={funding_rate:.4%} size=${size_usd:.0f}"</span>)

    <span class="cm"># Leg 1: buy spot via Wallet API - POST /v1/wallet/swap</span>
    spot = <span class="fn">wallet_post</span>(<span class="st">"/v1/wallet/swap"</span>, {
        <span class="st">"from_token"</span>: <span class="st">"USDC"</span>, <span class="st">"to_token"</span>: coin,
        <span class="st">"amount_usd"</span>: size_usd, <span class="st">"max_slippage_pct"</span>: <span class="num">0.3</span>
    })

    <span class="cm"># Leg 2: short equal notional on perp - POST /v1/trade/open</span>
    perp = <span class="fn">trading_post</span>(<span class="st">"/v1/trade/open"</span>, {
        <span class="st">"coin"</span>: coin, <span class="st">"side"</span>: <span class="st">"sell"</span>,
        <span class="st">"size_usd"</span>: size_usd, <span class="st">"leverage"</span>: <span class="num">1</span>,
        <span class="st">"order_type"</span>: <span class="st">"market"</span>
    })

    log.<span class="fn">info</span>(<span class="st">f"Arb open: spot tx={spot['tx_hash'][:12]}... perp id={perp['position_id']}"</span>)
    <span class="kw">return</span> <span class="cls">Position</span>(coin=coin, size_usd=size_usd,
                   entry_funding_rate=funding_rate,
                   perp_position_id=perp[<span class="st">"position_id"</span>],
                   spot_amount=coin_amt)

<span class="kw">def</span> <span class="fn">close_funding_arb</span>(pos: <span class="cls">Position</span>):
    log.<span class="fn">info</span>(<span class="st">f"Closing arb: {pos.coin} total_earned=${pos.total_funding_earned:.2f}"</span>)
    <span class="cm"># POST /v1/trade/close</span>
    <span class="fn">trading_post</span>(<span class="st">"/v1/trade/close"</span>, {<span class="st">"position_id"</span>: pos.perp_position_id})
    <span class="cm"># POST /v1/wallet/swap - sell spot back to USDC</span>
    <span class="fn">wallet_post</span>(<span class="st">"/v1/wallet/swap"</span>, {
        <span class="st">"from_token"</span>: pos.coin, <span class="st">"to_token"</span>: <span class="st">"USDC"</span>,
        <span class="st">"amount_tokens"</span>: pos.spot_amount, <span class="st">"max_slippage_pct"</span>: <span class="num">0.3</span>
    })

<span class="kw">def</span> <span class="fn">run_funding_bot</span>():
    active: <span class="cls">dict</span>[<span class="cls">str</span>, <span class="cls">Position</span>] = {}

    <span class="kw">while True</span>:
        <span class="kw">try</span>:
            markets = <span class="fn">trading_get</span>(<span class="st">"/v1/markets"</span>)
            rates   = {m[<span class="st">"coin"</span>]: m <span class="kw">for</span> m <span class="kw">in</span> markets}

            <span class="cm"># Check existing positions - close if rate dropped below threshold</span>
            <span class="kw">for</span> coin, pos <span class="kw">in</span> <span class="fn">list</span>(active.<span class="fn">items</span>()):
                rate    = rates.<span class="fn">get</span>(coin, {}).<span class="fn">get</span>(<span class="st">"funding_rate"</span>, <span class="num">0</span>)
                earned  = pos.size_usd * rate
                pos.total_funding_earned += earned
                log.<span class="fn">info</span>(<span class="st">f"{coin} rate={rate:.4%} earned=${earned:.2f}"</span>)
                <span class="kw">if</span> rate &lt; CLOSE_THRESHOLD:
                    <span class="fn">close_funding_arb</span>(pos)
                    <span class="kw">del</span> active[coin]

            <span class="cm"># Open new positions for high-rate markets not already held</span>
            <span class="kw">for</span> m <span class="kw">in</span> <span class="fn">get_top_funding_markets</span>():
                <span class="kw">if</span> m[<span class="st">"coin"</span>] <span class="kw">not in</span> active:
                    pos = <span class="fn">open_funding_arb</span>(m[<span class="st">"coin"</span>],
                                             m[<span class="st">"funding_rate"</span>],
                                             m[<span class="st">"mark_price"</span>])
                    <span class="kw">if</span> pos:
                        active[m[<span class="st">"coin"</span>]] = pos

        <span class="kw">except Exception</span> <span class="kw">as</span> e:
            log.<span class="fn">error</span>(<span class="st">f"Bot error: {e}"</span>)

        time.<span class="fn">sleep</span>(CHECK_INTERVAL)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="fn">run_funding_bot</span>()
      </div>
    </div>

    <div class="warning-box reveal reveal-delay-2" style="margin-top: 32px;">
      <div class="warning-title">Risk: Funding Rate Flip</div>
      <p>Funding rates can turn negative within a single period during market reversals. When negative, shorts pay longs â€” your bot would be paying rather than earning. Monitor rates in real time and close any position if its funding rate stays below -0.01% for two consecutive periods.</p>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY B: CROSS-CHAIN PRICE ARBITRAGE -->
<section id="cross-chain">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy B</div>
      <div class="strategy-header">
        <div class="strategy-number">02</div>
        <div class="strategy-meta">
          <div class="strategy-tag tag-advanced">Cross-Chain</div>
          <h2>Cross-Chain Price Arbitrage</h2>
          <p>The same token can trade at meaningfully different prices on different chains and DEXs simultaneously. Your agent scans across chains using Purple Flea's Wallet API quotes, then executes on both sides within a single API session.</p>
        </div>
      </div>
    </div>

    <div class="prose reveal reveal-delay-1">
      <h3>Theory</h3>
      <p>
        Cross-chain arbitrage exploits temporary price divergences that arise from imbalanced liquidity pools. If USDC buys 0.003318 ETH on Arbitrum but only 0.003305 ETH on Ethereum mainnet, there is a 0.39% spread. After bridging costs and gas, a fast agent with pre-positioned capital on both chains can capture this without bridging at all â€” simply sell on the expensive side and buy on the cheap side, rebalancing later when the spread has closed.
      </p>
      <p>
        Purple Flea's Wallet API provides a <code>GET /v1/wallet/balance</code> endpoint that returns balances across all chains in a single call, and <code>POST /v1/wallet/swap</code> executes on any chain you specify. Your agent does not need per-chain RPC connections or separate gas wallets.
      </p>
    </div>

    <div class="reveal reveal-delay-2" style="margin-top: 32px;">
      <div style="margin-bottom: 16px;">
        <div class="section-label">Python Implementation</div>
        <h3 style="font-size: 1.3rem; font-weight: 700; margin-bottom: 8px;">Cross-Chain Price Scanner</h3>
        <p style="color: var(--text-secondary); font-size: 0.95rem; margin-bottom: 20px;">Queries swap quotes across all supported chains simultaneously and identifies spreads worth executing. Uses pre-positioned capital â€” no bridging in the hot path.</p>
      </div>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">cross_chain_scanner.py</span>
        </div>
<span class="kw">import</span> asyncio, aiohttp, logging
<span class="kw">from</span> itertools <span class="kw">import</span> combinations

WALLET_API = <span class="st">"https://wallet.purpleflea.com"</span>
WALLET_KEY = <span class="st">"pf_wallet_sk_..."</span>
HEADERS    = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {WALLET_KEY}"</span>}
MIN_SPREAD = <span class="num">0.30</span>   <span class="cm"># minimum net spread % to execute</span>
TRADE_USD  = <span class="num">500</span>    <span class="cm"># USDC per trade leg</span>
CHAINS     = [<span class="st">"ethereum"</span>, <span class="st">"arbitrum"</span>, <span class="st">"optimism"</span>, <span class="st">"polygon"</span>, <span class="st">"base"</span>]
TOKENS     = [<span class="st">"ETH"</span>, <span class="st">"WBTC"</span>, <span class="st">"LINK"</span>, <span class="st">"UNI"</span>]

GAS_COST_USD = {
    <span class="st">"ethereum"</span>: <span class="num">12.0</span>, <span class="st">"arbitrum"</span>: <span class="num">0.30</span>,
    <span class="st">"optimism"</span>: <span class="num">0.25</span>, <span class="st">"polygon"</span>: <span class="num">0.05</span>, <span class="st">"base"</span>: <span class="num">0.20</span>
}

<span class="kw">async def</span> <span class="fn">get_quote</span>(session: aiohttp.<span class="cls">ClientSession</span>,
                    token: <span class="cls">str</span>, chain: <span class="cls">str</span>) -&gt; <span class="cls">float</span>:
    <span class="cm"># GET /v1/wallet/address with quote params - tokens received per $1 USDC</span>
    <span class="kw">async with</span> session.<span class="fn">get</span>(
        <span class="st">f"{WALLET_API}/v1/wallet/address"</span>,
        params={<span class="st">"from"</span>: <span class="st">"USDC"</span>, <span class="st">"to"</span>: token,
                <span class="st">"amount_usd"</span>: TRADE_USD, <span class="st">"chain"</span>: chain},
        headers=HEADERS,
        timeout=aiohttp.<span class="cls">ClientTimeout</span>(total=<span class="num">5</span>)
    ) <span class="kw">as</span> r:
        d = <span class="kw">await</span> r.<span class="fn">json</span>()
        <span class="kw">return</span> d[<span class="st">"out_amount"</span>] / TRADE_USD

<span class="kw">async def</span> <span class="fn">scan_token</span>(session: aiohttp.<span class="cls">ClientSession</span>,
                      token: <span class="cls">str</span>) -&gt; <span class="cls">list</span>:
    tasks  = [<span class="fn">get_quote</span>(session, token, chain) <span class="kw">for</span> chain <span class="kw">in</span> CHAINS]
    prices = <span class="kw">await</span> asyncio.<span class="fn">gather</span>(*tasks, return_exceptions=<span class="kw">True</span>)
    <span class="kw">return</span> [
        {<span class="st">"token"</span>: token, <span class="st">"chain"</span>: chain, <span class="st">"rate"</span>: price}
        <span class="kw">for</span> chain, price <span class="kw">in</span> <span class="fn">zip</span>(CHAINS, prices)
        <span class="kw">if</span> <span class="fn">isinstance</span>(price, <span class="cls">float</span>)
    ]

<span class="kw">async def</span> <span class="fn">find_opportunities</span>() -&gt; <span class="cls">list</span>[<span class="cls">dict</span>]:
    opportunities = []
    <span class="kw">async with</span> aiohttp.<span class="fn">ClientSession</span>() <span class="kw">as</span> session:
        <span class="kw">for</span> token <span class="kw">in</span> TOKENS:
            quotes = <span class="kw">await</span> <span class="fn">scan_token</span>(session, token)
            <span class="kw">for</span> q1, q2 <span class="kw">in</span> <span class="fn">combinations</span>(quotes, <span class="num">2</span>):
                cheap, dear = <span class="fn">sorted</span>([q1, q2],
                    key=<span class="kw">lambda</span> x: x[<span class="st">"rate"</span>], reverse=<span class="kw">True</span>)
                spread_pct = (cheap[<span class="st">"rate"</span>] - dear[<span class="st">"rate"</span>]) / dear[<span class="st">"rate"</span>] * <span class="num">100</span>
                gas_total  = GAS_COST_USD[cheap[<span class="st">"chain"</span>]] + GAS_COST_USD[dear[<span class="st">"chain"</span>]]
                gas_pct    = gas_total / TRADE_USD * <span class="num">100</span>
                net_spread = spread_pct - gas_pct - <span class="num">0.1</span>
                <span class="kw">if</span> net_spread &gt;= MIN_SPREAD:
                    opportunities.<span class="fn">append</span>({
                        <span class="st">"token"</span>:              token,
                        <span class="st">"buy_chain"</span>:          cheap[<span class="st">"chain"</span>],
                        <span class="st">"sell_chain"</span>:         dear[<span class="st">"chain"</span>],
                        <span class="st">"gross_spread_pct"</span>:   <span class="fn">round</span>(spread_pct, <span class="num">3</span>),
                        <span class="st">"net_spread_pct"</span>:     <span class="fn">round</span>(net_spread, <span class="num">3</span>),
                        <span class="st">"expected_profit_usd"</span>:<span class="fn">round</span>(TRADE_USD * net_spread / <span class="num">100</span>, <span class="num">2</span>),
                    })
    <span class="kw">return</span> <span class="fn">sorted</span>(opportunities,
                   key=<span class="kw">lambda</span> x: x[<span class="st">"net_spread_pct"</span>], reverse=<span class="kw">True</span>)

<span class="kw">async def</span> <span class="fn">execute_cross_chain_arb</span>(opp: <span class="cls">dict</span>):
    <span class="kw">async with</span> aiohttp.<span class="fn">ClientSession</span>() <span class="kw">as</span> session:
        <span class="cm"># Buy on cheap chain - POST /v1/wallet/swap</span>
        buy = <span class="kw">await</span> session.<span class="fn">post</span>(<span class="st">f"{WALLET_API}/v1/wallet/swap"</span>,
            headers=HEADERS, json={
                <span class="st">"from_token"</span>: <span class="st">"USDC"</span>, <span class="st">"to_token"</span>: opp[<span class="st">"token"</span>],
                <span class="st">"amount_usd"</span>: TRADE_USD, <span class="st">"chain"</span>: opp[<span class="st">"buy_chain"</span>],
                <span class="st">"max_slippage_pct"</span>: <span class="num">0.5</span>
            })
        buy_data = <span class="kw">await</span> buy.<span class="fn">json</span>()

        <span class="cm"># Sell on expensive chain (pre-positioned token balance)</span>
        sell = <span class="kw">await</span> session.<span class="fn">post</span>(<span class="st">f"{WALLET_API}/v1/wallet/swap"</span>,
            headers=HEADERS, json={
                <span class="st">"from_token"</span>: opp[<span class="st">"token"</span>], <span class="st">"to_token"</span>: <span class="st">"USDC"</span>,
                <span class="st">"amount_usd"</span>: TRADE_USD, <span class="st">"chain"</span>: opp[<span class="st">"sell_chain"</span>],
                <span class="st">"max_slippage_pct"</span>: <span class="num">0.5</span>
            })
        logging.<span class="fn">info</span>(<span class="st">f"Executed {opp['token']}: "
                      <span class="st">f"buy={opp['buy_chain']} sell={opp['sell_chain']} "
                      <span class="st">f"net={opp['net_spread_pct']}%"</span>)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    opps = asyncio.<span class="fn">run</span>(<span class="fn">find_opportunities</span>())
    <span class="kw">for</span> o <span class="kw">in</span> opps:
        <span class="fn">print</span>(<span class="st">f"{o['token']:6} {o['buy_chain']:10} -&gt; {o['sell_chain']:10} "
              <span class="st">f"net={o['net_spread_pct']:.2f}% profit=${o['expected_profit_usd']}"</span>)
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- STRATEGY C: STATISTICAL ARBITRAGE -->
<section id="stat-arb">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Strategy C</div>
      <div class="strategy-header">
        <div class="strategy-number">03</div>
        <div class="strategy-meta">
          <div class="strategy-tag tag-quant">Quantitative</div>
          <h2>Statistical Arbitrage (BTC/ETH Spread)</h2>
          <p>BTC and ETH are highly correlated historically. When their log-price ratio deviates significantly from its rolling mean, a reversion trade captures the spread as it normalizes. Z-score above 2 triggers entry; z-score below 0.5 triggers exit.</p>
        </div>
      </div>
    </div>

    <div class="prose reveal reveal-delay-1">
      <h3>Theory</h3>
      <p>
        Statistical arbitrage assumes that historically correlated assets will continue to co-move. The BTC/ETH log-price ratio has a long-run mean driven by their relative market caps and network utility. When ETH dramatically outperforms BTC over a short period, the ratio deviates above its mean â€” stat arb goes long BTC and short ETH, betting the ratio mean-reverts.
      </p>
      <p>
        The z-score measures how many standard deviations the current spread is from its rolling mean. A z-score of +2 means the spread is two standard deviations above average â€” historically a reliable reversal signal. The position is closed when the z-score returns to 0.5 or crosses zero.
      </p>
    </div>

    <div class="formula-block reveal reveal-delay-1">
      spread_t = log(BTC_price) - log(ETH_price)<br>
      z_score  = (spread_t - mean(spread, window)) / std(spread, window)<br><br>
      <span class="highlight">Enter LONG BTC + SHORT ETH when z_score &lt; -2.0</span><br>
      <span class="highlight">Enter SHORT BTC + LONG ETH when z_score &gt; +2.0</span><br>
      <span class="highlight">Exit all positions when abs(z_score) &lt; 0.5</span><br><br>
      Rolling window: 30 days (720 hourly candles)<br>
      Position sizing: equal notional - $5k BTC + $5k ETH per side<br>
      Stop loss: z-score &gt; 3.5 (spread widening instead of reverting)
    </div>

    <div class="reveal reveal-delay-2" style="margin-top: 32px;">
      <div style="margin-bottom: 16px;">
        <div class="section-label">Python Implementation</div>
        <h3 style="font-size: 1.3rem; font-weight: 700; margin-bottom: 8px;">Z-Score Mean Reversion Bot</h3>
        <p style="color: var(--text-secondary); font-size: 0.95rem; margin-bottom: 20px;">Computes the BTC/ETH log-price z-score every hour and executes perp trades via the Trading API when thresholds are crossed.</p>
      </div>
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">stat_arb_bot.py</span>
        </div>
<span class="kw">import</span> requests, math, time, logging
<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">from</span> statistics <span class="kw">import</span> mean, stdev

TRADING_API = <span class="st">"https://trading.purpleflea.com"</span>
TRADING_KEY = <span class="st">"pf_trade_sk_..."</span>
HEADERS     = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {TRADING_KEY}"</span>}
WINDOW      = <span class="num">720</span>    <span class="cm"># 30 days of hourly candles</span>
ENTRY_Z     = <span class="num">2.0</span>    <span class="cm"># z-score threshold to open position</span>
EXIT_Z      = <span class="num">0.5</span>    <span class="cm"># z-score threshold to close position</span>
STOP_Z      = <span class="num">3.5</span>    <span class="cm"># emergency stop if spread keeps widening</span>
SIZE_USD    = <span class="num">5000</span>   <span class="cm"># notional per leg ($5k BTC + $5k ETH)</span>

spread_history: deque = <span class="fn">deque</span>(maxlen=WINDOW)
current_position: <span class="cls">dict</span> = {}

<span class="kw">def</span> <span class="fn">get_mark_prices</span>() -&gt; <span class="cls">tuple</span>[<span class="cls">float</span>, <span class="cls">float</span>]:
    <span class="cm"># GET /v1/markets - retrieve BTC and ETH mark_price</span>
    markets = requests.<span class="fn">get</span>(<span class="st">f"{TRADING_API}/v1/markets"</span>,
                            headers=HEADERS).<span class="fn">json</span>()
    prices  = {m[<span class="st">"coin"</span>]: m[<span class="st">"mark_price"</span>] <span class="kw">for</span> m <span class="kw">in</span> markets}
    <span class="kw">return</span> prices[<span class="st">"BTC"</span>], prices[<span class="st">"ETH"</span>]

<span class="kw">def</span> <span class="fn">compute_z_score</span>(btc: <span class="cls">float</span>, eth: <span class="cls">float</span>) -&gt; <span class="cls">float</span>:
    spread = math.<span class="fn">log</span>(btc) - math.<span class="fn">log</span>(eth)
    spread_history.<span class="fn">append</span>(spread)
    <span class="kw">if</span> <span class="fn">len</span>(spread_history) &lt; <span class="num">60</span>:
        <span class="kw">return</span> <span class="num">0.0</span>   <span class="cm"># not enough history yet</span>
    mu  = <span class="fn">mean</span>(spread_history)
    sig = <span class="fn">stdev</span>(spread_history)
    <span class="kw">return</span> (spread - mu) / sig <span class="kw">if</span> sig &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0.0</span>

<span class="kw">def</span> <span class="fn">open_position</span>(side: <span class="cls">str</span>) -&gt; <span class="cls">dict</span>:
    <span class="cm"># side = 'long_btc' means buy BTC perp + sell ETH perp</span>
    btc_side = <span class="st">"buy"</span>  <span class="kw">if</span> side == <span class="st">"long_btc"</span> <span class="kw">else</span> <span class="st">"sell"</span>
    eth_side = <span class="st">"sell"</span> <span class="kw">if</span> side == <span class="st">"long_btc"</span> <span class="kw">else</span> <span class="st">"buy"</span>

    btc_pos = requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}/v1/trade/open"</span>,
        headers=HEADERS,
        json={<span class="st">"coin"</span>: <span class="st">"BTC"</span>, <span class="st">"side"</span>: btc_side,
              <span class="st">"size_usd"</span>: SIZE_USD, <span class="st">"leverage"</span>: <span class="num">1</span>,
              <span class="st">"order_type"</span>: <span class="st">"market"</span>}).<span class="fn">json</span>()

    eth_pos = requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}/v1/trade/open"</span>,
        headers=HEADERS,
        json={<span class="st">"coin"</span>: <span class="st">"ETH"</span>, <span class="st">"side"</span>: eth_side,
              <span class="st">"size_usd"</span>: SIZE_USD, <span class="st">"leverage"</span>: <span class="num">1</span>,
              <span class="st">"order_type"</span>: <span class="st">"market"</span>}).<span class="fn">json</span>()

    logging.<span class="fn">info</span>(<span class="st">f"Opened {side}: BTC-{btc_side} ETH-{eth_side} ${SIZE_USD} each"</span>)
    <span class="kw">return</span> {<span class="st">"side"</span>: side,
            <span class="st">"btc_id"</span>: btc_pos[<span class="st">"position_id"</span>],
            <span class="st">"eth_id"</span>: eth_pos[<span class="st">"position_id"</span>]}

<span class="kw">def</span> <span class="fn">close_position</span>(pos: <span class="cls">dict</span>):
    <span class="kw">for</span> pid <span class="kw">in</span> [pos[<span class="st">"btc_id"</span>], pos[<span class="st">"eth_id"</span>]]:
        requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}/v1/trade/close"</span>,
                       headers=HEADERS,
                       json={<span class="st">"position_id"</span>: pid})
    logging.<span class="fn">info</span>(<span class="st">f"Closed position: {pos['side']}"</span>)

<span class="kw">def</span> <span class="fn">run_stat_arb</span>():
    <span class="kw">global</span> current_position
    <span class="kw">while True</span>:
        <span class="kw">try</span>:
            btc, eth = <span class="fn">get_mark_prices</span>()
            z = <span class="fn">compute_z_score</span>(btc, eth)
            logging.<span class="fn">info</span>(<span class="st">f"BTC={btc:.0f} ETH={eth:.2f} z={z:.3f}"</span>)

            <span class="kw">if</span> current_position:
                side = current_position[<span class="st">"side"</span>]
                reverted  = (<span class="fn">abs</span>(z) &lt; EXIT_Z)
                blown_out = (<span class="fn">abs</span>(z) &gt; STOP_Z)
                crossed   = ((side == <span class="st">"long_btc"</span> <span class="kw">and</span> z &gt; <span class="num">0</span>) <span class="kw">or</span>
                             (side == <span class="st">"long_eth"</span> <span class="kw">and</span> z &lt; <span class="num">0</span>))
                <span class="kw">if</span> reverted <span class="kw">or</span> blown_out <span class="kw">or</span> crossed:
                    <span class="fn">close_position</span>(current_position)
                    current_position = {}
            <span class="kw">else</span>:
                <span class="kw">if</span> z &lt; -ENTRY_Z:
                    current_position = <span class="fn">open_position</span>(<span class="st">"long_btc"</span>)
                <span class="kw">elif</span> z &gt; ENTRY_Z:
                    current_position = <span class="fn">open_position</span>(<span class="st">"long_eth"</span>)

        <span class="kw">except Exception</span> <span class="kw">as</span> e:
            logging.<span class="fn">error</span>(<span class="st">f"Stat arb error: {e}"</span>)

        time.<span class="fn">sleep</span>(<span class="num">3600</span>)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="fn">run_stat_arb</span>()
      </div>
    </div>

    <div class="warning-box reveal reveal-delay-2" style="margin-top: 24px;">
      <div class="warning-title">Risk: Correlation Breakdown</div>
      <p>BTC and ETH correlation is not guaranteed. During regulatory events, ETH-specific upgrades, or major ETF announcements, the correlation can break down for weeks. Always enforce the stop loss at z-score above 3.5 to limit drawdown if the spread continues widening instead of reverting.</p>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- PRODUCTION BOT -->
<section id="production-bot">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Production Code</div>
      <h2 class="section-title">Full Production-Ready Orchestrator</h2>
      <p class="section-desc">Combines all three strategies under a single loop with shared portfolio management, rate limiting, error handling, and a 20% max allocation rule enforced per trade.</p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">arb_orchestrator.py</span>
        </div>
<span class="kw">import</span> requests, time, math, logging
<span class="kw">from</span> collections <span class="kw">import</span> deque
<span class="kw">from</span> statistics <span class="kw">import</span> mean, stdev
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass, field
<span class="kw">from</span> typing <span class="kw">import</span> <span class="cls">Optional</span>

logging.<span class="fn">basicConfig</span>(level=logging.INFO,
    format=<span class="st">"%(asctime)s [%(name)s] %(levelname)s %(message)s"</span>)

TRADING_API  = <span class="st">"https://trading.purpleflea.com"</span>
WALLET_API   = <span class="st">"https://wallet.purpleflea.com"</span>
TRADING_KEY  = <span class="st">"pf_trade_sk_..."</span>
WALLET_KEY   = <span class="st">"pf_wallet_sk_..."</span>
MAX_ALLOC    = <span class="num">0.20</span>    <span class="cm"># max 20% of portfolio per trade</span>
FUNDING_OPEN = <span class="num">0.0005</span>  <span class="cm"># 0.05%/8h threshold to open</span>
FUNDING_CLOSE= <span class="num">0.0001</span>  <span class="cm"># 0.01%/8h threshold to close</span>
STAT_ENTRY_Z = <span class="num">2.0</span>
STAT_EXIT_Z  = <span class="num">0.5</span>
STAT_STOP_Z  = <span class="num">3.5</span>

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">BotState</span>:
    funding_positions: <span class="cls">dict</span>  = field(default_factory=<span class="cls">dict</span>)
    stat_position:     <span class="cls">Optional</span>[<span class="cls">dict</span>] = <span class="kw">None</span>
    spread_history:    deque = field(default_factory=<span class="kw">lambda</span>: <span class="fn">deque</span>(maxlen=<span class="num">720</span>))
    total_earned:      <span class="cls">float</span> = <span class="num">0.0</span>
    trade_count:       <span class="cls">int</span>   = <span class="num">0</span>

<span class="kw">class</span> <span class="cls">PFClient</span>:
    <span class="kw">def</span> __init__(self):
        self.t = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {TRADING_KEY}"</span>}
        self.w = {<span class="st">"Authorization"</span>: <span class="st">f"Bearer {WALLET_KEY}"</span>}

    <span class="kw">def</span> <span class="fn">portfolio_value</span>(self) -&gt; <span class="cls">float</span>:
        <span class="cm"># GET /v1/wallet/balance</span>
        <span class="kw">return</span> requests.<span class="fn">get</span>(<span class="st">f"{WALLET_API}/v1/wallet/balance"</span>,
                            headers=self.w, timeout=<span class="num">8</span>).<span class="fn">json</span>()[<span class="st">"total_usd"</span>]

    <span class="kw">def</span> <span class="fn">markets</span>(self) -&gt; <span class="cls">list</span>:
        <span class="cm"># GET /v1/markets - returns coins with funding_rate, mark_price</span>
        <span class="kw">return</span> requests.<span class="fn">get</span>(<span class="st">f"{TRADING_API}/v1/markets"</span>,
                            headers=self.t, timeout=<span class="num">8</span>).<span class="fn">json</span>()

    <span class="kw">def</span> <span class="fn">open_trade</span>(self, coin, side, size_usd, leverage=<span class="num">1</span>) -&gt; <span class="cls">dict</span>:
        <span class="cm"># POST /v1/trade/open</span>
        <span class="kw">return</span> requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}/v1/trade/open"</span>, headers=self.t,
            json={<span class="st">"coin"</span>: coin, <span class="st">"side"</span>: side,
                  <span class="st">"size_usd"</span>: size_usd, <span class="st">"leverage"</span>: leverage,
                  <span class="st">"order_type"</span>: <span class="st">"market"</span>}).<span class="fn">json</span>()

    <span class="kw">def</span> <span class="fn">close_trade</span>(self, position_id) -&gt; <span class="cls">dict</span>:
        <span class="cm"># POST /v1/trade/close</span>
        <span class="kw">return</span> requests.<span class="fn">post</span>(<span class="st">f"{TRADING_API}/v1/trade/close"</span>, headers=self.t,
            json={<span class="st">"position_id"</span>: position_id}).<span class="fn">json</span>()

    <span class="kw">def</span> <span class="fn">swap</span>(self, from_t, to_t, amount_usd, chain) -&gt; <span class="cls">dict</span>:
        <span class="cm"># POST /v1/wallet/swap</span>
        <span class="kw">return</span> requests.<span class="fn">post</span>(<span class="st">f"{WALLET_API}/v1/wallet/swap"</span>, headers=self.w,
            json={<span class="st">"from_token"</span>: from_t, <span class="st">"to_token"</span>: to_t,
                  <span class="st">"amount_usd"</span>: amount_usd, <span class="st">"chain"</span>: chain,
                  <span class="st">"max_slippage_pct"</span>: <span class="num">0.3</span>}).<span class="fn">json</span>()

api   = <span class="cls">PFClient</span>()
state = <span class="cls">BotState</span>()
log   = logging.<span class="fn">getLogger</span>(<span class="st">"orchestrator"</span>)

<span class="kw">def</span> <span class="fn">run_funding_cycle</span>():
    markets   = api.<span class="fn">markets</span>()
    portfolio = api.<span class="fn">portfolio_value</span>()
    rates     = {m[<span class="st">"coin"</span>]: m <span class="kw">for</span> m <span class="kw">in</span> markets}

    <span class="kw">for</span> coin, pos <span class="kw">in</span> <span class="fn">list</span>(state.funding_positions.<span class="fn">items</span>()):
        rate   = rates.<span class="fn">get</span>(coin, {}).<span class="fn">get</span>(<span class="st">"funding_rate"</span>, <span class="num">0</span>)
        earned = pos[<span class="st">"size_usd"</span>] * rate
        state.total_earned += earned
        log.<span class="fn">info</span>(<span class="st">f"[funding] {coin} rate={rate:.4%} earned=${earned:.2f} total=${state.total_earned:.2f}"</span>)
        <span class="kw">if</span> rate &lt; FUNDING_CLOSE:
            api.<span class="fn">close_trade</span>(pos[<span class="st">"perp_id"</span>])
            api.<span class="fn">swap</span>(coin, <span class="st">"USDC"</span>, pos[<span class="st">"size_usd"</span>], <span class="st">"ethereum"</span>)
            <span class="kw">del</span> state.funding_positions[coin]
            log.<span class="fn">info</span>(<span class="st">f"[funding] Closed {coin} - rate below threshold"</span>)

    top = <span class="fn">sorted</span>([m <span class="kw">for</span> m <span class="kw">in</span> markets
                  <span class="kw">if</span> m[<span class="st">"funding_rate"</span>] &gt; FUNDING_OPEN],
                 key=<span class="kw">lambda</span> x: x[<span class="st">"funding_rate"</span>], reverse=<span class="kw">True</span>)[:<span class="num">10</span>]

    <span class="kw">for</span> m <span class="kw">in</span> top:
        <span class="kw">if</span> m[<span class="st">"coin"</span>] <span class="kw">in</span> state.funding_positions: <span class="kw">continue</span>
        size = <span class="fn">min</span>(portfolio * MAX_ALLOC, <span class="num">10000</span>)
        api.<span class="fn">swap</span>(<span class="st">"USDC"</span>, m[<span class="st">"coin"</span>], size, <span class="st">"ethereum"</span>)
        perp = api.<span class="fn">open_trade</span>(m[<span class="st">"coin"</span>], <span class="st">"sell"</span>, size)
        state.funding_positions[m[<span class="st">"coin"</span>]] = {
            <span class="st">"size_usd"</span>: size, <span class="st">"perp_id"</span>: perp[<span class="st">"position_id"</span>]}
        state.trade_count += <span class="num">1</span>
        log.<span class="fn">info</span>(<span class="st">f"[funding] Opened {m['coin']} rate={m['funding_rate']:.4%} size=${size:.0f}"</span>)

<span class="kw">def</span> <span class="fn">run_stat_cycle</span>():
    markets = api.<span class="fn">markets</span>()
    prices  = {m[<span class="st">"coin"</span>]: m[<span class="st">"mark_price"</span>] <span class="kw">for</span> m <span class="kw">in</span> markets}
    btc, eth = prices[<span class="st">"BTC"</span>], prices[<span class="st">"ETH"</span>]
    spread   = math.<span class="fn">log</span>(btc) - math.<span class="fn">log</span>(eth)
    state.spread_history.<span class="fn">append</span>(spread)
    <span class="kw">if</span> <span class="fn">len</span>(state.spread_history) &lt; <span class="num">60</span>: <span class="kw">return</span>
    z = ((spread - <span class="fn">mean</span>(state.spread_history))
         / <span class="fn">max</span>(<span class="fn">stdev</span>(state.spread_history), <span class="num">1e-9</span>))
    log.<span class="fn">info</span>(<span class="st">f"[stat] BTC={btc:.0f} ETH={eth:.2f} z={z:.3f}"</span>)

    <span class="kw">if</span> state.stat_position:
        <span class="kw">if</span> <span class="fn">abs</span>(z) &lt; STAT_EXIT_Z <span class="kw">or</span> <span class="fn">abs</span>(z) &gt; STAT_STOP_Z:
            <span class="kw">for</span> pid <span class="kw">in</span> [state.stat_position[<span class="st">"btc_id"</span>],
                        state.stat_position[<span class="st">"eth_id"</span>]]:
                api.<span class="fn">close_trade</span>(pid)
            log.<span class="fn">info</span>(<span class="st">f"[stat] Closed at z={z:.3f}"</span>)
            state.stat_position = <span class="kw">None</span>
    <span class="kw">elif</span> <span class="fn">abs</span>(z) &gt; STAT_ENTRY_Z:
        portfolio = api.<span class="fn">portfolio_value</span>()
        size = <span class="fn">min</span>(portfolio * MAX_ALLOC, <span class="num">5000</span>)
        btc_side = <span class="st">"buy"</span>  <span class="kw">if</span> z &lt; <span class="num">0</span> <span class="kw">else</span> <span class="st">"sell"</span>
        eth_side = <span class="st">"sell"</span> <span class="kw">if</span> z &lt; <span class="num">0</span> <span class="kw">else</span> <span class="st">"buy"</span>
        bp = api.<span class="fn">open_trade</span>(<span class="st">"BTC"</span>, btc_side, size)
        ep = api.<span class="fn">open_trade</span>(<span class="st">"ETH"</span>, eth_side, size)
        state.stat_position = {<span class="st">"btc_id"</span>: bp[<span class="st">"position_id"</span>],
                                <span class="st">"eth_id"</span>: ep[<span class="st">"position_id"</span>]}
        state.trade_count += <span class="num">1</span>
        log.<span class="fn">info</span>(<span class="st">f"[stat] Opened z={z:.3f} BTC-{btc_side} ETH-{eth_side} ${size:.0f}"</span>)

<span class="kw">def</span> <span class="fn">main</span>():
    log.<span class="fn">info</span>(<span class="st">"Arbitrage orchestrator started"</span>)
    cycle = <span class="num">0</span>
    <span class="kw">while True</span>:
        <span class="kw">try</span>:
            <span class="fn">run_stat_cycle</span>()          <span class="cm"># runs every cycle (hourly)</span>
            <span class="kw">if</span> cycle % <span class="num">8</span> == <span class="num">0</span>:        <span class="cm"># funding check every 8 hours</span>
                <span class="fn">run_funding_cycle</span>()
        <span class="kw">except Exception</span> <span class="kw">as</span> e:
            log.<span class="fn">error</span>(<span class="st">f"Cycle error: {e}"</span>)
        cycle += <span class="num">1</span>
        time.<span class="fn">sleep</span>(<span class="num">3600</span>)

<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="fn">main</span>()
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- BACKTESTING -->
<section id="backtesting">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Backtesting</div>
      <h2 class="section-title">Validate Before You Deploy</h2>
      <p class="section-desc">Backtest your strategy against historical funding rates and price data before risking capital. The example below replays 90 days of funding data to estimate net P&amp;L and Sharpe ratio.</p>
    </div>

    <div class="reveal reveal-delay-1">
      <div class="code-block">
        <div class="code-header">
          <div class="code-dot red"></div>
          <div class="code-dot yellow"></div>
          <div class="code-dot green"></div>
          <span class="code-filename">backtest_funding.py</span>
        </div>
<span class="kw">import</span> csv, math
<span class="kw">from</span> dataclasses <span class="kw">import</span> dataclass

<span class="cm"># Load historical funding data: each row = {coin, timestamp, rate, mark_price}</span>
<span class="cm"># Source: GET /v1/markets?history=true&amp;days=90  (export to CSV)</span>

<span class="at">@dataclass</span>
<span class="kw">class</span> <span class="cls">BacktestResult</span>:
    total_pnl:    <span class="cls">float</span>
    num_trades:   <span class="cls">int</span>
    win_rate:     <span class="cls">float</span>
    max_drawdown: <span class="cls">float</span>
    sharpe_ratio: <span class="cls">float</span>

<span class="kw">def</span> <span class="fn">backtest_funding_arb</span>(
    data_path: <span class="cls">str</span>,
    open_threshold:  <span class="cls">float</span> = <span class="num">0.0005</span>,
    close_threshold: <span class="cls">float</span> = <span class="num">0.0001</span>,
    size_usd:        <span class="cls">float</span> = <span class="num">10000</span>,
    fee_pct:         <span class="cls">float</span> = <span class="num">0.0002</span>   <span class="cm"># 0.02% per leg</span>
) -&gt; <span class="cls">BacktestResult</span>:
    pnl_series, positions, trades = [], {}, []

    <span class="kw">with</span> <span class="fn">open</span>(data_path) <span class="kw">as</span> f:
        rows = <span class="fn">list</span>(csv.<span class="cls">DictReader</span>(f))

    <span class="kw">for</span> row <span class="kw">in</span> rows:
        coin  = row[<span class="st">"coin"</span>]
        rate  = <span class="fn">float</span>(row[<span class="st">"funding_rate"</span>])
        price = <span class="fn">float</span>(row[<span class="st">"mark_price"</span>])

        <span class="kw">if</span> coin <span class="kw">in</span> positions:
            period_pnl = size_usd * rate
            pnl_series.<span class="fn">append</span>(period_pnl)
            positions[coin][<span class="st">"cumulative"</span>] += period_pnl
            <span class="kw">if</span> rate &lt; close_threshold:
                entry_cost = size_usd * fee_pct * <span class="num">2</span>
                net = positions[coin][<span class="st">"cumulative"</span>] - entry_cost
                trades.<span class="fn">append</span>(net)
                <span class="kw">del</span> positions[coin]

        <span class="kw">elif</span> rate &gt; open_threshold:
            positions[coin] = {<span class="st">"size_usd"</span>: size_usd, <span class="st">"cumulative"</span>: <span class="num">0.0</span>}

    total_pnl = <span class="fn">sum</span>(trades)
    win_rate  = <span class="fn">sum</span>(<span class="num">1</span> <span class="kw">for</span> t <span class="kw">in</span> trades <span class="kw">if</span> t &gt; <span class="num">0</span>) / <span class="fn">max</span>(<span class="fn">len</span>(trades), <span class="num">1</span>)

    <span class="cm"># Max drawdown calculation</span>
    cum = <span class="num">0</span>; peak = <span class="num">0</span>; max_dd = <span class="num">0</span>
    <span class="kw">for</span> p <span class="kw">in</span> pnl_series:
        cum += p; peak = <span class="fn">max</span>(peak, cum)
        max_dd = <span class="fn">max</span>(max_dd, peak - cum)

    <span class="cm"># Annualised Sharpe ratio (3 periods/day)</span>
    n  = <span class="fn">len</span>(pnl_series)
    mu = <span class="fn">sum</span>(pnl_series) / <span class="fn">max</span>(n, <span class="num">1</span>)
    var = <span class="fn">sum</span>((p - mu) ** <span class="num">2</span> <span class="kw">for</span> p <span class="kw">in</span> pnl_series) / <span class="fn">max</span>(n, <span class="num">1</span>)
    sharpe = (mu / math.<span class="fn">sqrt</span>(var)) * math.<span class="fn">sqrt</span>(<span class="num">3</span> * <span class="num">365</span>) <span class="kw">if</span> var &gt; <span class="num">0</span> <span class="kw">else</span> <span class="num">0</span>

    <span class="kw">return</span> <span class="cls">BacktestResult</span>(
        total_pnl=<span class="fn">round</span>(total_pnl, <span class="num">2</span>),
        num_trades=<span class="fn">len</span>(trades),
        win_rate=<span class="fn">round</span>(win_rate, <span class="num">3</span>),
        max_drawdown=<span class="fn">round</span>(max_dd, <span class="num">2</span>),
        sharpe_ratio=<span class="fn">round</span>(sharpe, <span class="num">2</span>)
    )

result = <span class="fn">backtest_funding_arb</span>(<span class="st">"funding_history.csv"</span>)
<span class="fn">print</span>(<span class="st">f"90-day P&amp;L:    ${result.total_pnl:,.2f}"</span>)
<span class="fn">print</span>(<span class="st">f"Trades:         {result.num_trades}"</span>)
<span class="fn">print</span>(<span class="st">f"Win rate:       {result.win_rate:.1%}"</span>)
<span class="fn">print</span>(<span class="st">f"Max drawdown:  ${result.max_drawdown:.2f}"</span>)
<span class="fn">print</span>(<span class="st">f"Sharpe ratio:   {result.sharpe_ratio:.2f}"</span>)
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RISK WARNINGS -->
<section id="risks">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Risk Management</div>
      <h2 class="section-title">What Can Go Wrong</h2>
      <p class="section-desc">Arbitrage is not risk-free. Understanding the failure modes before deployment is what separates profitable bots from expensive lessons.</p>
    </div>

    <div class="reveal reveal-delay-1">
      <table class="risk-table">
        <thead>
          <tr>
            <th>Risk</th>
            <th>Strategy</th>
            <th>Severity</th>
            <th>Mitigation</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Funding rate flips negative</strong></td>
            <td>Funding Arb</td>
            <td class="risk-med">Medium</td>
            <td>Monitor rates in real time. Close positions if rate stays below -0.01% for two consecutive periods.</td>
          </tr>
          <tr>
            <td><strong>Liquidation on perp leg</strong></td>
            <td>Funding Arb</td>
            <td class="risk-low">Low at 1x</td>
            <td>Use 1x leverage on the perp leg. The spot hedge offsets directional moves. Monitor margin ratio, keep above 20%.</td>
          </tr>
          <tr>
            <td><strong>Slippage exceeds spread</strong></td>
            <td>Cross-Chain</td>
            <td class="risk-high">High</td>
            <td>Simulate both swap legs before committing. Reject if simulated slippage exceeds 60% of gross spread.</td>
          </tr>
          <tr>
            <td><strong>Correlation breakdown</strong></td>
            <td>Stat Arb</td>
            <td class="risk-high">High</td>
            <td>Hard stop at z-score above 3.5. Size at max 20% of portfolio. Never add to a losing stat arb position.</td>
          </tr>
          <tr>
            <td><strong>Gas price spike</strong></td>
            <td>All</td>
            <td class="risk-med">Medium</td>
            <td>Use real-time EIP-1559 base fee estimates. Cancel pending swaps if base fee has moved 5x since the scan.</td>
          </tr>
          <tr>
            <td><strong>API downtime or timeout</strong></td>
            <td>All</td>
            <td class="risk-med">Medium</td>
            <td>Implement exponential backoff with 3 retries. If one leg executes and the other fails, log and alert immediately. Do not retry the second leg without confirming the first is still open.</td>
          </tr>
          <tr>
            <td><strong>Smart contract exploit (DEX)</strong></td>
            <td>Cross-Chain</td>
            <td class="risk-high">Low probability, high impact</td>
            <td>Use only DEXs with 12+ months of mainnet history. Keep cross-chain capital below $50k per chain.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="grid-3 reveal reveal-delay-2" style="margin-top: 40px;">
      <div class="card">
        <div class="card-icon green">&#9679;</div>
        <h3>Position Sizing</h3>
        <p>Never allocate more than 20% of your portfolio to any single trade. Diversify across multiple uncorrelated arb positions simultaneously to smooth returns.</p>
      </div>
      <div class="card">
        <div class="card-icon orange">&#9888;</div>
        <h3>Emergency Kill Switch</h3>
        <p>Implement a manual kill switch that closes all positions via <code>GET /v1/trade/positions</code> followed by <code>POST /v1/trade/close</code> for each active position ID.</p>
      </div>
      <div class="card">
        <div class="card-icon blue">&#128202;</div>
        <h3>Daily Loss Limits</h3>
        <p>Set a daily loss limit at 2% of portfolio. If the bot loses more than this in any 24-hour period, halt all new trades and alert the operator before resuming.</p>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- PERFORMANCE BENCHMARKS -->
<section id="performance">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Performance</div>
      <h2 class="section-title">Realistic Expectations</h2>
      <p class="section-desc">Historical benchmarks from backtests on 2023&ndash;2024 data. Past performance does not guarantee future returns. These figures exclude tail-risk events and assume markets remain liquid.</p>
    </div>

    <div class="reveal reveal-delay-1">
      <table class="perf-table">
        <thead>
          <tr>
            <th>Strategy</th>
            <th>Capital Required</th>
            <th>Est. Monthly Return</th>
            <th>Est. Annual Return</th>
            <th>Max Drawdown (backtest)</th>
            <th>Sharpe (backtest)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Funding Rate Arb</strong></td>
            <td>$10,000</td>
            <td class="positive">$200 &ndash; $900</td>
            <td class="positive">24% &ndash; 108%</td>
            <td>$180</td>
            <td>2.1 &ndash; 3.8</td>
          </tr>
          <tr>
            <td><strong>Cross-Chain Price Arb</strong></td>
            <td>$5,000 per chain</td>
            <td class="positive">$50 &ndash; $300</td>
            <td class="positive">12% &ndash; 72%</td>
            <td>$320</td>
            <td>1.4 &ndash; 2.6</td>
          </tr>
          <tr>
            <td><strong>Statistical Arb (BTC/ETH)</strong></td>
            <td>$10,000</td>
            <td class="positive">$100 &ndash; $500</td>
            <td class="positive">12% &ndash; 60%</td>
            <td>$1,100</td>
            <td>0.8 &ndash; 1.9</td>
          </tr>
          <tr>
            <td><strong>Combined (all three)</strong></td>
            <td>$25,000</td>
            <td class="positive">$400 &ndash; $1,600</td>
            <td class="positive">19% &ndash; 77%</td>
            <td>$1,200</td>
            <td>1.6 &ndash; 2.8</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="info-box reveal reveal-delay-2">
      <p><strong>Key insight:</strong> Funding rate arbitrage dominates in bull markets (high funding rates) but yields near zero in flat or bear markets. Statistical arb performs best during high-volatility regimes with strong BTC/ETH correlation. Cross-chain arb returns are more consistent but require active capital management across chains. Running all three together smooths returns across market conditions.</p>
    </div>
  </div>
</section>

<hr class="section-divider">

<!-- RELATED LINKS -->
<section style="padding: 80px 0;">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Related Guides</div>
      <h2 class="section-title">Go deeper.</h2>
    </div>
    <div class="related-grid reveal reveal-delay-1">
      <a href="/trading-api/" class="related-card">
        <div class="label">API Reference</div>
        <div class="title">Trading API Docs</div>
        <div class="desc">275+ perp markets, funding rates, open/close positions â€” full endpoint reference</div>
      </a>
      <a href="/crypto-wallet-api/" class="related-card">
        <div class="label">API Reference</div>
        <div class="title">Crypto Wallet API</div>
        <div class="desc">Multi-chain HD wallets, cross-chain swaps, real-time balances</div>
      </a>
      <a href="/funding-rate-arbitrage/" class="related-card">
        <div class="label">Deep Dive</div>
        <div class="title">Funding Rate Arbitrage</div>
        <div class="desc">Complete guide to delta-neutral perp strategies and passive yield</div>
      </a>
    </div>
  </div>
</section>

<!-- CTA -->
<section class="cta-section">
  <div class="container">
    <div class="cta-box reveal">
      <h2>Register your arbitrage agent<br>with <span style="color: var(--purple)">both APIs.</span></h2>
      <p>One registration unlocks the Trading API (275+ perp markets, funding rates, 50x leverage) and the Wallet API (multi-chain wallets, cross-chain swaps). Free tier available.</p>
      <div class="cta-apis">
        <div class="cta-api-pill"><span class="dot"></span> trading.purpleflea.com &mdash; 275+ markets</div>
        <div class="cta-api-pill"><span class="dot"></span> wallet.purpleflea.com &mdash; 8+ chains</div>
      </div>
      <div class="hero-actions">
        <a href="https://trading.purpleflea.com" class="btn-primary" target="_blank">Register Trading API &rarr;</a>
        <a href="https://wallet.purpleflea.com" class="btn-secondary" target="_blank">Register Wallet API</a>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<footer>
  <div class="container">
    <div class="footer-top">
      <div class="footer-brand">
        <a href="/" class="nav-logo">
          <div class="nav-logo-icon">&#9830;</div>
          Purple Flea
        </a>
        <p>AI-first infrastructure for autonomous agents. Built for machines, verified by math.</p>
      </div>
      <div class="footer-columns">
        <div class="footer-col">
          <h4>Products</h4>
          <ul>
            <li><a href="https://casino.purpleflea.com" target="_blank">Casino</a></li>
            <li><a href="https://trading.purpleflea.com" target="_blank">Trading</a></li>
            <li><a href="https://wallet.purpleflea.com" target="_blank">Wallet</a></li>
            <li><a href="https://domains.purpleflea.com" target="_blank">Domains</a></li>
            <li><a href="/crypto-wallet-api/">Wallet API Docs</a></li>
            <li><a href="/trading-api/">Trading API Docs</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Developers</h4>
          <ul>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/for-agents">For Agents</a></li>
            <li><a href="/for-langchain/">LangChain</a></li>
            <li><a href="/for-crewai/">CrewAI</a></li>
            <li><a href="/for-claude/">Claude / MCP</a></li>
            <li><a href="/quick-start">Quick Start</a></li>
            <li><a href="/openapi">OpenAPI</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Company</h4>
          <ul>
            <li><a href="/pricing">Pricing</a></li>
            <li><a href="/stats">Stats</a></li>
            <li><a href="/changelog">Changelog</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="mailto:hello@purpleflea.com">Contact</a></li>
            <li><a href="https://github.com/Purple-flea" target="_blank">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 Purple Flea. All rights reserved.</p>
      <div class="footer-social">
        <a href="https://github.com/Purple-flea" target="_blank">GitHub</a>
        <a href="https://x.com/purpleflea" target="_blank">X / Twitter</a>
      </div>
    </div>
  </div>
</footer>

<script>
const navbar = document.getElementById('navbar');
window.addEventListener('scroll', () => {
  navbar.classList.toggle('scrolled', window.scrollY > 50);
});
const revealEls = document.querySelectorAll('.reveal');
const revealObs = new IntersectionObserver((entries) => {
  entries.forEach(e => {
    if (e.isIntersecting) {
      e.target.classList.add('visible');
      revealObs.unobserve(e.target);
    }
  });
}, { threshold: 0.08, rootMargin: '0px 0px -40px 0px' });
revealEls.forEach(el => revealObs.observe(el));
</script>
</body>
</html>
